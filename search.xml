<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EditText 搜索优化 | 安卓 offer 收割基]]></title>
    <url>%2F2019%2F09%2F06%2Foptimize-edittext-search%2F</url>
    <content type="text"><![CDATA[描述设计一个 EditText 的文本监听器，停止输入 1s 后，如果文本发生变化则触发监听器。 例子：文本内容是 111，111 -&gt; 1111 -&gt; 11111，连续输入都小于 1s，在输完后的 1s 触发监听器为 11111；文本内容是 111，111 -&gt; 1111 -&gt; 111，连续输入都小于 1s，在输完后的 1s 不触发监听器； 类似微信的客户端搜索，不同的是微信在 111 -&gt; 1111 -&gt; 111 是会触发改变的。 效果如下所示，注意观察 title 文本的改变： 参考答案代码很简单，结合注释参考即可，小功能从构思到编码到完成到优化，其实也是要花不少时间的，希望可以帮到你们哈。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SearchEditText extends EditText &#123; private static final long LIMIT = 1000; private OnTextChangedListener mListener; private String mStartText = "";// 记录开始输入前的文本内容 private Runnable mAction = new Runnable() &#123; @Override public void run() &#123; if (mListener != null) &#123; // 判断最终和开始前是否一致 if (!StringUtils.equals(mStartText, getText().toString())) &#123; mStartText = getText().toString();// 更新 mStartText mListener.onTextChanged(mStartText); &#125; &#125; &#125; &#125;; public SearchEditText(Context context) &#123; super(context); &#125; public SearchEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public SearchEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; /** * 在 LIMIT 时间内连续输入不触发文本变化 */ public void setOnTextChangedListener(OnTextChangedListener listener) &#123; mListener = listener; &#125; @Override protected void onTextChanged(final CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; super.onTextChanged(text, start, lengthBefore, lengthAfter); // 移除上一次的回调 removeCallbacks(mAction); postDelayed(mAction, LIMIT); &#125; @Override protected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); removeCallbacks(mAction); &#125; public interface OnTextChangedListener &#123; void onTextChanged(String text); &#125;&#125; 结语我正在打造一个帮助 Android 开发者们拿到更好 offer 的面试库————安卓 offer 收割基，欢迎 star，觉得不错的可以持续关注，有兴趣的可以一起加入进来和我一同打造。 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>安卓 offer 收割基</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AucFrame 之统一管理 Gradle]]></title>
    <url>%2F2019%2F07%2F24%2Fauc-frame-manage-gradle%2F</url>
    <content type="text"><![CDATA[前言AucFrame 往期文章： AucFrame 之简介及学习 AucFrame 之让你的 Gradle 更智能 「AucFrame 之统一管理 Gradle」源码传送门 管理 lib 的 Gradle首先，我们再看一遍 AucFrame 的架构图。 我们从下开始往上搭建，在根目录创建 lib 文件夹，在项目中新建一个 Android Library 类型的 base module，然后删除其中的 base.iml，因为不删除 base.iml 文件的话会影响后续的移动，把 androidTest 以及 test 测试目录删了也没事，然后我们把 base 文件夹移入到 lib 中，最后我们修改 setting.gradle 文件中的 &#39;:base&#39; 为 :lib:base，最后点击 Gradle 的同步即可，最终会在 lib 下生成 lib.iml，base 下生成 lib-base.iml 表示成功，结果如下所示： 同样的方式，我们创建 :lib:common，接下来配置他们的依赖关系。 我们可以看到 base 和 common 的 build.gralde 简直一毛一样，这样我们是否可以把他们都抽出去呢，答案是肯定的。 我们在项目根目录创建 buildLib.gradle 文件，代表所有 lib 类型的模块都可以使用它，我们放入公共内容即可，具体如下所示： 1234567891011121314151617181920212223242526apply &#123; plugin "com.android.library" plugin "kotlin-android" plugin "kotlin-android-extensions"&#125;android &#123; compileSdkVersion Config.compileSdkVersion defaultConfig &#123; minSdkVersion Config.minSdkVersion versionCode Config.versionCode versionName Config.versionName &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125; lintOptions &#123; abortOnError false &#125;&#125; 可以看到，我们使用到了 Config.groovy 中的属性，这样方便所有 lib 的版本都一致，说到版本一致，那么我们还要统一第三方库的依赖，很简单，我们在 Config.groovy 中创建依赖库的配置，如今它长这样： 1234567891011121314151617181920212223242526272829303132333435363738class Config &#123; static applicationId = 'com.blankj.aucframe' // TODO: MODIFY static appName = 'AucFrame' // TODO: MODIFY static compileSdkVersion = 27 // TODO: MODIFY static minSdkVersion = 21 // TODO: MODIFY static targetSdkVersion = 27 // TODO: MODIFY static versionCode = 1_000_000 // TODO: MODIFY static versionName = '1.0.0'// E.g. 1.9.72 =&gt; 1,009,072 // TODO: MODIFY static kotlin_version = '1.3.10' static support_version = '27.1.1' static leakcanary_version = '1.6.3' static depConfig = [ plugin : [ gradle: "com.android.tools.build:gradle:3.3.0", kotlin: "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version", ], support : [ appcompat_v7: "com.android.support:appcompat-v7:$support_version", design : "com.android.support:design:$support_version", multidex : "com.android.support:multidex:1.0.2", constraint : "com.android.support.constraint:constraint-layout:1.1.3", ], kotlin : "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version", utilcode : "com.blankj:utilcode:1.25.0", free_proguard: "com.blankj:free-proguard:1.0.1", swipe_panel : "com.blankj:swipe-panel:1.1", leakcanary : [ android : "com.squareup.leakcanary:leakcanary-android:$leakcanary_version", android_no_op : "com.squareup.leakcanary:leakcanary-android-no-op:$leakcanary_version", support_fragment: "com.squareup.leakcanary:leakcanary-support-fragment:$leakcanary_version", ], ]&#125; 接下来就是让 base 和 common 应用它们了，我们往 base 的 build.gradle 写入如下完整内容： 1234567891011121314151617apply &#123; from "$&#123;project.rootDir.path&#125;/buildLib.gradle"&#125;dependencies &#123; implementation fileTree(include: ['*.jar'], dir: 'libs') api Config.depConfig.utilcode api Config.depConfig.free_proguard api Config.depConfig.swipe_panel api Config.depConfig.support.appcompat_v7 api Config.depConfig.support.design api Config.depConfig.support.multidex api Config.depConfig.support.constraint api Config.depConfig.kotlin compileOnly Config.depConfig.leakcanary.android_no_op.dep&#125; 由于我们 common 模块是依赖 base 的，所以 common 的配置如下所示： 1234567apply &#123; from "$&#123;project.rootDir.path&#125;/buildLib.gradle"&#125;dependencies &#123; api project(":lib:base")&#125; 写入的内容都比较简单，我就不一一解释了，下面我们来管理 feature。 现在我们往 base 模块放两个基础类 ———— BaseApplication 和 BaseActivity，在 common 中放入两个公共类 ———— CommonApplication 和 CommonBackActivity 以及一些公共资源，具体请查阅源码，接下来让我们来管理 frature。 管理 feature 的 Gradle管理 export 的 Gradle再看一遍架构图，我们可以发现 feature 中每个 feature 中都存有 app、pkg（、export） 模块，我们自底向上来一步步操作，现在我们在根目录创建 feature 目录，在 feature 目录下创建 feature0 及 feature1 目录，和创建 base 类似，我们在 feature0 和 feature1 中创建 export 模块，注意两个 feature 中的 export 包名要区分开，我这里分别是 com.blankj.feature0.export、com.blankj.feature1.export，建立完之后的 setting.gradle 文件如下所示： 12include ':app', ':lib:base', ':lib:common', ':feature:feature0:export', ':feature:feature1:export', 由于 export 是依赖 common 的，所以两个 export 的 build.gradle 如下所示： 1234567apply &#123; from "$&#123;project.rootDir.path&#125;/buildLib.gradle"&#125;dependencies &#123; api project(":lib:common")&#125; 现在我们 gradle 同步一下，可以发现两个 export 已经被添加进来了。 管理 pkg 的 Gradle我们以相同的方式创建两个 pkg，包名分别是 com.blankj.feature0.pkg、com.blankj.feature1.pkg，建立完后的 setting.gradle 文件如下所示： 123include ':app', ':lib:base', ':lib:common', ':feature:feature0:export', ':feature:feature1:export', ':feature:feature0:pkg', ':feature:feature1:pkg' pkg 我们暂时只依赖各自的 export，后面我们会再改成全量依赖 export，所以 :feature:feature0:pkg 的 build.gradle 如下所示： 1234567apply &#123; from "$&#123;project.rootDir.path&#125;/buildLib.gradle"&#125;dependencies &#123; api project(":feature:feature0:export")&#125; :feature:feature1:pkg 的 build.gradle 同理。 gradle 同步一下，可以发现两个 pkg 已经被添加进来了，现在我们在 :feature:feature0:pkg 中添加一个 Feature0Activity，以及在 :feature:feature1:pkg 中添加一个 Feature1Activity，具体请参看源码。 管理 app 的 Gradlepkg 上层就是 mock 层了，因为这层是可选的，我们暂时先跳过，后面我们用到的时候再来搞定它，那么现在就只剩下各个 app 了，首先，我们利用类似和 buildLib.gradle 相似的方式，在根目录创建公共的 buildApp.gradle 文件，内容如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051apply &#123; plugin "com.android.application" plugin "kotlin-android" plugin "kotlin-android-extensions"&#125;android &#123; defaultConfig &#123; minSdkVersion Config.minSdkVersion versionCode Config.versionCode versionName Config.versionName applicationId Config.applicationId + suffix targetSdkVersion Config.targetSdkVersion multiDexEnabled true resValue "string", "app_name", Config.appName + suffix &#125; buildTypes &#123; debug &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; packagingOptions &#123; exclude 'META-INF/*' &#125; dexOptions &#123; preDexLibraries true javaMaxHeapSize "8g" maxProcessCount 8 dexInProcess = true &#125;&#125;dependencies &#123; // LeakCanary debugImplementation Config.depConfig.leakcanary.android debugImplementation Config.depConfig.leakcanary.support_fragment releaseImplementation Config.depConfig.leakcanary.android_no_op&#125;def getSuffix() &#123; if (project.path == ":feature:launcher:app") return "" return project.path.replace(":", "_").substring(":feature".length(), project.path.length() - ":app".length())&#125; 这样我们在每个 app 中的 build.gradle 都可以使用这些公共属性，细心的朋友应该可以看到我这边除了 launcher 以外，每个 applicationId 都是都是带有 feature 的模块名后缀的，具体方法就是 getSuffix()，方便我们在手机上同时装多个应用。 我们先删除根目录下的 app 目录，在 feature0 和 feature1 中以相同的方式创建两个 app，包名分别是 com.blankj.feature0.app、com.blankj.feature1.app，建立完后的 setting.gradle 文件如下所示： 1234include ':lib:base', ':lib:common', ':feature:feature0:export', ':feature:feature1:export', ':feature:feature0:pkg', ':feature:feature1:pkg', ':feature:feature0:app', ':feature:feature1:app' app 是只依赖各自的 pkg，所以 :feature:feature0:app 的 build.gradle 如下所示： 1234567apply &#123; from "$&#123;project.rootDir.path&#125;/buildApp.gradle"&#125;dependencies &#123; api project(":feature:feature0:pkg")&#125; :feature:feature1:app 的 build.gradle 同理。 同步一下项目可以发现两个 app 也被编译到了项目中，在可运行 app 列表中已经有了 feature0-app 和 feature1-app，如下图所示： 现在我们在 :feature:feature0:app 中添加一个 Feature0App，以及在 :feature:feature1:app 中添加一个 Feature1App，具体请参看源码，然后把设置各自的 AndroidManifest.xml，我这里以 :feature:feature0:app 中的为例： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.blankj.feature0.app"&gt; &lt;application android:name="com.blankj.feature0.app.Feature0App" android:allowBackup="false" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme"&gt; &lt;activity android:name="com.blankj.feature0.pkg.Feature0Activity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 可以发现，我们加入了 Feature0Activity 作为启动页，这样便可快速调试它，同理，:feature:feature1:app 的 AndroidManifest.xml 也是如此，此时我们便可单独运行一下它们了，由于他们的 applicationId 是不同的，所以两者可以同时安装。 下面，我们和之前上述一样的方式来创建最顶层的 :feature:launcher:app 模块，目前我们让它依赖 :feature:feature0:pkg 和 :feature:feature1:pkg 模块，后续我们会让它支持动态化配置，其 build.gradle 如下所示： 12345678apply &#123; from "$&#123;project.rootDir.path&#125;/buildApp.gradle"&#125;dependencies &#123; api project(":feature:feature0:pkg") api project(":feature:feature1:pkg")&#125; 把其加入到 setting.gradle 中，同步一下 gradle，会发现可运行 app 中多了个 launcher-app，我们创建一个 LauncherApp，这里我们假设 app 的入口就在 feature0 中，故配置 :feature:launcher:app 中的 AndroidManifest.xml 如下所示： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.blankj.feature0.app"&gt; &lt;application android:name="com.blankj.feature0.app.Feature0App" android:allowBackup="false" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme"&gt; &lt;activity android:name="com.blankj.feature0.pkg.Feature0Activity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 我们把三个应用都装到手机上，应用名分别为 AucFrame、AucFrame_feature0、AucFrame_featrue1，到此，我们统一管理 Gradle 已结束。 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>AucFrame</category>
      </categories>
      <tags>
        <tag>AucFrame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AucFrame 之让你的 Gradle 更智能]]></title>
    <url>%2F2019%2F07%2F23%2Fauc-frame-smart-gradle%2F</url>
    <content type="text"><![CDATA[前言不了解什么是 AucFrame 的可以先看一下这篇文章：AucFrame 之简介及学习 环境首先来明确下开发环境，这里推荐使用 Android Studio 3.5-Beta4 及以上的版本，3.3.x 和 3.4.x 也都是可以的，只是没有智能提示，3.2.x 及以下版本的话就不推荐使用了，否则后面的课程可能会出问题。 背景如果你开发过稍微大型点的项目，项目中肯定会存有多个 module，那么多个 gradle 的管理便成了问题，曾经我也分享过 Android 开发之版本统一规范 这样的 ext 管理方式，但在 gradle 中没有智能提示，也不能跳转到这些变量，局限性太高是个硬伤，那么现在有更好的解决方案吗？答案是肯定的，就是利用 buildSrc 来更好地管理 Gradle。 解决方案首先声明下，该方式在 AS 的 3.3.x 版本以及 3.4.x 版本是不能提供智能提示，推荐使用 3.5-Beta4 及以上的版本，相关 bug 地址传送门：https://issuetracker.google.com/issues/123032843，从修复 bug 这里可以看出 AS 团队也是赞成使用的，最新的 3.5 正式版相信马上就会到来了，我如今使用的版本是 3.5-Beta5 版本，一切如斯顺畅，效果图如下所示： 那么具体怎么操作呢，现在来揭晓其真面目，写过插件的肯定知道 buildSrc 这个目录，这个目录存在于项目根目录下，例如我这里就是 AucFrameTemplate/buildSrc，提醒一下，这个是要自己创建的哦，它默认是直接会参与编译，所以不用加入到 setting.gradle 中，具体如下图所示： 下面我们自己来建立它，首先是 .gitignore，这个文件没什么好说的，内容就是 /build。 其 build.gradle 文件如下所示： 123456789101112131415repositories &#123; google() jcenter()&#125;apply &#123; plugin 'groovy' plugin 'java-gradle-plugin'&#125;dependencies &#123; implementation gradleApi() implementation localGroovy() implementation "commons-io:commons-io:2.6"&#125; 加完这两文件后 sync 下项目后便可以看到 buildSrc 目录下生成了 buildSrc.iml，这就代表 buildSrc 已经参与到项目编译中了。 接下来我们在 buildSrc/src/main/groovy 中创建 Config.groovy 文件，向其中写入如下内容（根据项目自己修改）： 1234567891011class Config &#123; static applicationId = 'com.blankj.aucframe' // TODO: MODIFY static appName = 'AucFrame' // TODO: MODIFY static compileSdkVersion = 27 // TODO: MODIFY static minSdkVersion = 21 // TODO: MODIFY static targetSdkVersion = 27 // TODO: MODIFY static versionCode = 1_000_000 // TODO: MODIFY static versionName = '1.0.0'// E.g. 1.9.72 =&gt; 1,009,072 // TODO: MODIFY&#125; 写完后我们再同步一下项目，现在你可以跳转到 app 中的 build.gradle 中，设置你所需要设置的属性即可，可设置成如下所示： 12345678910android &#123; compileSdkVersion Config.compileSdkVersion defaultConfig &#123; minSdkVersion Config.minSdkVersion versionCode Config.versionCode versionName Config.versionName applicationId Config.applicationId targetSdkVersion Config.targetSdkVersion &#125;&#125; 你会发现在输入过程中是支持智能提示的，也可以支持跳转，如上只是基本的操作，愣着干嘛啊，赶紧扣 6 吧，接下来我们做更刺激的操作。 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>AucFrame</category>
      </categories>
      <tags>
        <tag>AucFrame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AucFrame 之简介及学习]]></title>
    <url>%2F2019%2F07%2F22%2Fauc-frame%2F</url>
    <content type="text"><![CDATA[简介首先，什么是 AUC 呢？在 QQ 群里的小伙伴们应该知道这个词，或者知道我的工具类的也应该能猜到是什么，没错，AUC 全称就是 AndroidUtilCode，这个项目的生命周期已长达 3 年之久，star 数目前是 24k+，应该算是比较成功的一个开源项目了，基于它，我打造了一套自认为还不错的组件化架构 ———— AucFrame，其优点如下所示： 统一管理项目中的 Gradle 自由选择调试模块 自由选择需要的包 自由切换源码和远程仓库 业务模块互不依赖，完全解偶 模块间通讯一学就会 比 EventBus 更高效的模块内通讯 接下来就让我们来一一揭开他的神秘面纱。 预览架构么，肯定要开门见山，直接上图，不然说的再天花乱坠也无济于事，也就是所谓的 no picture you say a j8，AucFrame 的架构如下所示： 其项目中具体的工程结构如下所示：123456789101112131415161718192021└── AndroidUtilCode ├── feature │ ├── launcher │ │ └── app │ ├── main │ │ ├── app │ │ └── pkg │ ├── mock │ ├── subutil │ │ ├── app │ │ ├── export │ │ └── pkg │ └── utilcode │ ├── app │ ├── export │ └── pkg └── lib ├── base ├── common ├── subutil └── utilcode 基于此，我们可以设计出如下通用架构： 其工程结构如下所示：123456789101112131415161718└── ProjectName ├── feature │ ├── launcher │ │ └── app │ ├── feature0 │ │ ├── app │ │ ├── export │ │ └── pkg │ ├── feature1 │ │ ├── app │ │ ├── export │ │ └── pkg │ └── mock └── lib ├── base ├── common ├── rxjava └── utilcode 对着架构图也许你也能撸出来一个，但其优雅程度肯定不及我撸的，具体如何优雅？最直接的就是 feature 下的所有模块的 build.gradle 都是空空如也，没有一行代码，甚至删了也无所谓，也就不需要你写哪个模块具体需要依赖什么，但确切的依赖关系，就是架构中所示，开发者可自由配置想要运行哪个 app，自由配置你所需要的 pkg，做到各业务可完全独立运行，下面就让我带领你如何优雅地撸出它来。 学习该教程适合期望能优化自己工程架构的中高级开发人员，新手的话建议把 Gradle 摸清楚了再来学习即可，为了你更好更全面地了解及掌握 AucFrame，在这里我会一步步地搭建一个模板工程：AucFrameTemplate，并教你如何搭建出该架构及背后的原理，方便你可以运用到你的项目中，或者在下个项目中快速使用，相关课程列表如下所示： AucFrame 之简介及学习（就是本节） AucFrame 之让你的 Gradle 更智能 AucFrame 之统一管理 Gradle AucFrame 之解放 Gradle AucFrame 之模块间通信 AucFrame 之模块内通信 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>AucFrame</category>
      </categories>
      <tags>
        <tag>AucFrame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比 EventBus 更高效的事件总线（BusUtils）]]></title>
    <url>%2F2019%2F07%2F22%2Fbusutils%2F</url>
    <content type="text"><![CDATA[背景设计这个 BusUtils 其实是在做 ApiUtils 时顺手做的，因为两者实现方式基本一致，设计前我也没想着要和 greenrobot 的 EventBus 一较高低，但设计完总需要一个对比，所以就拿业界最优秀的事件总线 EventBus 比较一下吧，然后就发现我这区区 300 行不到的 BusUtils 性能比 EventBus 要高出好多，当然，这一切的前提都是在 BusUtils 是切实可用并且有效的，它也是一款线程安全的事件总线，这些我都在单测中有做过实际测试的，不吹不擂，后面我们拿数据说话，有小伙伴不相信的话也可以通过下载我的源码来比较即可，单测地址：BusUtilsVsEventBusTest，Android 测试地址：BusCompareActivity，BusUtils 在 AucFrame 中的作用就是模块内传值，其扮演的角色如下所示： 下面介绍其使用： 使用配置在项目根目录的 build.gradle 中添加 bus 插件： 123456buildscript &#123; dependencies &#123; ... classpath 'com.blankj:bus-gradle-plugin:2.1' &#125;&#125; 然后在 application 模块中使用该插件： 1apply plugin: "com.blankj.bus" 给你的项目添加 AndroidUtilCode 依赖： 1api "com.blankj:utilcode:latest_version 如果你单纯只想引入 BusUtils 也是可以的，需要你自己拷贝一份这个类放到你工程里，记得还要拷贝 ThreadUtils 哦，然后在 app 下的 build.gradle 中 配置 bus 的 DSL 域如下所示： 1234567bus &#123; busUtilsClass "com.xxx.xxx.BusUtils"&#125;android &#123; ...&#125; 可以猜测到默认的 busUtilsClass 为 com.blankj.utilcode.util.BusUtils 哈。 如果开启混淆的话还需要配置你的 BusUtils 中注解方法的防混淆，如果直接用 AndroidUtilCode 的话是不需要你配置的，我已经帮你做完了，配置你自己的 BusUtils 防混淆应该如下所示： 1234-keepattributes *Annotation*-keepclassmembers class * &#123; @com.xxx.xxx.BusUtils$Bus &lt;methods&gt;;&#125; 当然，如果你项目是开启混淆的话，全量引入 AndroidUtilCode 也是可以的，混淆会帮你去除未使用到的类和方法。 好了，插件和依赖都配置完毕，下面介绍基本使用。 基本使用1234567891011121314151617181920212223public static final String TAG_NO_PARAM = "TagNoParam";public static final String TAG_ONE_PARAM = "TagOneParam";@BusUtils.Bus(tag = TAG_NO_PARAM)public void noParamFun() &#123;/* Do something */&#125;@BusUtils.Bus(tag = TAG_ONE_PARAM)public void oneParamFun(String param) &#123;/* Do something */&#125;@Overridepublic void onStart() &#123; super.onStart(); BusUtils.register(this);&#125;@Overridepublic void onStop() &#123; super.onStop(); BusUtils.unregister(this);&#125;BusUtils.post(TAG_NO_PARAM);// noParamFun() will receiveBusUtils.post(TAG_ONE_PARAM, "param");// oneParamFun() will receive 使用过 EventBus 的肯定一下子就能看懂。 高级使用粘性事件支持粘性事件，也就是先发送，然后在订阅的时候接收到之前发送的粘性事件，把其消费掉，使用方式和 EventBus 一致，就是在 `@BusUtils.Bus注解中设置sticky = true`，具体例子如下所示：123456789101112public static final String TAG_NO_PARAM_STICKY = "TagNoParamSticky";@BusUtils.Bus(tag = TAG_NO_PARAM_STICKY, sticky = true)public void noParamStickyFun() &#123;/* Do something */&#125;BusUtils.postSticky(TAG_NO_PARAM_STICKY);BusUtils.register(xxx);// will invoke noParamStickyFunBusUtils.removeSticky(TAG_NO_PARAM_STICKY);// When u needn't use the sticky, remove itBusUtils.unregister(xxx); 线程切换线程切换使用的是 ThreadUtils 中的线程池，它具有安全的 Cached 线程池，以及 MAIN, IO, CPU, CACHED, SINGLE 线程池，默认不设置的话就是在提交的线程 POSTING，使用的话就是在 `@BusUtils.Bus注解中设置threadMode = BusUtils.ThreadMode.xx` 即可。 规范要想工具用得舒服，规范肯定要遵守的，所谓无规矩不成方圆，不然五花八门的问题肯定一堆堆，这里推荐如下规范： 持有事件的类和函数确保确保都是 public 的。 由于 BusUtils 是用于模块内调用，所以可以写一个 BusConfig 的类来保存一个模块内所有 bus 的 Tag，方便查找到使用方及调用方。 Tag 中最好还能带有业务模块后缀名防止重复，是 sticky 类型的话也带上 sticky，指定具体线程的话也带上线程名，例如：update_avatar_sticky_main_info 这个 Tag，让人直接望文生义。 如果能结合 AucFrame 来使用，那就更规范不过了。 对 BusUtils 中事件传输的的 bean 都需要 keep 下来，否则开启混淆后会找不到该实体对象而报错。 使用已经介绍完毕，下面我们来和 EventBus 对比下性能。 性能测试首先，把两者的事件定义好，因为比较的是事件达到的快慢，所以内部都是空实现即可，具体代码如下所示： 1234567@Subscribepublic void eventBusFun(String param) &#123;&#125;@BusUtils.Bus(tag = "busUtilsFun")public void busUtilsFun(String param) &#123;&#125; BusUtils 在编译时会根据 `@BusUtils.Bus` 注解生成一份记录 tag 和 方法签名的映射表，因为是在编译时完成的，这里我们通过反射来完成。 123456@Beforepublic void setUp() throws Exception &#123; // 这一步是在 AOP 的时候注入的，这里通过反射来注入 busUtilsFun 事件，效果是一样的。 ReflectUtils getInstance = ReflectUtils.reflect(BusUtils.class).method("getInstance"); getInstance.method("registerBus", "busUtilsFun", BusUtilsVsEventBusTest.class.getName(), "busUtilsFun", String.class.getName(), "param", false, "POSTING");&#125; 通过比较如下几点的测试来完成对比： 注册 10000 个订阅者，共执行 10 次取平均值 向 1 个订阅者发送 * 1000000 次，共执行 10 次取平均值 向 100 个订阅者发送 * 100000 次，共执行 10 次取平均值 注销 10000 个订阅者，共执行 10 次取平均值 测试机器如下所示： 12macOS: 2.2GHz Intel Core i7 16GB一加6: Android 9 8GB 在 Android 上，我们加入 EventBus 的注解处理器来提升 EventBus 效率，让其在最优情况下和 BusUtils 比较。 接下来，我们把测试的模板代码写好，方便后续可以直接把两者比较的代码往回调中塞入即可，具体代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839/** * @param name 传入的测试函数名 * @param sampleSize 样本的数量 * @param times 每次执行的次数 * @param callback 比较的回调函数 */private void compareWithEventBus(String name, int sampleSize, int times, CompareCallback callback) &#123; long[][] dur = new long[2][sampleSize]; for (int i = 0; i &lt; sampleSize; i++) &#123; long cur = System.currentTimeMillis(); for (int j = 0; j &lt; times; j++) &#123; callback.runEventBus(); &#125; dur[0][i] = System.currentTimeMillis() - cur; cur = System.currentTimeMillis(); for (int j = 0; j &lt; times; j++) &#123; callback.runBusUtils(); &#125; dur[1][i] = System.currentTimeMillis() - cur; callback.restState(); &#125; long eventBusAverageTime = 0; long busUtilsAverageTime = 0; for (int i = 0; i &lt; sampleSize; i++) &#123; eventBusAverageTime += dur[0][i]; busUtilsAverageTime += dur[1][i]; &#125; System.out.println( name + "\nEventBusCostTime: " + eventBusAverageTime / sampleSize + "\nBusUtilsCostTime: " + busUtilsAverageTime / sampleSize );&#125;public interface CompareCallback &#123; void runEventBus(); void runBusUtils(); void restState();&#125; 下面就让我们来一一对比测试。 注册 10000 个订阅者，共执行 10 次取平均值123456789101112131415161718192021222324252627282930313233343536373839404142/** * 注册 10000 个订阅者，共执行 10 次取平均值 */@Testpublic void compareRegister10000Times() &#123; final List&lt;BusUtilsVsEventBusTest&gt; eventBusTests = new ArrayList&lt;&gt;(); final List&lt;BusUtilsVsEventBusTest&gt; busUtilsTests = new ArrayList&lt;&gt;(); compareWithEventBus("Register 10000 times.", 10, 10000, new CompareCallback() &#123; @Override public void runEventBus() &#123; BusUtilsVsEventBusTest test = new BusUtilsVsEventBusTest(); EventBus.getDefault().register(test); eventBusTests.add(test); &#125; @Override public void runBusUtils() &#123; BusUtilsVsEventBusTest test = new BusUtilsVsEventBusTest(); BusUtils.register(test); busUtilsTests.add(test); &#125; @Override public void restState() &#123; for (BusUtilsVsEventBusTest test : eventBusTests) &#123; EventBus.getDefault().unregister(test); &#125; eventBusTests.clear(); for (BusUtilsVsEventBusTest test : busUtilsTests) &#123; BusUtils.unregister(test); &#125; busUtilsTests.clear(); &#125; &#125;);&#125;// MacOS Output:// Register 10000 times.// EventBusCostTime: 427// BusUtilsCostTime: 41// 一加6 Output:// Register 10000 times.// EventBusCostTime: 1268// BusUtilsCostTime: 399 向 1 个订阅者发送 * 1000000 次，共执行 10 次取平均值12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 向 1 个订阅者发送 * 1000000 次，共执行 10 次取平均值 */@Testpublic void comparePostTo1Subscriber1000000Times() &#123; comparePostTemplate("Post to 1 subscriber 1000000 times.", 1, 1000000);&#125;// MacOS Output:// Post to 1 subscriber 1000000 times.// EventBusCostTime: 145// BusUtilsCostTime: 33// 一加6 Output:// Post to 1 subscriber 1000000 times.// EventBusCostTime: 1247// BusUtilsCostTime: 696private void comparePostTemplate(String name, int subscribeNum, int postTimes) &#123; final List&lt;BusUtilsVsEventBusTest&gt; tests = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; subscribeNum; i++) &#123; BusUtilsVsEventBusTest test = new BusUtilsVsEventBusTest(); EventBus.getDefault().register(test); BusUtils.register(test); tests.add(test); &#125; compareWithEventBus(name, 10, postTimes, new CompareCallback() &#123; @Override public void runEventBus() &#123; EventBus.getDefault().post("EventBus"); &#125; @Override public void runBusUtils() &#123; BusUtils.post("busUtilsFun", "BusUtils"); &#125; @Override public void restState() &#123; &#125; &#125;); for (BusUtilsVsEventBusTest test : tests) &#123; EventBus.getDefault().unregister(test); BusUtils.unregister(test); &#125;&#125; 向 100 个订阅者发送 * 100000 次，共执行 10 次取平均值12345678910111213141516/** * 向 100 个订阅者发送 * 100000 次，共执行 10 次取平均值 */@Testpublic void comparePostTo100Subscribers10000Times() &#123; comparePostTemplate("Post to 100 subscribers 100000 times.", 100, 100000);&#125;// MacOS Output:// Post to 100 subscribers 100000 times.// EventBusCostTime: 139// BusUtilsCostTime: 79// 一加6 Output:// Post to 100 subscribers 100000 times.// EventBusCostTime: 3092// BusUtilsCostTime: 2900 注销 10000 个订阅者，共执行 10 次取平均值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 注销 10000 个订阅者，共执行 10 次取平均值 */@Testpublic void compareUnregister10000Times() &#123; final List&lt;BusUtilsVsEventBusTest&gt; tests = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; BusUtilsVsEventBusTest test = new BusUtilsVsEventBusTest(); EventBus.getDefault().register(test); BusUtils.register(test); tests.add(test); &#125; compareWithEventBus("Unregister 10000 times.", 10, 1, new CompareCallback() &#123; @Override public void runEventBus() &#123; for (BusUtilsVsEventBusTest test : tests) &#123; EventBus.getDefault().unregister(test); &#125; &#125; @Override public void runBusUtils() &#123; for (BusUtilsVsEventBusTest test : tests) &#123; BusUtils.unregister(test); &#125; &#125; @Override public void restState() &#123; for (BusUtilsVsEventBusTest test : tests) &#123; EventBus.getDefault().register(test); BusUtils.register(test); &#125; &#125; &#125;); for (BusUtilsVsEventBusTest test : tests) &#123; EventBus.getDefault().unregister(test); BusUtils.unregister(test); &#125;&#125;// MacOS Output:// Unregister 10000 times.// EventBusCostTime: 231// BusUtilsCostTime: 23// 一加6 Output:// Unregister 10000 times.// EventBusCostTime: 800// BusUtilsCostTime: 199 结论为了方便观察，我们生成一份图表来比较两者之间的性能： 图表中分别对四个函数在 MacOS 和 OnePlus6 中的表现进行统计，每个函数中从左向右分别是 「MacOS 的 BusUtils」、「MacOS 的 EventBus」、「OnePlus6 的 BusUtils」、「OnePlus6 的 EventBus」，可以发现，BusUtils 在注册和注销上基本比 EventBus 要快上好几倍，BusUtils 在向少量订阅者发送多次事件比 EventBus 也快上好多，在向多个订阅者发送多次事件也比 EventBus 快上些许。 基于以上说的这么多，如果你项目中事件总线用得比较频繁，那么可以试着用我的 BusUtils 来替代 EventBus 来提升性能，或者在新的项目中，你也可以直接使用性能更好的 BusUtils。 下面来总结下 BusUtils 的优点： BusUtils 是通过事件 Tag 来确定唯一事件的，所以接收函数支持无参或者一个参数，而 EventBus 只能通过 MessageEvent 来确定具体的接收者，只能接收一个参数，即便仅仅是通知，也需要定义一个 MessageEvent，所以，BusUtils 传参更灵活。 BusUtils 在应用到项目中后，编译后便会在 application 中生成 __bus__.json 事件列表，如上生成的事件列表如下所示： 12345678&#123; "BusUtilsClass": "com.blankj.utilcode.util.BusUtils", "rightBus": &#123; "noParamFun": "&#123; desc: com.blankj.utilcode.pkg.feature.bus.BusActivity#noParamFun(), threadMode: POSTING &#125;", "oneParamFun": "&#123; desc: com.blankj.utilcode.pkg.feature.bus.BusActivity#oneParamFun(java.lang.String param), threadMode: POSTING &#125;" &#125;, "wrongBus": &#123;&#125;&#125; 修改 oneParamFun 为两个参数的话，为了确保项目不会因为 BusUtils 在运行时崩溃，api 插件会使其在编译时就不过，此时 __bus__.json 文件如下所示，提示你参数个数不对： 12345678&#123; "BusUtilsClass": "com.blankj.utilcode.util.BusUtils", "rightBus": &#123; "noParamFun": "&#123; desc: com.blankj.utilcode.pkg.feature.bus.BusActivity#noParamFun(), threadMode: POSTING &#125;", &#125;, "wrongBus": &#123; "oneParamFun": "&#123; desc: com.blankj.utilcode.pkg.feature.bus.BusActivity#oneParamFun(java.lang.String param, java.lang.String param1), threadMode: POSTING, paramSize: 2 &#125;" &#125; 同理，如果两个 bus 的 Tag 相同了，也会编译不过，提示你项目中存在 Tag 相同的 bus。（2.1 版本已支持 Tag 一对多及事件优先级） 所以，BusUtils 比 EventBus 更友好。 BusUtils 比 EventBus 代码少得太多，BusUtils 的源码只有区区 300 行，而 EventBus 3000 行肯定是不止的哈。 BusUtils 比 EventBus 性能更好。 原理bus 插件原理分析bus 插件的源码在这里：bus 插件源码传送门，该插件通过 Gradle 的 transform 来完成对 BusUtils.init() 做注入，下面来一步步分析： 不明白 transform 的可以先去了解下，简单来说 transform 就是专门用来做字节码插入操作的，最常见的就是 AOP（面向切面编程），这部分我就不科普了，有兴趣的可以自己搜索了解。 说到字节码操作，那就又有知识点了，想要上手快速简单的可以使用 javassist，不过，我选择了更强大快速的 ASM，这里我就不详细介绍了，有兴趣的可以自己去学习，ASM 其实也很简单的，在 ASM Bytecode Outline 这个插件帮助下写得还是很快的。 通过 ASM 扫描出所有带有 `@BusUtils.Bus` 注解的函数，读取并保存注解的值和函数的参数信息，相关代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@Overridepublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; className = name.replace("/", "."); super.visit(version, access, name, signature, superName, interfaces);&#125;@Overridepublic MethodVisitor visitMethod(int access, String funName, String desc, String signature, String[] exceptions) &#123; if (cv == null) return null; MethodVisitor mv = cv.visitMethod(access, funName, desc, signature, exceptions); busInfo = null; mv = new AdviceAdapter(Opcodes.ASM5, mv, access, funName, desc) &#123; @Override public AnnotationVisitor visitAnnotation(String desc1, boolean visible) &#123; final AnnotationVisitor av = super.visitAnnotation(desc1, visible); if (("L" + mBusUtilsClass + "$Bus;").equals(desc1)) &#123; busInfo = new BusInfo(className, funName); funParamDesc = desc.substring(1, desc.indexOf(")")); return new AnnotationVisitor(Opcodes.ASM5, av) &#123; @Override public void visit(String name, Object value) &#123;// 可获取注解的值 super.visit(name, value); if ("tag".equals(name)) &#123; tag = (String) value; &#125; else if ("sticky".equals(name) &amp;&amp; (Boolean) value) &#123; busInfo.sticky = true; &#125; &#125; @Override public void visitEnum(String name, String desc, String value) &#123; super.visitEnum(name, desc, value); if ("threadMode".equals(name)) &#123; busInfo.threadMode = value; &#125; &#125; &#125;; &#125; return av; &#125; @Override public void visitLocalVariable(String name, String desc, String signature, Label start, Label end, int index) &#123; super.visitLocalVariable(name, desc, signature, start, end, index);// 获取方法参数信息 if (busInfo != null &amp;&amp; !funParamDesc.equals("")) &#123; if ("this".equals(name)) &#123; return; &#125; funParamDesc = funParamDesc.substring(desc.length());// 每次去除参数直到为 ""，那么之后的就不是参数了 busInfo.paramsInfo.add(new BusInfo.ParamsInfo(Type.getType(desc).getClassName(), name)); if (busInfo.isParamSizeNoMoreThanOne &amp;&amp; busInfo.paramsInfo.size() &gt; 1) &#123; busInfo.isParamSizeNoMoreThanOne = false; &#125; &#125; &#125; @Override public void visitEnd() &#123; super.visitEnd(); if (busInfo != null) &#123; List&lt;BusInfo&gt; infoList = mBusMap.get(tag); if (infoList == null) &#123; infoList = new ArrayList&lt;&gt;(); mBusMap.put(tag, infoList); &#125; else if (infoList.size() == 0) &#123; mBusMap.put(tag, infoList); &#125; else if (infoList.size() == 1) &#123; BusInfo info0 = infoList.get(0); info0.isTagRepeat = true; busInfo.isTagRepeat = true; &#125; else &#123; busInfo.isTagRepeat = true; &#125; infoList.add(busInfo); &#125; &#125; &#125;; return mv;&#125; 然后往 BusUtils.init() 插入扫描出来的内容，比如上面提到的 oneParamFun 这个函数，那么其最终插入的代码如下所示： 1234private void init() &#123; this.registerBus("TagOneParam", "com.blankj.bus.BusTest", "oneParamFun", "java.lang.String", "param", false, "POSTING");&#125; 其 ASM 插入的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overridepublic MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123; if (!"init".equals(name)) &#123; return super.visitMethod(access, name, descriptor, signature, exceptions); &#125; // 往 init() 函数中写入 if (cv == null) return null; MethodVisitor mv = cv.visitMethod(access, name, descriptor, signature, exceptions); mv = new AdviceAdapter(Opcodes.ASM5, mv, access, name, descriptor) &#123; @Override public AnnotationVisitor visitAnnotation(String desc, boolean visible) &#123; return super.visitAnnotation(desc, visible); &#125; @Override protected void onMethodEnter() &#123; super.onMethodEnter(); &#125; @Override protected void onMethodExit(int opcode) &#123; super.onMethodExit(opcode); for (Map.Entry&lt;String, List&lt;BusInfo&gt;&gt; busEntry : mBusMap.entrySet()) &#123; List&lt;BusInfo&gt; infoList = busEntry.getValue(); if (infoList.size() != 1) continue; BusInfo busInfo = infoList.get(0); if (!busInfo.isParamSizeNoMoreThanOne) continue; mv.visitVarInsn(ALOAD, 0); mv.visitLdcInsn(busEntry.getKey()); mv.visitLdcInsn(busInfo.className); mv.visitLdcInsn(busInfo.funName); if (busInfo.paramsInfo.size() == 1) &#123; mv.visitLdcInsn(busInfo.paramsInfo.get(0).className); mv.visitLdcInsn(busInfo.paramsInfo.get(0).name); &#125; else &#123; mv.visitLdcInsn(""); mv.visitLdcInsn(""); &#125; mv.visitInsn(busInfo.sticky ? ICONST_1 : ICONST_0); mv.visitLdcInsn(busInfo.threadMode); mv.visitMethodInsn(INVOKESPECIAL, mBusUtilsClass, "registerBus", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V", false); &#125; &#125; &#125;; return mv;&#125; BusUtils 原理分析接下来看下 BusUtils.registerBus 的实现： 12345private void registerBus(String tag, String className, String funName, String paramType, String paramName, boolean sticky, String threadMode) &#123; mTag_BusInfoMap.put(tag, new BusInfo(className, funName, paramType, paramName, sticky, threadMode));&#125; 很简单，就是往 mTag_BusInfoMap 中插入了 key 为 tag，value 为 BusInfo 的一个实例，这样便把一个事件保留了下来。 接下来就是使用了，一开始我们都是先 register，源码如下所示： 1234567891011121314151617public static void register(final Object bus) &#123; getInstance().registerInner(bus);&#125;private void registerInner(final Object bus) &#123; if (bus == null) return; String className = bus.getClass().getName(); synchronized (mClassName_BusesMap) &#123; Set&lt;Object&gt; buses = mClassName_BusesMap.get(className); if (buses == null) &#123; buses = new CopyOnWriteArraySet&lt;&gt;(); mClassName_BusesMap.put(className, buses); &#125; buses.add(bus); &#125; processSticky(bus);&#125; 我们获取 bus 的类名，然后对 mClassName_BusesMap 加锁来把它插入到 mClassName_BusesMap 的 value 的集合中，可以看到我们用了线程安全的 CopyOnWriteArraySet 集合，然后还需要处理下之前是否订阅过粘性事件 processSticky，到这里 register 便结束了。 然后就是 post 来发送事件了，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public static void post(final String tag) &#123; post(tag, NULL);&#125;public static void post(final String tag, final Object arg) &#123; getInstance().postInner(tag, arg);&#125;private void postInner(final String tag, final Object arg) &#123; postInner(tag, arg, false);&#125;private void postInner(final String tag, final Object arg, final boolean sticky) &#123; BusInfo busInfo = mTag_BusInfoMap.get(tag); if (busInfo == null) &#123; Log.e(TAG, "The bus of tag &lt;" + tag + "&gt; is not exists."); return; &#125; if (busInfo.method == null) &#123; Method method = getMethodByBusInfo(busInfo); if (method == null) &#123; return; &#125; busInfo.method = method; &#125; invokeMethod(tag, arg, busInfo, sticky);&#125;private Method getMethodByBusInfo(BusInfo busInfo) &#123; try &#123; if ("".equals(busInfo.paramType)) &#123; return Class.forName(busInfo.className).getDeclaredMethod(busInfo.funName); &#125; else &#123; return Class.forName(busInfo.className).getDeclaredMethod(busInfo.funName, Class.forName(busInfo.paramType)); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null;&#125;private void invokeMethod(final String tag, final Object arg, final BusInfo busInfo, final boolean sticky) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; realInvokeMethod(tag, arg, busInfo, sticky); &#125; &#125;; switch (busInfo.threadMode) &#123; case "MAIN": Utils.runOnUiThread(runnable); return; case "IO": ThreadUtils.getIoPool().execute(runnable); return; case "CPU": ThreadUtils.getCpuPool().execute(runnable); return; case "CACHED": ThreadUtils.getCachedPool().execute(runnable); return; case "SINGLE": ThreadUtils.getSinglePool().execute(runnable); return; default: runnable.run(); &#125;&#125;private void realInvokeMethod(final String tag, Object arg, BusInfo busInfo, boolean sticky) &#123; Set&lt;Object&gt; buses = mClassName_BusesMap.get(busInfo.className); if (buses == null || buses.size() == 0) &#123; if (!sticky) &#123; Log.e(TAG, "The bus of tag &lt;" + tag + "&gt; was not registered before."); return; &#125; else &#123; return; &#125; &#125; try &#123; if (arg == NULL) &#123; for (Object bus : buses) &#123; busInfo.method.invoke(bus); &#125; &#125; else &#123; for (Object bus : buses) &#123; busInfo.method.invoke(bus, arg); &#125; &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125;&#125; 可以看到代码还是比较多的，不过别急，我们一步步来还是很简单的，首先在我们之前注入的 mTag_BusInfoMap 中查找是否有该 tag 的 BusInfo，没有的话就输出错误日志直接返回。 然后我们根据获取到的 BusInfo 来找到 method 实例，BusInfo 第一次会把 method 保存在实例中，之后调用的话直接从实例中取出 method 即可。 接着我们从 BusInfo 中取出线程信息，最后在线程中执行 method 的反射，大体就是这样，具体细节的话还是需要自己分析源码。 最后就是 unregister 了： 12345678910111213141516public static void unregister(final Object bus) &#123; getInstance().unregisterInner(bus);&#125;private void unregisterInner(final Object bus) &#123; if (bus == null) return; String className = bus.getClass().getName(); synchronized (mClassName_BusesMap) &#123; Set&lt;Object&gt; buses = mClassName_BusesMap.get(className); if (buses == null || !buses.contains(bus)) &#123; Log.e(TAG, "The bus of &lt;" + bus + "&gt; was not registered before."); return; &#125; buses.remove(bus); &#125;&#125; unregister 和 register 相反，就是从 mClassName_BusesMap 的 value 集合中移除，同样需要对 mClassName_BusesMap 加锁哦。 Change Log打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>AucFrame</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>AucFrame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一学就会的模块间通讯（ApiUtils）]]></title>
    <url>%2F2019%2F07%2F22%2Fapiutils%2F</url>
    <content type="text"><![CDATA[背景随着项目业务越来越多，开发出一套好的组件化方案势在必行，如果还在探寻一套好的组件化架构，那么 AucFrame 想必会是你的菜。 组件化方案中各业务是相互隔离的，所以两个业务模块要通信的话，就需要通过路由或者接口下沉来完成，业界的方案都无法与 AucFrame 完美融合，所以我就只好自己动手来完成一个更方便、精简、完美的 ApiUtils，它功能类似 SPI，但比 SPI 更适合于 Android，而且功能更强大。 在 AucFrame 架构中，我们可以通过 ApiUtils 来自由调用各模块的 apis，各业务通过对外提供的 export 模块来供其他业务方使用，自身只需要实现自身的 export 中的 apis 即可。其 AucFrame 的架构图如下所示： ApiUtils 扮演的角色如下所示： 图中还有提到 BusUtils，这是一个比 EventBus 更高效的模块内通讯工具，想了解的可以点进去看看哈。当然，ApiUtils 不仅在 AucFrame 中可以使用，在正常项目中你也可以使用它来做业务隔离，下面来介绍其具体使用方式。 使用配置在项目根目录的 build.gradle 中添加 api 插件： 123456buildscript &#123; dependencies &#123; ... classpath 'com.blankj:api-gradle-plugin:1.0' &#125;&#125; 然后在 application 模块中使用该插件： 1apply plugin: "com.blankj.api" 给你的项目添加 AndroidUtilCode 依赖： 1api "com.blankj:utilcode:latest_version" 如果你单纯只想引入 ApiUtils 也是可以的，需要你自己拷贝一份这个类放到你工程里，然后在 app 下的 build.gradle 中 配置 api 的 DSL 域如下所示： 1234567api &#123; apiUtilsClass "com.xxx.xxx.ApiUtils"&#125;android &#123; ...&#125; 可以猜测到默认的 apiUtilsClass 为 com.blankj.utilcode.util.ApiUtils 哈。 当然，如果你项目是开启混淆的话，全量引入 AndroidUtilCode 也是可以的，混淆会帮你去除未使用到的类和方法。 例子插件和依赖都配置完毕，下面就让我们在项目中使用吧，举一个实际的例子，比如 login 模块中存在 LoginActivity，main 模块存在 MainActivity，这两个模块是平行的关系，两者互不依赖，现在我们通过 ApiUtils 让 LoginActivity 来启动 MainActivity，在 AucFrame 中每个业务模块下都有 export 模块，类似于你们自己项目中的底层公共模块，因为是 login 来调用 main 模块，所以是 mian 模块需要提供 api 来供 login 来调，所以我们在 main 的 export 中加入一个继承自 ApiUtils.BaseApi 的抽象类 MainApi，并添加启动 MainActivity 的抽象方法，我们把方法搞得更复杂点，带上自定义的参数和返回值，具体如下所示： 12345678910111213141516171819202122232425262728293031323334353637public abstract class MainApi extends ApiUtils.BaseApi &#123; public abstract MainResult startMainActivity(Context context, MainParam param);&#125;public class MainParam &#123; private String name; public MainParam(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class MainResult &#123; private String name; public MainResult(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 接下来我们在 main 模块新建 MainApiImpl 去实现这个抽象类，但需要额外做一步，对该实现类加一个 `@ApiUtils.Api` 注解，该注解是提供给 api 插件注入使用的，后面原理分析会提到，而且需要保证只能有一个空参的构造函数，因为后续调用的时候会用无参构造来生成实例，具体如下所示： 12345678@ApiUtils.Apipublic class MainApiImpl extends MainApi &#123; @Override public MainResult startMainActivity(Context context, MainParam param) &#123; MainActivity.start(context, param); return new MainResult("result"); &#125;&#125; 关于各模块的 impl 我建议最好放在各模块包名的最外层，这样方便打开这个模块源码就能找到这个模块向外暴露的 apis。 注解 `@ApiUtils.Api中还提供了一个isMock的值，该值默认是false，所以如上注解相当于@ApiUtils.Api(isMock = false)，该值代表该接口是否用于 mock，一个api在项目中只有一个实现，所以在单模块调试的时候，该模块在通过ApiUtils调用其他模块api的时候，因为其他模块没有依赖进来，所以此时就需要 mock 其他模块的api，防止因为找不到其他模块的api而 crash，在 **[AucFrame](https://github.com/Blankj/AucFrameTemplate)** 中的mock层中我们就是这么做的，比如login模块在单独调试的时候，此时main模块是不存在的，我们就要写一个 mock 的api` 如下所示： 12345678@ApiUtils.Api(isMock = true)public class MainApiMockImpl extends MainApi &#123; @Override public MainResult startMainActivity(Context context, MainParam param) &#123; ToastUtils.showLong("Start MainActivity succeed."); return new MainResult("mock result"); &#125;&#125; 当 MainApiImpl 和 MainApiMockImpl 同时存在的时候，api 插件会让 isMock = false 为最终的 api 实现类，也就是 MainApiImpl，在 AucFrame 中，mock 层是在非全量 pkg 的情况下才会参与编译，所以不用担心最终全量的 app 中存有 mock 的冗余操作。 下面就让我们在 login 中通过 ApiUtils 来调用 mian 提供的 api 吧，如下所示： 12MainResult result = ApiUtils.getApi(MainApi.class) .startMainActivity(LoginActivity.this, new MainParam("MainParam")); 这里说明下，ApiUtils.getApi(MainApi.class) 这一步是懒加载的，也就是只会在第一次调用的时候才初始化，所以不用担心初始化的时候把所有业务 api 都一股脑实现降低效率的风险。 现在，我们便可以运行一下查看是否可以跳转成功，api 插件还会在你的 application 目录下生成一份 __api__.json 的 api 列表文件，具体如下所示： 1234567&#123; "ApiUtilsClass": "com.blankj.utilcode.util.ApiUtils", "implApis": &#123; "com/blankj/main/export/api/MainApi": "&#123; implApiClass: com/blankj/main/pkg/MainApiImpl, isMock: false &#125;" &#125;, "noImplApis": []&#125; 如果项目中并没有实现 MainApi 的话，为了确保项目不会因为 ApiUtils 在运行时崩溃，api 插件会使其在编译时就不通过，此时 __api__.json 文件如下所示，提示你需要实现 MainApi： 1234567&#123; "ApiUtilsClass": "com.blankj.utilcode.util.ApiUtils", "implApis": &#123;&#125;, "noImplApis": [ "com/blankj/main/export/api/MainApi" ]&#125; 好了，使用已经介绍完毕了，看完是不是觉得还不错，6 着干嘛，赶紧扣愣吧，结合 AucFrame 使用简直美哉哈。 规范要想工具用得舒服，规范肯定要遵守的，所谓无规矩不成方圆，不然五花八门的问题肯定一堆堆，这里推荐如下规范： impl 和 api 应该都是 public 的，而且 impl 中应该只存在一个无参的 public 构造函数（默认不写即可）。 api 中接口的修改我们遵循类似于官方 Android SDK 的升级，大部分情况是新接口的出现需要兼容老接口，如果老接口并不影响功能的正常使用，也就无需通知业务方更新为新接口，新的接口一般都是新的业务方来调用；除非老的接口存有问题或漏洞，我们明确需要删除它，那在删除它的同时，我们还需要把业务中调用老接口的地方统一替换为新的接口，类似于我们升级 Android SDK 的时候，某些 api 明确被官方删除了，那我们就需要强行替换为新的接口。还是上面的跳转 main 的例子，由于新的业务在跳转的时候需新增一个 UserInfo 的参数，具体如下所示：12345678910111213141516// oldpublic abstract class MainApi extends ApiUtils.BaseApi &#123; public abstract MainResult startMainActivity(Context context, MainParam param);&#125;// goodpublic abstract class MainApi extends ApiUtils.BaseApi &#123; public abstract MainResult startMainActivity(Context context, MainParam param); public abstract MainResult startMainActivity(Context context, MainParam param, UserInfo info);&#125;// don'tpublic abstract class MainApi extends ApiUtils.BaseApi &#123; public abstract MainResult startMainActivity(Context context, MainParam param, UserInfo info);&#125; 如果删除或修改老的接口的话，会导致其他模块还没来得及更新你的接口，从而调用你老的接口直接编译不过的问题。 把 impl 放在业务包的最外层，开门见山，方便寻找。 如果能结合 AucFrame 来使用，那就更规范不过了。 原理api 插件原理分析api 插件的源码在这里：api 插件源码传送门，该插件通过 Gradle 的 transform 来完成对 ApiUtils.init() 做注入，下面来一步步分析： 不明白 transform 的可以先去了解下，简单来说 transform 就是专门用来做字节码插入操作的，最常见的就是 AOP（面向切面编程），这部分我就不科普了，有兴趣的可以自己搜索了解。 说到字节码操作，那就又有知识点了，想要上手快速简单的可以使用 javassist，不过，我选择了更强大快速的 ASM，这里我就不详细介绍了，有兴趣的可以自己去学习，ASM 其实也很简单的，在 ASM Bytecode Outline 这个插件帮助下写得还是很快的。 通过 ASM 扫描出所有继承自 ApiUtils.BaseApi 的类，以及所有带有 `@ApiUtils.Api` 注解的类，然后保存起来，相关代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; className = name; superClassName = superName; if ((mApiUtilsClass + "$BaseApi").equals(superName)) &#123; mApiClasses.add(name); &#125; super.visit(version, access, name, signature, superName, interfaces);&#125;@Overridepublic AnnotationVisitor visitAnnotation(String desc, boolean visible) &#123; if (("L" + mApiUtilsClass + "$Api;").equals(desc)) &#123; hasAnnotation = true; return new AnnotationVisitor(Opcodes.ASM5, super.visitAnnotation(desc, visible)) &#123; @Override public void visit(String name, Object value) &#123;// 可获取注解的值 isMock = (boolean) value; super.visit(name, value); &#125; &#125;; &#125; return super.visitAnnotation(desc, visible);&#125;@Overridepublic void visitEnd() &#123; super.visitEnd(); if (hasAnnotation) &#123; if (!isMock) &#123;// 如果不是 mock 的话 ApiInfo apiInfo = mApiImplMap.get(superClassName); if (apiInfo == null) &#123; mApiImplMap.put(superClassName, new ApiInfo(className, false)); &#125; else &#123;// 存在一个 api 多个实现就报错 errorStr = "&lt;" + className + "&gt; and &lt;" + apiInfo.implApiClass + "&gt; impl same api of &lt;" + superClassName + "&gt;"; &#125; &#125; else &#123;// mock 的话，如果 map 中已存在就不覆盖了 if (!mApiImplMap.containsKey(superClassName)) &#123; mApiImplMap.put(superClassName, new ApiInfo(className, true)); &#125; &#125; &#125;&#125; 然后往 ApiUtils.init() 插入扫描出来的内容，比如上面举例的 MainApi，那么其最终插入的代码如下所示： 123private void init() &#123; this.registerImpl(MainApiImpl.class);&#125; 其 ASM 插入的代码如下所示： 1234567891011121314151617181920212223242526272829@Overridepublic MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123; if (!"init".equals(name)) &#123; return super.visitMethod(access, name, descriptor, signature, exceptions); &#125; // 往 init() 函数中写入 if (cv == null) return null; MethodVisitor mv = cv.visitMethod(access, name, descriptor, signature, exceptions); mv = new AdviceAdapter(Opcodes.ASM5, mv, access, name, descriptor) &#123; @Override public AnnotationVisitor visitAnnotation(String desc, boolean visible) &#123; return super.visitAnnotation(desc, visible); &#125; @Override protected void onMethodEnter() &#123; super.onMethodEnter(); &#125; @Override protected void onMethodExit(int opcode) &#123; super.onMethodExit(opcode); for (Map.Entry&lt;String, ApiInfo&gt; apiImplEntry : mApiImplMap.entrySet()) &#123; mv.visitVarInsn(Opcodes.ALOAD, 0); mv.visitLdcInsn(Type.getType("L" + apiImplEntry.getValue().implApiClass + ";")); mv.visitMethodInsn(Opcodes.INVOKESPECIAL, mApiUtilsClass, "registerImpl", "(Ljava/lang/Class;)V", false); &#125; &#125; &#125;; return mv;&#125; ApiUtils 原理分析接下来看下 ApiUtils.registerImpl 的实现： 123private void registerImpl(Class implClass) &#123; mInjectApiImplMap.put(implClass.getSuperclass(), implClass);&#125; 很简单，就是往 mInjectApiImplMap 中插入了 key 为 MainApiImpl 的父类：MainApi 的 class，value 为 MainApiImpl 的 class。 后面就让我们来看具体调用 getApi 的操作吧： 1234567891011121314151617181920212223242526272829303132public static &lt;T extends BaseApi&gt; T getApi(@NonNull final Class&lt;T&gt; apiClass) &#123; return getInstance().getApiInner(apiClass);&#125;private &lt;Result&gt; Result getApiInner(Class apiClass) &#123; BaseApi api = mApiMap.get(apiClass); if (api == null) &#123; synchronized (this) &#123; api = mApiMap.get(apiClass); if (api == null) &#123; Class implClass = mInjectApiImplMap.get(apiClass); if (implClass != null) &#123; try &#123; api = (BaseApi) implClass.newInstance(); mApiMap.put(apiClass, api); &#125; catch (Exception ignore) &#123; Log.e(TAG, "The &lt;" + implClass + "&gt; has no parameterless constructor."); return null; &#125; &#125; else &#123; Log.e(TAG, "The &lt;" + apiClass + "&gt; doesn't implement."); return null; &#125; &#125; &#125; &#125; //noinspection unchecked return (Result) api;&#125;public abstract static class BaseApi &#123;&#125; 这段代码很好理解，而且加了同步锁操作，防止多线程生成多个 impl，然后，根据传进来的 api 的 class，我们通过注入的 map 中找到具体的 impl 的 class，如果缓存中有就取缓存中的，没有的话就通过 newInstance 来实例化一个 impl，并放入缓存中，最终返回其 impl。因为是通过 newInstance 来实例化 impl，这也解释了为什么 impl 中需保留无参构造函数，而且只有在使用时才会初始化，而不是一股脑把所有的 api 都初始化。 简易实用，不到 100 行代码实现模块间跳转的 ApiUtils 已介绍完毕，接下来你就可以小试牛刀了。 Change Log打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>AucFrame</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>AucFrame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几需一行代码完成多语言切换]]></title>
    <url>%2F2019%2F06%2F29%2Fonly-one-code-change-language%2F</url>
    <content type="text"><![CDATA[背景之前总是有开发者反馈我应用切换了语言，可是工具类获取的 string 却没有发生改变。其实这个问题很简单，你切换语言的 Context 只作用在了你的 Activity 上，并没有对你的 Application 做同样的操作，知道了这点，那么解决问题就很简单了，为了省事，我给大家封装了 LanguageUtils，直接一行代码便可完成多语言的切换，类似微信的语言切换分分钟便可完成。 使用Gradle:1implementation 'com.blankj:utilcode:latest_version' APIs 语言相关 -&gt; LanguageUtils.java -&gt; Demo12applySystemLanguage: 应用系统语言applyLanguage : 应用语言 原理如果我们的应用不设置 android:configChanges=&quot;locale|layoutDirection&quot;，那么应用是跟随系统语言设置的变化而变化的，比如你应用适配了英语（values-en-rUS）和简体中文（values-zh-rCN），那么你去设置里切换成英语的话，返回到你应用中，你的 Activity 会重新创建一遍，把 Activity#Resource#Configuration#Locale 设置为当前系统语言，这样就达到了跟随系统语言设置的变化而变化，但 Application 并没有重启，所以这就导致了一开说到的问题。 要解决跟随系统变化这一点的话，只需要在 Activity#onCreate 的生命周期中把 Application#Resource#Configuration#Locale 设置为系统的 Locale 即可，那么系统的 Locale 怎么读取呢，知道之前屏幕适配方案的人应该也能想到这一方式：Resources.getSystem().getConfiguration().locale，这样，我们的 Application 便也切换成了系统语言，注意更新 Locale 需要兼容下高版本，调用具体代码可以参照如下： 1234567891011121314151617private static void updateLanguage(Context context, Locale locale) &#123; Resources resources = context.getResources(); Configuration config = resources.getConfiguration(); Locale contextLocale = config.locale; if (equals(contextLocale.getLanguage(), locale.getLanguage()) &amp;&amp; equals(contextLocale.getCountry(), locale.getCountry())) &#123; return; &#125; DisplayMetrics dm = resources.getDisplayMetrics(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; config.setLocale(locale); context.createConfigurationContext(config); &#125; else &#123; config.locale = locale; &#125; resources.updateConfiguration(config, dm);&#125; 那么如果是应用内切换语言呢？我们可以仿照系统切换语言的方式，把我们自己所有的 Activity 全关掉，然后启动首页的 Activity 即可，在打开的 Activity#onCreate 中把 Activity 和 Application 的 Locale 都设置为我们设置的语言即可，当然，这份设置是需要保存下来的，根据你的需求来确定是要保存在服务端还是本地。那么怎么关闭所有的 Activity 呢?我们可以通过增加 Intent 的 flag 为 Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK 即可，相关代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041private static void applyLanguage(@NonNull final Locale locale, final String activityClassName, final boolean isFollowSystem) &#123; if (isFollowSystem) &#123;// 如果是跟随系统，那么 sp 就什么都不存 SPUtils.getInstance().put(KEY_LOCALE, ""); &#125; else &#123;// 否则把设置的语言保存下来，在 onCreate 中应用该语言 String localLanguage = locale.getLanguage(); String localCountry = locale.getCountry(); SPUtils.getInstance().put(KEY_LOCALE, localLanguage + "$" + localCountry); &#125; updateLanguage(Utils.getApp(), locale);// 更新 Application 的语言 Intent intent = new Intent(); String realActivityClassName// 如果传入的 activityClassName 为空，那么启动 launcher Activity。 = TextUtils.isEmpty(activityClassName) ? getLauncherActivity() : activityClassName; intent.setComponent(new ComponentName(Utils.getApp(), realActivityClassName)); intent.addFlags( Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK ); Utils.getApp().startActivity(intent);// 关闭其他 Activity 并启动 realActivityClassName 的 Activity&#125;// 工具类调用此函数是在 ActivityLifecycleCallbacks#onActivityCreated 中static void applyLanguage(@NonNull final Activity activity) &#123; final String spLocale = SPUtils.getInstance().getString(KEY_LOCALE);// 获取保存的语言 if (TextUtils.isEmpty(spLocale)) &#123;// 为空说明是跟随系统走，那么更新系统语言即可 Locale sysLocale = Resources.getSystem().getConfiguration().locale; updateLanguage(Utils.getApp(), sysLocale); updateLanguage(activity, sysLocale); return; &#125; // 读取 sp 保存下来的语言并应用该语言 String[] language_country = spLocale.split("\\$"); if (language_country.length != 2) &#123; Log.e("LanguageUtils", "The string of " + spLocale + " is not in the correct format."); return; &#125; Locale settingLocale = new Locale(language_country[0], language_country[1]); updateLanguage(Utils.getApp(), settingLocale); updateLanguage(activity, settingLocale);&#125; 基于以上分析： 如果应用是跟随系统设置语言来切换的话，那么直接依赖我的工具类即可，它会自动帮你更新 Application 的语言。 如果需要应用内切换语言的话，只需在你切换语言的地方调用 LanguageUtils.applyLanguage(Locale.你要设置的语言, &quot;com.blankj.launcher.pkg.MainActivity/* 切换语言后你要跳转到的页面，如果为空，则启动应用的 launcher Activity */&quot;) 即可； 如果需要应用内切换语言变为跟随系统设置语言，那么调用 LanguageUtils.applySystemLanguage(&quot;&quot;/* 切换语言后你要跳转到的页面，如果为空，则启动应用的 launcher Activity */); 即可。 结语功能其实很简单，但总是缺少人能把它分析得透彻，从而做得很完美分享出来，希望我这次的分享能让你看到这一点，从而提升你之后的技能。 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 侧划，如斯优雅]]></title>
    <url>%2F2019%2F04%2F24%2Fswipe-panel%2F</url>
    <content type="text"><![CDATA[Background对市面上实现的侧划返回不是很满意（仿微信，QQ 通过修改窗口透明坑太多），最终决定还是亲手写一个高实用性的吧，效果如下所示，换个图标，更多划动功能可以由你自己解锁，总共一个 600 多行代码的类，推荐通过阅读源码，你肯定会收获很多哈。 Preview Download源码地址：SwipePanel，喜欢的记得给个小星星哈。 Gradle:1implementation 'com.blankj:swipe-panel:1.0' How to use动态1234567891011final SwipePanel swipePanel = new SwipePanel(this);swipePanel.setLeftEdgeSize(SizeUtils.dp2px(100));// 设置左侧触发阈值 100dpswipePanel.setLeftDrawable(R.drawable.base_back);// 设置左侧 iconswipePanel.wrapView(findViewById(R.id.rootLayout));// 设置嵌套在 rootLayout 外层swipePanel.setOnFullSwipeListener(new SwipePanel.OnFullSwipeListener() &#123;// 设置完全划开松手后的监听 @Override public void onFullSwipe(int direction) &#123; finish(); swipePanel.close(direction);// 关闭 &#125;&#125;); 静态1234567891011121314151617&lt;com.blankj.swipepanel.SwipePanel xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/swipePanel" android:background="@color/mediumGray" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".LayoutSwipePanelActivity" app:isLeftCenter="false" app:leftEdgeSize="100dp" app:leftSwipeColor="@color/colorPrimary" app:leftDrawable="@drawable/base_back"&gt; ...&lt;/com.blankj.swipepanel.SwipePanel&gt; API 方法名 属性名 说明 setLeft(Top, Right, Bottom)SwipeColor app:left(top, right, bottom)SwipeColor 设置左（上、右、下）测颜色 setLeft(Top, Right, Bottom)EdgeSize app:left(top, right, bottom)EdgeSize 设置左（上、右、下）测触发阈值 setLeft(Top, Right, Bottom)Drawable app:left(top, right, bottom)Drawable 设置左（上、右、下）测 icon setLeft(Top, Right, Bottom)Center app:isLeft(Top, Right, Bottom)Center 设置左（上、右、下）测是否居中 setLeft(Top, Right, Bottom)Enabled app:isLeft(Top, Right, Bottom)Enabled 设置左（上、右、下）测是否可用 wrapView — 设置嵌套在该 view 的外层 setOnFullSwipeListener — 设置完全划开松手后的监听 isOpen — 判断是否被划开 close — 关闭 Change Log打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 屏幕适配终结者]]></title>
    <url>%2F2018%2F12%2F18%2Fandroid-adapt-screen-killer%2F</url>
    <content type="text"><![CDATA[背景之前基于头条的适配方案写了篇文章 Android 屏幕适配从未如斯简单，但后续发现还是有挺多坑的，这些坑都记录在了 GitHub 屏幕适配问题汇总及解决，基于这么多坑，最终我发现了一种更完美的适配方案，本打算一个多月前就写这篇文章的，但由于公司事务繁忙一直抽不出空来，拖更到现在才发布，下面就让我来分享下此法，先来吹下优点吧。 优点1. 无侵入性首先科普下 Android 中的一个长度单位：pt，它表示一个点，是屏幕的物理尺寸，其大小为 1 英寸的 1 / 72，也就是 72pt 等于 1 英寸（其实 Android 中还有比较少见的 in 和 mm 的长度单位）。而我本次的适配使用的单位恰好是 pt，所以对你从前使用的布局不会造成任何影响，在老项目中开发新功能你可以胆大地加入该适配方案，新项目的话更可以毫不犹豫地采用该适配，并且在关闭该关闭后，pt 效果等同于 dp 哦。 2. 灵活性高如果你想要对某个 View 做到不同分辨率的设备下，使其尺寸在适配维度上所占比例一致的话，那么对它使用 pt 单位即可，如果你不想要这样的效果，而是想要更大尺寸的设备显示更多的内容，那么你可以像从前那样写 dp、sp 什么的即可，结合这两点，在界面布局上你就可以游刃有余地做到你想要的效果。 3. 不会影响系统 View 和三方 View 的大小这点其实在无侵入性中已经表现出来了，由于头条的方案是直接修改 DisplayMetrics#density 的 dp 适配，这样会导致系统 View 尺寸和原先不一致，比如 Dialog、Toast、 尺寸，同样，三方 View 的大小也会和原先效果不一致，这也就是我选择 pt 适配的原因之一。 4. 不会失效这一点是最值得吹牛的，因为不论头条的适配还是 AndroidAutoSize，都会存在 DisplayMetrics#density 被还原的情况，需要自己重新设置回去，最显著的就是界面中存在 WebView 的话，由于其初始化的时候会还原 DisplayMetrics#density 的值导致适配失效，当然这点已经有解决方案了，但还会有很多其他情况会还原 DisplayMetrics#density 的值导致适配失效。而我这方案就是为了解决这个痛点，不让 DisplayMetrics 中的值被还原导致适配失效。 效果说了这么多，先上下效果图压压惊吧，每种分辨率的图依次是宽度 1080pt 适配，高度 1920pt 适配以及关闭适配的效果。 480 x 800 - mdpi(160dpi) 720 x 1280 - xhdpi(320dpi) 1080 x 1920 - xxhdpi(480dpi) 1440x2560 - 560dpi 可以看到效果图中 WebView 对之后的 View 并没有产生适配失效的问题，这是之前适配所不能解决的问题。 如何根据设计图创建预览？在 AS 中 Tools -&gt; AVD Manager -&gt; Create Virtual Device...，我们以适配 1080 x 1920px 为例，具体操作如下： 创建完设备我们在预览界面选中这个设备即可看到 pt 单位效果。 设计师给你的设计图尺寸是多少，那你就建多少尺寸的设备即可，比如是 720 x 1280px 的，那你把上图的尺寸换成 720 和 1280，再计算下屏幕尺寸即可，如果是 360 x 640dp 的话，那就把上图的尺寸换成 360 和 640，再计算下屏幕尺寸即可，不用去 care 单位到底是什么，设计图标注多少那你就写多少即可，无需换算。适配的时候传入这个维度的尺寸值即可，比如 720 x 1280 的宽度适配，那就传入 720 即可。 原理及用法原理其实也是基于头条的原理，不过我是操作 pt，所以不是改 DisplayMetrics#density，而是 DisplayMetrics#xdpi，由于适配不会失效，所以需要在适配的 Activity 中重写下 getResources() 函数，因为每次 View 在变更尺寸时都会调用到 getResources()，所以我们直接在这里进行适配就不会导致失效，效果图中对应的代码分别如下所示： 1234567891011override fun getResources(): Resources &#123; return AdaptScreenUtils.adaptWidth(super.getResources(), 1080)&#125;override fun getResources(): Resources &#123; return AdaptScreenUtils.adaptHeight(super.getResources(), 1920)&#125;override fun getResources(): Resources &#123; return AdaptScreenUtils.closeAdapt(super.getResources())&#125; 其源码、Demo 以及 API 如下所示： AdaptScreen 相关 -&gt; [AdaptScreenUtils.java][adaptScreen.java] -&gt; [Demo][adaptScreen.demo]12345adaptWidth : 适配宽度adaptHeight: 适配高度closeAdapt : 关闭适配（pt 等同于 dp）pt2Px : pt 转 pxpx2Pt : px 转 pt pt2Px 及 px2Pt 是提供给需要动态操作 View 的。 如上只需依赖 AndroidUtilCode 最新版本即可： 1implementation 'com.blankj:utilcode:1.23.2' 结尾的话看了原理之后是不是觉得很简单，但能想到这种解决方案的又能有几人呢，我也是站在了巨人的肩膀上才能想到这一层次，希望该适配方案能像文章标题一样终结我们的适配，这是我目前发现最简单有效的适配方案，如果觉得不错的话记得推荐给身边的 Androider 哦，使用过程有问题的话欢迎同步到 「Android 屏幕适配终结者」问题汇总 这个 issue 中。 最后再插个内容，AndroidUtilCode 项目已改造为组件化，有兴趣的可以翻阅源码查看，相信你肯定会学到不少好东西的，下一篇文章我会为大家介绍下这方面的内容，期待我能尽快出产吧。 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App 启动过程（含 Activity 启动过程） | 安卓 offer 收割基]]></title>
    <url>%2F2018%2F09%2F29%2Fthe-process-of-app-start%2F</url>
    <content type="text"><![CDATA[这道题在曾经面试「菜鸟网络」中遇到过，不过当时只问了「Activity 启动过程」，这里对整个「App 启动过程」进行完整的源码分析，希望可以帮助到大家。 源码分析1. Launcher 捕获点击事件，其过程为 Launcher#onClick -&gt; Launcher#onClickAppShortcut -&gt; Launcher#startAppShortcutOrInfoActivity -&gt; Launcher#startActivitySafely -&gt; Activity#startActivity，其 Launcher3 相关源码如下所示：12345678910111213141516171819202122232425262728293031323334353637383940// https://github.com/amirzaidi/Launcher3/blob/f7951c32984036eef2f2130f21abded3ddf6160a/src/com/android/launcher3/Launcher.java#L2249public void onClick(View v) &#123; ... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) &#123; onClickAppShortcut(v); &#125; ...&#125;// https://github.com/amirzaidi/Launcher3/blob/f7951c32984036eef2f2130f21abded3ddf6160a/src/com/android/launcher3/Launcher.java#L2412protected void onClickAppShortcut(final View v) &#123; ... // Start activities startAppShortcutOrInfoActivity(v);&#125;// https://github.com/amirzaidi/Launcher3/blob/f7951c32984036eef2f2130f21abded3ddf6160a/src/com/android/launcher3/Launcher.java#L2462private void startAppShortcutOrInfoActivity(View v) &#123; ItemInfo item = (ItemInfo) v.getTag(); Intent intent;// 应用程序安装的时候根据 AndroidManifest.xml 由 PackageManagerService 解析并保存的 if (item instanceof PromiseAppInfo) &#123; PromiseAppInfo promiseAppInfo = (PromiseAppInfo) item; intent = promiseAppInfo.getMarketIntent(); &#125; else &#123; intent = item.getIntent(); &#125; ... boolean success = startActivitySafely(v, intent, item); ...&#125;// https://github.com/amirzaidi/Launcher3/blob/f7951c32984036eef2f2130f21abded3ddf6160a/src/com/android/launcher3/Launcher.java#L2689public boolean startActivitySafely(View v, Intent intent, ItemInfo item) &#123; ... intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); ... startActivity(intent, optsBundle); ...&#125; 2. 以 API 27 源码为例，说到了 Acitvity#startActivity，我们点击源码可以发现调用的是 Activity#startActivityForResult，其中调用到了 Instrumentation#execStartActivity 这个方法，源码如下所示：123456789101112131415161718192021// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/Activity.java#4800public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/Activity.java#4482public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; ... Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ...&#125; 3. 在 Instrumentation#execStartActivity 中我们可以发现它调用了 ActivityManager#getService()#startActivity，其 ActivityManager#getService() 是采用单例，返回的是实现 IActivityManager 类型的 Binder 对象，它的具体实现是在 ActivityManagerService 中。1234567891011121314151617181920212223242526272829303132// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/Instrumentation.java#1578public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ... try &#123; ... int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); ... &#125; catch (RemoteException e) &#123; ... &#125; return null;&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityManager.java#4216public static IActivityManager getService() &#123; return IActivityManagerSingleton.get();&#125;private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 4. 我们再到 ActivityManagerService#startActivity 查看其源码，发现其调用了 ActivityManagerService#startActivityAsUser，该方法又调用了 ActivityStarter#startActivityMayWait，源码如下所示：12345678910111213141516171819202122// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#4516@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); // TODO: Switch to user app stacks here. return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, "startActivityAsUser");&#125; 5. 我们查找到 ActivityStarter#startActivityMayWait，其间调用了 ActivityStarter#startActivityLocked，接着是 ActivityStarter#startActivity，然后是 ActivityStarter#startActivityUnchecked，其调用了 ActivityStackSupervisor#resumeFocusedStackTopActivityLocked，源码如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#673final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason) &#123; ... int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason); ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#263int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason) &#123; ... mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, inTask);&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#294private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask) &#123; ... return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask, outActivity);&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#988private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; ... result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#1015private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; ... mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); ...&#125; 6. 到 ActivityStackSupervisor#resumeFocusedStackTopActivityLocked 中查看发现其调用了 ActivityStack#resumeTopActivityUncheckedLocked，然后是 ActivityStack#resumeTopActivityInnerLocked，接着变又回到 ActivityStackSupervisor.java，调用了 ActivityStackSupervisor#startSpecificActivityLocked，这个方法中会判断要启动 App 的进程是否存在，存在则通知进程启动 Activity，否则就先将进程创建出来，其源码如下所示：1234567891011121314151617181920212223242526272829303132333435363738// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java#2085boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; ... return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStack.java#2245boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; ... result = resumeTopActivityInnerLocked(prev, options); ...&#125;http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStack.java#2286private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... mStackSupervisor.startSpecificActivityLocked(next, true, true); ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java#1560void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; ... if (app != null &amp;&amp; app.thread != null) &#123; ... // 如果进程已存在，则通知进程启动组件 realStartActivityLocked(r, app, andResume, checkConfig); return; ... &#125; // 否则先将进程创建出来 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true); ...&#125; 7. 我们分析进程尚未存在的情况，因为我们后续还会再次遇到 ActivityStackSupervisor#realStartActivityLocked，ActivityStackSupervisor#startSpecificActivityLocked 中创建进程使用到的 mService 为 ActivityManagerService，我们查看 ActivityManagerService#startProcessLocked 的源码如下所示：1234567891011// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#3777private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; ... if (entryPoint == null) entryPoint = "android.app.ActivityThread"; startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs); ...&#125; 8. 发现最终调用的事 Process#start 来启动进程，进程的入口就是在 android.app.ActivityThread.java 类中的 main() 函数，因此接下来我们从 ActivityThread#main 来分析，其调用了 ActivityThread#attach，其中 ActivityManager.getService() 之前提到过，返回的是一个是实现 IActivityManager 类型的 Binder 对象，它的具体实现是在 ActivityManagerService 中，相关源码如下所示：12345678910111213141516171819202122232425262728// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#6459public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); ... Looper.loop(); ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#6315private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; ... final IActivityManager mgr = ActivityManager.getService(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; ... &#125; ... &#125; ...&#125; 9. 我们又回到了 ActivityManagerService 中，查看其 attachApplication 函数，发现调用了 thread#bindApplication 和 mStackSupervisor#attachApplicationLocked 我们依次讲解这两个方法要做的事情，源码如下所示：12345678910111213141516171819202122232425262728293031323334// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#7215public final void attachApplication(IApplicationThread thread) &#123; ... attachApplicationLocked(thread, callingPid); ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#6911private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; .... thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial); ... if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; ... &#125; &#125; ...&#125; 10. 上面说到的thread#bindApplication 中的这个 thread 是来自于 ActivityThread#mAppThread，其类型是 ApplicationThread，是 ActivityThread 的一个内部类，继承自 IApplicationThread.Stub，我们来查看 ApplicationThread#bindApplication，发现最后调用了 ActivityThread#sendMessage 方法，它内部调用了 mH.sendMessage 来发送消息，mH 是 ActivityThread 的内部类 H 的一个实例，查看 H#handleMessage 来查看它是怎么处理发送过来的消息，其最终走到了 ActivityThread#handleBindApplication。在源码中我们可以发现它先创建 mInstrumentation 对象，调用 data#info#makeApplication 来创建 Application 对象，其对象 data#info 为 LoadedApk 的一个实例，查看 LoadedApk#makeApplication 中代码可以发现，其调用了 Instrumentation#newApplication 方法，内部靠 Class#newInstance() 完成对 Application 实例化，然后调用 Application#attach(context) 来绑定 Context。 以上创建完 Application 对象后便是调用 Instrumentation#callApplicationOnCreate 走 Application 的 onCreate 生命周期，以上涉及到的全部源码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#899public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial) &#123; ... sendMessage(H.BIND_APPLICATION, data);&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#2593private void sendMessage(int what, Object obj) &#123; sendMessage(what, obj, 0, 0, false);&#125;private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, "SCHEDULE " + what + " " + mH.codeToString(what) + ": " + arg1 + " / " + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#1580public void handleMessage(Message msg) &#123; ... switch (msg.what) &#123; ... case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... &#125;&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#5429private void handleBindApplication(AppBindData data) &#123; ... final InstrumentationInfo ii; ... // 创建 mInstrumentation 实例 if (ii != null) &#123; final ApplicationInfo instrApp = new ApplicationInfo(); ii.copyTo(instrApp); instrApp.initForUser(UserHandle.myUserId()); final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false); final ContextImpl instrContext = ContextImpl.createAppContext(this, pi); try &#123; final ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); &#125; catch (Exception e) &#123; ... &#125; ... &#125; else &#123; mInstrumentation = new Instrumentation(); &#125; ... Application app; ... // 创建 Application 实例 try &#123; ... app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; ... &#125; &#125; finally &#123; ... &#125; ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/LoadedApk.java#959public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = "android.app.Application"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); ... ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; ... &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123;// 传入为 null 所以不走 try &#123; instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; ... &#125; &#125; ... return app;&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/Instrumentation.java#1084public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return newApplication(cl.loadClass(className), context);&#125;static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); app.attach(context); return app;&#125; 11. 说完了 9 中的 thread#bindApplication，下面我们继续说 mStackSupervisor#attachApplicationLocked，其 mStackSupervisor 是 ActivityStackSupervisor 的一个实例，我们查看 ActivityStackSupervisor#attachApplicationLocked 方法中发现会调用 ActivityStackSupervisor#realStartActivityLocked，其方法会调用 app#thread#scheduleLaunchActivity，源码如下所示：1234567891011121314151617181920212223242526// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java#956boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; ... if (realStartActivityLocked(activity, app, top == activity /* andResume */, true /* checkConfig */)) &#123; ... &#125; ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java#1313final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...&#125; 12. 上面说到的 app#thread#scheduleLaunchActivity 中的 thread 是前面提到过的 IApplicationThread，它的实现类是 ActivityThread#ApplicationThread ，我们查看 ActivityThread#ApplicationThread#scheduleLaunchActivity 中的代码发现最终是发送 LAUNCH_ACTIVITY 消息，这步我们在第 10 步中有过分析，我们直接查看其处理消息相关代码即可，在 H#handleMessage 中，我们可以看到其会接收并处理很多和四大组件相关的操作，我们查看对 LAUNCH_ACTIVITY 的处理，发现对其处理的方法是 ActivityThread#handleLaunchActivity，它调用到了 ActivityThread#performLaunchActivity 方法，其中的实现再次涉及到了 Instrumentation 类，之前是在创建 Application 对象用到了它，如今是创建 Activity 对象又用到了它，其 Instrumentation#newActivity 也是通过 Class.newInstance() 来实例化 Activity，实例化结束后回到 ActivityThread#performLaunchActivity 中来让 activity 依附到 window 中，然后callActivityOnCreate 走 Activity 的 onCreate 生命周期，涉及到的源码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#756public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; ... sendMessage(H.LAUNCH_ACTIVITY, r);&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#1580public void handleMessage(Message msg) &#123; ... switch (msg.what) &#123; ... case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, "LAUNCH_ACTIVITY"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ... &#125;&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#2833private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ... Activity a = performLaunchActivity(r, customIntent); ...&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java#2644private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); ... &#125; catch (Exception e) &#123; ... &#125; try &#123; // 返回之前创建过的 application 对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) &#123; ... // attach 到 window 上 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); ... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... &#125; &#125; catch (Exception e) &#123; ... &#125; return activity;&#125;// http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/Instrumentation.java#1143public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance();&#125;public Activity newActivity(Class&lt;?&gt; clazz, Context context, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance) throws InstantiationException, IllegalAccessException &#123; Activity activity = (Activity)clazz.newInstance(); ActivityThread aThread = null; activity.attach(context, aThread, this, token, 0 /* ident */, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances)lastNonConfigurationInstance, new Configuration(), null /* referrer */, null /* voiceInteractor */, null /* window */, null /* activityConfigCallback */); return activity;&#125; 到此为止，一个 App 的启动过程已分析结束，最后献上启动涉及到的类的流程图： 结语我正在打造一个帮助 Android 开发者们拿到更好 offer 的面试库————安卓 offer 收割基，欢迎 star，觉得不错的可以持续关注，有兴趣的可以一起加入进来和我一同打造。 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>安卓 offer 收割基</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>App 启动过程</tag>
        <tag>Activity 启动过程</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 性能优化 | 安卓 offer 收割基]]></title>
    <url>%2F2018%2F09%2F29%2Foptimize-recycler-view%2F</url>
    <content type="text"><![CDATA[阿里四面有三面都问了这个问题，在此做了整理，希望可以帮助到大家，欢迎查漏补缺。 数据处理和视图加载分离我们知道，从远端拉取数据肯定是要放在异步的，在我们拉取下来数据之后可能就匆匆把数据丢给了 VH 处理，其实，数据的处理逻辑我们也应该放在异步处理，这样 Adapter 在 notify change 后，ViewHolder 就可以简单无压力地做数据与视图的绑定逻辑，比如： 1mTextView.setText(Html.fromHtml(data).toString()); 这里的 Html.fromHtml(data) 方法可能就是比较耗时的，存在多个 TextView 的话耗时会更为严重，这样便会引发掉帧、卡顿，而如果把这一步与网络异步线程放在一起，站在用户角度，最多就是网络刷新时间稍长一点。 数据优化分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 DiffUtil 来进行局部刷新数据，而不是一味地全局刷新数据。 布局优化减少过渡绘制减少布局层级，可以考虑使用自定义 View 来减少层级，或者更合理地设置布局来减少层级，不推荐在 RecyclerView 中使用 ConstraintLayout，有很多开发者已经反映了使用它效果更差，相关链接有：Is ConstraintLayout that slow?、constraintlayout 1.1.1 not work well in listview。 减少 xml 文件 inflate 时间这里的 xml 文件不仅包括 layout 的 xml，还包括 drawable 的 xml，xml 文件 inflate 出 ItemView 是通过耗时的 IO 操作，尤其当 Item 的复用几率很低的情况下，随着 Type 的增多，这种 inflate 带来的损耗是相当大的，此时我们可以用代码去生成布局，即 new View() 的方式，只要搞清楚 xml 中每个节点的属性对应的 API 即可。 减少 View 对象的创建一个稍微复杂的 Item 会包含大量的 View，而大量的 View 的创建也会消耗大量时间，所以要尽可能简化 ItemView；设计 ItemType 时，对多 ViewType 能够共用的部分尽量设计成自定义 View，减少 View 的构造和嵌套。 其他其他并不代表不重要，而是我不能把他们进行分类哈，其中可能某些操作会对你的 RecyclerView 有很大的优化。 升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能，可参考 RecyclerView 数据预取。 如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout 浪费资源； 设置 RecyclerView.addOnScrollListener(listener); 来对滑动过程中停止加载的操作。 如果不要求动画，可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭来提神效率。 对 TextView 使用 String.toUpperCase 来替代 android:textAllCaps=&quot;true&quot;。 对 TextView 使用 StaticLayout 或者 DynamicLayout 的自定义 View 来代替它。 通过重写 RecyclerView.onViewRecycled(holder) 来回收资源。 通过 RecycleView.setItemViewCacheSize(size); 来加大 RecyclerView 的缓存，用空间换时间来提高滚动的流畅性。 如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool。 对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗。 通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示： 123456new LinearLayoutManager(this) &#123; @Override protected int getExtraLayoutSpace(RecyclerView.State state) &#123; return size; &#125;&#125;; 结语我正在打造一个帮助 Android 开发者们拿到更好 offer 的面试库————安卓 offer 收割基，欢迎 star，觉得不错的可以持续关注，有兴趣的可以一起加入进来和我一同打造。 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>安卓 offer 收割基</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴面经记]]></title>
    <url>%2F2018%2F09%2F26%2Falibaba-interview%2F</url>
    <content type="text"><![CDATA[背景今年三月份入职了「51信用卡」，公司的福利待遇在杭州也算得上是翘楚，但好景不长，没能挨过 6 个月的试用期，倒在了七月末的一波 CY，不过公司对试用期员工也有稍许补偿，对此很是感恩，同时还要感谢共事的小伙伴们给了我成长和发展的空间，和他们匆匆告别后便回家修养生息，准备我的求职之路。 更新简历上了 Boss 直聘更新了一波自己的简历，关于简历模板，之前我就分享过，传送门在此～ 要是觉得不错一定要记得 star 哦，关于简历，在此强调一点，正常逻辑下面试官起初肯定是就着简历来问问题的，所以简历中的提及的技术点自己一定要全面掌握。 选取公司一开始我也没急着投递简历，先打算好好看几天书，再去面试，不过 Boss 直聘上每天都有 HR、内推人员或者猎头主动联系我，感觉 Android 开发行情最近还不错的样子。关于如何选择公司，我分享下我的看法，如果你是 5 年以内的开发人员，那么尽量往大公司跳，大公司有完善的薪酬、制度体系，不用面临随时倒闭的风险，如果是 5 年以上的开发人员，给你个 404 吧，相信你自己可以定夺。所以，2016 届毕业的我肯定是要往更大的公司跳的，最终根据地理位置和我的意向筛选出的心仪公司屈指可数，包括「支付宝」、「菜鸟网络」、「二维火」和「涂鸦科技」，由于优先被内推了支付宝，而支付宝和菜鸟网络都是阿里系的公司，同一时间只能走一条面试线，所以这里便和菜鸟网络说了再见。 学习技术 在家主要看了 《深入理解 Java 虚拟机》和《Kotlin 实战》这两本，虽说和 Android 没有直接关系，但我相信这两部分还是非常重要的； 快速复读了一遍《Android 开发艺术探索》，这本我一直认为是 Android 的面试宝典，希望到现在还没有看过的年轻 Android 开发者们都可以过目一下； 阅读并分析 Android 源码和主流三方库的源码，技术要往深度发展，不要仅仅只停留在调用 API 的层面，要做到知其然并知其所以然。 分析并实践一些主流框架的原理，如插件化、自动化埋点、热修复、路由等。 面试经历首先我拿了一个不太中意的先找找感觉，面试了「点我达」的「高级 Android 开发工程师」，时长两小时左右，由于职位主要是做业务相关的，我也表现出了并不是很喜欢，不出意外，最终把我拒了，不过这波面试也让我找到了感觉。 之后面试了「二维火」的「Android 架构师」，时长两小时左右，这个职位是我所擅长的，也是我喜欢的，面试之后 offer 给得很爽快，也是为我保留时间最久的 offer，一直保留到我收到支付宝的 offer 为止我才痛心婉拒，但最终我还是由于支付宝拒绝了它。在 offer 保质期方便，如果可以和 HR 协商，那么你应该想方设法把 offer 实效延长，毕竟双方都比较满意，我就是这么死皮赖脸把这个 offer 延长了好几周。 再就是面试「涂鸦科技」的「高级 Android 开发工程师」，从下午两点面到了六点多，由于其公司创始人是阿里系的，设计的面试流程几乎和阿里一致，一下午总共经历了五轮面试，两天后收到了其 offer，保质期一周，由于还在苦苦坚持面支付宝，和 HR 商量 offer 时效性也不给予改变，所以痛心婉拒。 最后就是面试开始最早结束最晚的「支付宝」的「高级 Android 开发工程师」，首先说下面试的整个时间线： 2018/08/08: 内推 2018/08/14: 一面（电话技术面） 2018/08/21: 二面（现场技术面） 2018/08/25: 三面（电话技术面：主管） 2018/09/05: 四面（现场交叉面：HR 和技术总监） 2018/09/20: 口头 offer 2018/09/22: 体检 2018/09/25: 正式 offer 其中最坑的一步就是四面完之后等 HRG 的消息，四面结束的时候现场说的是四面完一周内会给我答复，我回去后查询面试结果是通过状态，下一步就是 offer 审批阶段，我也就心想耐心等着便是了，可等了差不多两周一直都是 offer 审批阶段，中间也没有 HR 和我联系，我就觉得不太对劲了，在网上搜索了很多关于「阿里巴巴 offer 审批时长」的帖子，一度认为自己进了备胎组 ORZ，这时候我想我不能再傻傻等下去了，找了帮我内推的大哥说明了下情况，让他帮我催一下进度，心想要是不准备发 offer 的话就赶紧把我拒了吧，让我安安心心去「二维火」也成，好在两天后总算得到了 HRG 的口头 offer，她一上来便表示了歉意，理应上周给我答复的，但由于太忙耽搁了，这样我也不好意思说什么。幸好我催得还比较主动，不然再等个两周我都觉得有可能。 其面试内容一面、二面都以技术为主，三面以架构设计为主，四面技术总监就是泛泛而谈了，HR 是面除技术以外对你整个人的看法。这里我说个很巧的事情，一二四面的技术官都问了我「RecyclerView 的优化」问题。每位面试官都有一票否决的权利，面试结果可以在面试完之后通过电话查询，或者找内推人员帮你查询，在查询到面试结果之后方便安排自己后续的准备。 这么多面试下来围绕的主要还是以简历为主，所以简历中所写的技术自己一定要熟烂于心，面试官问的问题即便不会，也要说出自己的想法，有些时候面试官会根据你的想法来给你提点让你继续想下去，让面试官觉得你是一个热爱思考的人。技术和经验短时间内是无法瞬间提升的，需要我们平时注重积累、反思和总结，这方面可以通过平时多写博客或者笔记进行总结，有能力开源的就做开源，这些都可以是面试的敲门砖，如果你的 GitHub 如同下面我这样的，还怕会缺少机会吗，哈哈。 重点来了上面提及的面试经历不是为了炫耀我多么厉害，而是我想把我的经验分享给大家，让大家在面试方面有所提高，我也会把我总结的 Android 面试技术点分享到 GitHub 上，方便大家整理和学习，由于个人时间精力能力有限，所以可能进度会有点慢，但我会像打造 AndroidUtilCode 一样坚持下去，也欢迎小伙伴们可以加入一起打造，有内推需要的也可以在里面查看，献上传送门 AndroidOfferKiller，觉得不错的一定要给个 star 哦，你的 star 是我对大的动力。 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>简历</tag>
        <tag>阿里巴巴</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 屏幕适配从未如斯简单（8月10日最终更新版）]]></title>
    <url>%2F2018%2F07%2F30%2Feasy-adapt-screen%2F</url>
    <content type="text"><![CDATA[前言由于之前发的适配文章关注的人比较多，而之前的方案存在较多坑，但这已经被我这一周来仔细琢磨找到了最优的解决方案，担心大家还停留在之前的适配方式，所以在掘金只能靠分享链接来提醒你们查看最新更新版本，为之前还未成熟的适配深表歉意，烦请大家一起再次阅览一遍下文吧。 一个月前看了今日头条新的屏幕适配方案，这是传送门，对此不禁拍案叫绝，为此我想把这种方案融入到我工具类中直接一行代码即可适配，如今最新 1.19.0 版 AndroidUtilCode 已有其最新的适配方案，其相关函数在 ScreenUtils 中，相关 API 如下所示： 1234adaptScreen4VerticalSlide : 适配垂直滑动的屏幕adaptScreen4HorizontalSlide: 适配水平滑动的屏幕cancelAdaptScreen : 取消适配屏幕isAdaptScreen : 是否适配屏幕 效果UtilApk 中的 ScreenAdaptActivity 以设计图为 360dp 宽度 来做适配，我们设置两个 view 宽度为 180dp，代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ScreenAdaptActivity extends BaseActivity &#123; private TextView tvUp; private TextView tvDown; public static void start(Context context) &#123; Intent starter = new Intent(context, ScreenAdaptActivity.class); context.startActivity(starter); &#125; @Override public void initData(@Nullable Bundle bundle) &#123; if (ScreenUtils.isPortrait()) &#123; ScreenUtils.adaptScreen4VerticalSlide(this, 360); &#125; else &#123; ScreenUtils.adaptScreen4HorizontalSlide(this, 360); &#125; &#125; @Override public int bindLayout() &#123; return R.layout.activity_screen_adapt; &#125; @Override public void initView(Bundle savedInstanceState, View contentView) &#123; &#125; @Override public void doBusiness() &#123; &#125; @Override public void onWidgetClick(View view) &#123; &#125; public void toggleFullScreen(View view) &#123; ScreenUtils.toggleFullScreen(this); &#125; @Override protected void onDestroy() &#123; ScreenUtils.cancelAdaptScreen(this); super.onDestroy(); &#125;&#125; 其在 1080x1920 420dpi(xxhdpi) 下的效果如下所示： 其在 768x1280 320dpi(xhdpi) 下的效果如下所示： 其在 480x800 240dpi(hdpi) 下的效果如下所示： 其在 320x480 160dpi(mdpi) 下的效果如下所示： 如上就是竖屏以 360dp 为宽度和宽屏以 360dp 为高度的适配效果。 原理如果看了上面今日头条的那篇适配文章，那么你可能已经知道其原理了，不明白的话可以继续看下我的解释：我们知道 px = dp * density，我们要适配的话需要确保 dp 不变去修改 density，而安卓默认 density = dpi / 160，其意思就是 1dp 有多少 px，也就是像素密度，我们开发是按照一份设计稿来做的，那么有没有什么办法来让 density 和设计稿尺寸做联系呢？假设我们设计稿是宽度是 1080px，资源放在 xxhdpi，那么我们宽度转换为 dp 就是 1080 / 3 = 360dp，要在不同设备上宽度都表现为 360dp，那么就需要修改其 density = screenWidthPx / 360，这样就满足了上述条件，而和 density 相关的还有 densityDpi、scaledDensity，我们根据 density 等比修改 densityDpi、scaledDensity 即可。 由于 API 26 及以上的 Activity#getResources()#getDisplayMetrics() 和 Application#getResources()#getDisplayMetrics() 是不同的引用，所以在 API 26 及以上适配是没有影响的，但在 API 26 以下 Activity#getResources()#getDisplayMetrics() 和 Application#getResources()#getDisplayMetrics() 是相同的引用，导致适配有问题，这里要感谢 @MirkoWu 提出的问题，后面会有解决之法。 如果我们以 xxhdpi 的 360dp 来适配的话，首先在 AS 中预览是个问题，在接入第三方 SDK 带有界面或者 View 的话会导致它的尺寸全然不对，因为我们那样适配后界面宽度只有 360dp，而第三方 SDK 中很有可能写的布局会超出 360dp，这便会引发新的问题，当然这也是有响应的解决之道，比如暂时取消适配，但我们有更好的方式，着重看下面介绍。 我着重推荐以 mdpi 为特例来适配，比如前面说到的 xxhdpi 的 360dp，那么在 mdpi 下就是 360 * 3 = 1080dp，这样我们新建一个宽为 1080px 的 mdpi 设备（可以通过修改设备尺寸来达到 mdpi），然后切换为该设备来预览布局就完美解决了以上问题，我们在写布局的时候设计图是 36px，那么我们直接就写 36dp 即可，设计图字体是 24px， 我们直接就写 24sp 即可，这样便可达到和设计图一致的效果。另外，图片资源放在需要适配的最高 dpi 下面即可，比如 drawable-xxhdpi 或者 drawable-xxxhdpi，这样在高清屏上也不会导致失真。 但是这样会导致获取状态栏和导航栏高度有问题，其获取状态栏高度代码为如下所示： 12345public static int getStatusBarHeight() &#123; Resources resources = Utils.getApp().getResources(); int resourceId = resources.getIdentifier("status_bar_height", "dimen", "android"); return resources.getDimensionPixelSize(resourceId);&#125; 由于使用的是 Application#getResources，这会导致最后计算状态栏高度使用的是修改过后的 density，在这里也要感谢 @magic0908 无意间提到的 Resources.getSystem() 来获取系统的 Resources,果不其然可以获取到正确高度的状态栏高度，代码如下所示： 12345public static int getStatusBarHeight() &#123; Resources resources = Resources.getSystem(); int resourceId = resources.getIdentifier("status_bar_height", "dimen", "android"); return resources.getDimensionPixelSize(resourceId);&#125; 同理获取导航栏高度也可以这样。 考虑到了 Resources.getSystem()，那么我们在适配上岂不是可以更方便，不用区分版本什么的 Activity#getResources()#getDisplayMetrics() 和 Application#getResources()#getDisplayMetrics()，也不需要什么中间变量来记录适配前的值，那些值我们直接在 Resources#getSystem()#getDisplayMetrics() 中获取 density、densityDpi、scaledDensity 即可，而且在修改系统字体的时候，Resources#getSystem()#getDisplayMetrics() 也会相应地改变，这样也就不需要注册 registerComponentCallbacks 来监听系统字体的改变，所以最终的源码很是简洁，但其中间遇到的问题很是复杂，光工具类我这些天就更新了很多版本来解决其问题，从1.18.0 到 1.18.7，有六个版本都是和这个适配有关系，但最终还是完美地找到了解决方案，也要感谢大家的帮助，其最终源码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Adapt the screen for vertical slide. * * @param activity The activity. * @param designWidthInPx The size of design diagram's width, in pixel. */public static void adaptScreen4VerticalSlide(final Activity activity, final int designWidthInPx) &#123; adaptScreen(activity, designWidthInPx, true);&#125;/** * Adapt the screen for horizontal slide. * * @param activity The activity. * @param designHeightInPx The size of design diagram's height, in pixel. */public static void adaptScreen4HorizontalSlide(final Activity activity, final int designHeightInPx) &#123; adaptScreen(activity, designHeightInPx, false);&#125;/** * Reference from: https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA */private static void adaptScreen(final Activity activity, final int sizeInPx, final boolean isVerticalSlide) &#123; final DisplayMetrics systemDm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics appDm = Utils.getApp().getResources().getDisplayMetrics(); final DisplayMetrics activityDm = activity.getResources().getDisplayMetrics(); if (isVerticalSlide) &#123; activityDm.density = activityDm.widthPixels / (float) sizeInPx; &#125; else &#123; activityDm.density = activityDm.heightPixels / (float) sizeInPx; &#125; activityDm.scaledDensity = activityDm.density * (systemDm.scaledDensity / systemDm.dens activityDm.densityDpi = (int) (160 * activityDm.density); appDm.density = activityDm.density; appDm.scaledDensity = activityDm.scaledDensity; appDm.densityDpi = activityDm.densityDpi;&#125;/** * Cancel adapt the screen. * * @param activity The activity. */public static void cancelAdaptScreen(final Activity activity) &#123; final DisplayMetrics systemDm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics appDm = Utils.getApp().getResources().getDisplayMetrics(); final DisplayMetrics activityDm = activity.getResources().getDisplayMetrics(); activityDm.density = systemDm.density; activityDm.scaledDensity = systemDm.scaledDensity; activityDm.densityDpi = systemDm.densityDpi; appDm.density = systemDm.density; appDm.scaledDensity = systemDm.scaledDensity; appDm.densityDpi = systemDm.densityDpi;&#125;/** * Return whether adapt screen. * * @return &#123;@code true&#125;: yes&lt;br&gt;&#123;@code false&#125;: no */public static boolean isAdaptScreen() &#123; final DisplayMetrics systemDm = Resources.getSystem().getDisplayMetrics(); final DisplayMetrics appDm = Utils.getApp().getResources().getDisplayMetrics(); return systemDm.density != appDm.density;&#125; 坑点在原理里都已经说完了哈。 建议新老项目都可以用这套方案，老项目中如果有新的 Activity 加进来，那么可以对其使用该方案来适配，然后在启动其他老的 Activity 时候 cancelAdaptScreen 即可。新项目我建议采用我工具类中的使用，可以让你爽到极致，在 BaseActivity 中 setContentView(xx) 之前调用适配代码即可，记得第二个参数一定要传入设计图的实际像素尺寸，不再是曾经的 dp 尺寸了。 有了固定的尺寸，那么我们百分比是不是就很好实现了，计算后直接写 xxdp 即可，这样在所有设备上也都是一定的比例，哪里还需要什么百分比布局什么的来做？是不是 so easy，更多风骚的操作可待你解锁。 结语如果我的工具类对你的适配造成了影响，欢迎到 AndroidUtilCode 提 issue，感谢今日头条的方案，让我可以站在巨人的肩膀上装一次 13。 最后 记得屏幕适配一定要用 1.19.0 版本及以上 记得屏幕适配一定要用 1.19.0 版本及以上 记得屏幕适配一定要用 1.19.0 版本及以上 给大家带来了麻烦，sorry。 GitHub issue屏幕适配问题汇总]]></content>
      <categories>
        <category>Android</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 的二级缓存如斯简单]]></title>
    <url>%2F2018%2F07%2F05%2Fdouble-cache-so-easy%2F</url>
    <content type="text"><![CDATA[CacheDiskUtils之前写过一篇 你想要的 CacheUtils，简单介绍了下其可以完美替代 ASimpleCache，而且修复了其中少许 BUG 并做了相应优化，相关 API 如下所示： 缓存相关 -&gt; CacheUtils.java1234567891011121314getInstance : 获取缓存实例Instance.put : 缓存中写入数据Instance.getBytes : 缓存中读取字节数组Instance.getString : 缓存中读取 StringInstance.getJSONObject : 缓存中读取 JSONObjectInstance.getJSONArray : 缓存中读取 JSONArrayInstance.getBitmap : 缓存中读取 BitmapInstance.getDrawable : 缓存中读取 DrawableInstance.getParcelable : 缓存中读取 ParcelableInstance.getSerializable: 缓存中读取 SerializableInstance.getCacheSize : 获取缓存大小Instance.getCacheCount : 获取缓存个数Instance.remove : 根据键值移除缓存Instance.clear : 清除所有缓存 其也就是所谓的硬盘缓存，在 AndroidUtilCode 1.17.0 版本，该 CacheUtils 已被我标记废弃，可替换为 CacheDiskUtils，下一个大版本1.18.x 可能就会移除 CacheUtils。 CacheMemoryUtils讲了磁盘缓存另一个就是内存缓存，内存缓存工具类 CacheMemoryUtils 原理是利用 LruCache 来实现的（LRU 是Least Recently Used的缩写，即最近最少使用），其 API 如下所示： 内存缓存相关 -&gt; CacheMemoryUtils.java -&gt; Test123456getInstance : 获取缓存实例Instance.put : 缓存中写入数据Instance.get : 缓存中读取字节数组Instance.getCacheCount: 获取缓存个数Instance.remove : 根据键值移除缓存Instance.clear : 清除所有缓存 CacheDoubleUtils结合硬盘缓存工具类 CacheDiskUtils 和内存缓存工具类 CacheMemoryUtils，那么我们的二级缓存工具类 CacheDoubleUtils 便诞生了，其 API 如下所示： 二级缓存相关 -&gt; CacheDoubleUtils.java -&gt; Test123456789101112131415getInstance : 获取缓存实例Instance.put : 缓存中写入数据Instance.getBytes : 缓存中读取字节数组Instance.getString : 缓存中读取 StringInstance.getJSONObject : 缓存中读取 JSONObjectInstance.getJSONArray : 缓存中读取 JSONArrayInstance.getBitmap : 缓存中读取 BitmapInstance.getDrawable : 缓存中读取 DrawableInstance.getParcelable : 缓存中读取 ParcelableInstance.getSerializable : 缓存中读取 SerializableInstance.getCacheDiskSize : 获取磁盘缓存大小Instance.getCacheDiskCount : 获取磁盘缓存个数Instance.getCacheMemoryCount: 获取内存缓存个数Instance.remove : 根据键值移除缓存Instance.clear : 清除所有缓存 借助以上三个缓存工具类，那么 Android 端的缓存实现便再也不是什么难题了，例如你想要实现 RxCache，那么借助 RxJava 的 compose 操作符和我的工具类，把数据放入缓存不就轻而易举地实现了么，更多风骚的姿势可待你解锁。]]></content>
      <categories>
        <category>Android</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[妈妈再也不用担心你不会使用线程池了（ThreadUtils）]]></title>
    <url>%2F2018%2F05%2F23%2Fthread-utils%2F</url>
    <content type="text"><![CDATA[为什么要用线程池使用线程池管理线程有如下优点： 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 线程池介绍ThreadPoolExecutorJava 为我们提供了 ThreadPoolExecutor 来创建一个线程池，其完整构造函数如下所示： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) int corePoolSize（核心线程数）：线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程；核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)；如果设置了 allowCoreThreadTimeOut 为 true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉。 int maximumPoolSize（线程池能容纳的最大线程数量）：线程总数 = 核心线程数 + 非核心线程数。 long keepAliveTime（非核心线程空闲存活时长）：非核心线程空闲时长超过该时长将会被回收，主要应用在缓存线程池中，当设置了 allowCoreThreadTimeOut 为 true 时，对核心线程同样起作用。 TimeUnit unit（keepAliveTime 的单位）：它是一个枚举类型，常用的如：TimeUnit.SECONDS（秒）、TimeUnit.MILLISECONDS（毫秒）。 BlockingQueue workQueue（任务队列）：当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务，常用的 workQueue 类型： SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现 线程数达到了 maximumPoolSize 而不能新建线程 的错误，使用这个类型队列的时候，maximumPoolSize 一般指定成 Integer.MAX_VALUE，即无限大。 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了 maximumPoolSize 的设定失效，因为总线程数永远不会超过 corePoolSize。 ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到 corePoolSize 的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了 maximumPoolSize，并且队列也满了，则发生错误。 DelayQueue：队列内元素必须实现 Delayed 接口，这就意味着你传进去的任务必须先实现 Delayed 接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。 ThreadFactory threadFactory（线程工厂）：用来创建线程池中的线程，通常用默认的即可。 RejectedExecutionHandler handler（拒绝策略）：在线程池已经关闭的情况下和任务太多导致最大线程数和任务队列已经饱和，无法再接收新的任务，在上面两种情况下，只要满足其中一种时，在使用 execute() 来提交新的任务时将会拒绝，线程池提供了以下 4 种策略： AbortPolicy：默认策略，在拒绝任务时，会抛出RejectedExecutionException。 CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。 DiscardOldestPolicy：该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。 DiscardPolicy：该策略默默的丢弃无法处理的任务，不予任何处理。 线程池执行策略当一个任务要被添加进线程池时，有以下四种执行策略： 线程数量未达到 corePoolSize，则新建一个线程（核心线程）执行任务。 线程数量达到了 corePoolsSize，则将任务移入队列等待。 队列已满，新建非核心线程执行任务。 队列已满，总线程数又达到了 maximumPoolSize，就会由 RejectedExecutionHandler 抛出异常。 其流程图如下所示： 常见的四类线程池常见的四类线程池分别有 FixedThreadPool、SingleThreadExecutor、ScheduledThreadPool 和 CachedThreadPool，它们其实都是通过 ThreadPoolExecutor 创建的，其参数如下表所示： 参数 FixedThreadPool SingleThreadExecutor ScheduledThreadPool CachedThreadPool corePoolSize nThreads 1 corePoolSize 0 maximumPoolSize nThreads 1 Integer.MAX_VALUE Integer.MAX_VALUE keepAliveTime 0 0 10 60 unit MILLISECONDS MILLISECONDS MILLISECONDS SECONDS workQueue LinkedBlockingQueue LinkedBlockingQueue DelayedWorkQueue SynchronousQueue threadFactory defaultThreadFactory defaultThreadFactory defaultThreadFactory defaultThreadFactory handler defaultHandler defaultHandler defaultHandler defaultHandler 适用场景 已知并发压力的情况下，对线程数做限制 需要保证顺序执行的场景，并且只有一个线程在执行 需要多个后台线程执行周期任务的场景 处理执行时间比较短的任务 如果你不想自己写一个线程池，那么你可以从上面看看有没有符合你要求的（一般都够用了），如果有，那么很好你直接用就行了，如果没有，那你就老老实实自己去写一个吧。 合理地配置线程池需要针对具体情况而具体处理，不同的任务类别应采用不同规模的线程池，任务类别可划分为 CPU 密集型任务、IO 密集型任务和混合型任务。 CPU 密集型任务：线程池中线程个数应尽量少，推荐配置为 (CPU 核心数 + 1)； IO 密集型任务：由于 IO 操作速度远低于 CPU 速度，那么在运行这类任务时，CPU 绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高 CPU 利用率，推荐配置为 (2 * CPU 核心数 + 1)； 混合型任务：可以拆分为 CPU 密集型任务和 IO 密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。 线程池工具类封装及使用为了提升开发效率及更好地使用和管理线程池，我已经为你们封装好了线程工具类—-ThreadUtils，依赖 AndroidUtilCode 1.16.1 版本即可使用，其 API 如下所示： 12345678910111213141516171819202122232425isMainThread : 判断当前是否主线程getFixedPool : 获取固定线程池getSinglePool : 获取单线程池getCachedPool : 获取缓冲线程池getIoPool : 获取 IO 线程池getCpuPool : 获取 CPU 线程池executeByFixed : 在固定线程池执行任务executeByFixedWithDelay : 在固定线程池延时执行任务executeByFixedAtFixRate : 在固定线程池按固定频率执行任务executeBySingle : 在单线程池执行任务executeBySingleWithDelay: 在单线程池延时执行任务executeBySingleAtFixRate: 在单线程池按固定频率执行任务executeByCached : 在缓冲线程池执行任务executeByCachedWithDelay: 在缓冲线程池延时执行任务executeByCachedAtFixRate: 在缓冲线程池按固定频率执行任务executeByIo : 在 IO 线程池执行任务executeByIoWithDelay : 在 IO 线程池延时执行任务executeByIoAtFixRate : 在 IO 线程池按固定频率执行任务executeByCpu : 在 CPU 线程池执行任务executeByCpuWithDelay : 在 CPU 线程池延时执行任务executeByCpuAtFixRate : 在 CPU 线程池按固定频率执行任务executeByCustom : 在自定义线程池执行任务executeByCustomWithDelay: 在自定义线程池延时执行任务executeByCustomAtFixRate: 在自定义线程池按固定频率执行任务cancel : 取消任务的执行 如果你使用 RxJava 很 6，而且项目中已经使用了 RxJava，那么你可以继续使用 RxJava 来做线程切换的操作；如果你并不会 RxJava 或者是在开发 SDK，那么这个工具类再适合你不过了，它可以为你统一管理线程池的使用，不至于让你的项目中出现过多的线程池。 ThreadUtils 使用极为方便，看 API 即可明白相关意思，FixedPool、SinglePool、CachedPool 分别对应了上面介绍的 FixedThreadPool、SingleThreadExecutor、CachedThreadPool 这三种，IoPool 是创建 (CPU_COUNT * 2 + 1) 个核心线程数，CpuPool 是建立 (CPU_COUNT + 1) 个核心线程数；而所有的 execute 都是线程池外围裹了一层 ScheduledThreadPool，这里和 RxJava 线程池的实现有所相似，可以更方便地提供延时任务和固定频率执行的任务，当然也可以更方便地取消任务的执行，下面让我们来简单地来介绍其使用，以从 assets 中拷贝 APK 到 SD 卡为例，其代码如下所示： 1234567891011121314151617181920212223public static void releaseInstallApk(final OnReleasedListener listener) &#123; if (!FileUtils.isFileExists(Config.TEST_APK_PATH)) &#123; ThreadUtils.executeByIo(new ThreadUtils.SimpleTask&lt;Void&gt;() &#123; @Override public Void doInBackground() throws Throwable &#123; ResourceUtils.copyFileFromAssets("test_install", Config.TEST_APK_PATH); return null; &#125; @Override public void onSuccess(Void result) &#123; if (listener != null) &#123; listener.onReleased(); &#125; &#125; &#125;); &#125; else &#123; if (listener != null) &#123; listener.onReleased(); &#125; LogUtils.d("test apk existed."); &#125;&#125; 看起来还不是很优雅是吧，你可以把相关的 Task 都抽出来放到合适的包下，这样每个 Task 的职责一看便知，如上例子可以改装成如下所示： 123456789101112131415161718192021222324252627282930313233343536public class ReleaseInstallApkTask extends ThreadUtils.SimpleTask&lt;Void&gt; &#123; private OnReleasedListener mListener; public ReleaseInstallApkTask(final OnReleasedListener listener) &#123; mListener = listener; &#125; @Override public Void doInBackground() throws Throwable &#123; ResourceUtils.copyFileFromAssets("test_install", Config.TEST_APK_PATH); return null; &#125; @Override public void onSuccess(Void result) &#123; if (mListener != null) &#123; mListener.onReleased(); &#125; &#125; public void execute() &#123; ThreadUtils.executeByIo(this); &#125;&#125;public static void releaseInstallApk(final OnReleasedListener listener) &#123; if (!FileUtils.isFileExists(Config.TEST_APK_PATH)) &#123; new ReleaseInstallApkTask(listener).execute(); &#125; else &#123; if (listener != null) &#123; listener.onReleased(); &#125; LogUtils.d("test apk existed."); &#125;&#125; 是不是瞬间清爽了很多，如果执行成功的回调中涉及了 View 相关的操作，那么你需要在 destroy 中取消 task 的执行哦，否则会内存泄漏哦，继续以上面的例子为例，代码如下所示： 12345678910public class XXActivity extends Activity &#123; ··· @Override protected void onDestroy() &#123; // ThreadUtils.cancel(releaseInstallApkTask); 或者下面的取消都可以 releaseInstallApkTask.cancel(); super.onDestroy(); &#125;&#125; 以上是以 SimpleTask 为例，Task 的话会多两个回调，onCancel() 和 onFail(Throwable t)，它们和 onSuccess(T result) 都是互斥的，最终回调只会走它们其中之一，并且在 Android 端是发送到主线程中执行，如果是 Java 端的话那就还是会在相应的线程池中执行，这点也方便了我做单元测试。 线程池工具类单元测试如果遇到了异步的单测，你会发现单测很快就跑完呢，并没有等待我们线程跑完再结束，我们可以用 CountDownLatch 来等待线程的结束，或者化异步为同步的做法，这里我们使用 CountDownLatch 来实现，我进行了简单的封装，测试 Fixed 的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public class ThreadUtilsTest &#123; @Test public void executeByFixed() throws Exception &#123; asyncTest(10, new TestRunnable&lt;String&gt;() &#123; @Override public void run(final int index, CountDownLatch latch) &#123; final TestTask&lt;String&gt; task = new TestTask&lt;String&gt;(latch) &#123; @Override public String doInBackground() throws Throwable &#123; Thread.sleep(500 + index * 10); if (index &lt; 4) &#123; return Thread.currentThread() + " :" + index; &#125; else if (index &lt; 7) &#123; cancel(); return null; &#125; else &#123; throw new NullPointerException(String.valueOf(index)); &#125; &#125; @Override void onTestSuccess(String result) &#123; System.out.println(result); &#125; &#125;; ThreadUtils.executeByFixed(3, task); &#125; &#125;); &#125; @Test public void executeByFixedWithDelay() throws Exception &#123; asyncTest(10, new TestRunnable&lt;String&gt;() &#123; @Override public void run(final int index, CountDownLatch latch) &#123; final TestTask&lt;String&gt; task = new TestTask&lt;String&gt;(latch) &#123; @Override public String doInBackground() throws Throwable &#123; Thread.sleep(500); if (index &lt; 4) &#123; return Thread.currentThread() + " :" + index; &#125; else if (index &lt; 7) &#123; cancel(); return null; &#125; else &#123; throw new NullPointerException(String.valueOf(index)); &#125; &#125; @Override void onTestSuccess(String result) &#123; System.out.println(result); &#125; &#125;; ThreadUtils.executeByFixedWithDelay(3, task, 500 + index * 10, TimeUnit.MILLISECONDS); &#125; &#125;); &#125; @Test public void executeByFixedAtFixRate() throws Exception &#123; asyncTest(10, new TestRunnable&lt;String&gt;() &#123; @Override public void run(final int index, CountDownLatch latch) &#123; final TestScheduledTask&lt;String&gt; task = new TestScheduledTask&lt;String&gt;(latch, 3) &#123; @Override public String doInBackground() throws Throwable &#123; Thread.sleep(500 + index * 10); if (index &lt; 4) &#123; return Thread.currentThread() + " :" + index; &#125; else if (index &lt; 7) &#123; cancel(); return null; &#125; else &#123; throw new NullPointerException(String.valueOf(index)); &#125; &#125; @Override void onTestSuccess(String result) &#123; System.out.println(result); &#125; &#125;; ThreadUtils.executeByFixedAtFixRate(3, task, 3000 + index * 10, TimeUnit.MILLISECONDS); &#125; &#125;); &#125; abstract static class TestScheduledTask&lt;T&gt; extends ThreadUtils.Task&lt;T&gt; &#123; private static final AtomicInteger ATOMIC_INTEGER = new AtomicInteger(); private int mTimes; CountDownLatch mLatch; TestScheduledTask(final CountDownLatch latch, final int times) &#123; mLatch = latch; mTimes = times; &#125; abstract void onTestSuccess(T result); @Override public void onSuccess(T result) &#123; onTestSuccess(result); if (ATOMIC_INTEGER.addAndGet(1) % mTimes == 0) &#123; mLatch.countDown(); &#125; &#125; @Override public void onCancel() &#123; System.out.println(Thread.currentThread() + " onCancel: "); mLatch.countDown(); &#125; @Override public void onFail(Throwable t) &#123; System.out.println(Thread.currentThread() + " onFail: " + t); mLatch.countDown(); &#125; &#125; abstract static class TestTask&lt;T&gt; extends ThreadUtils.Task&lt;T&gt; &#123; CountDownLatch mLatch; TestTask(final CountDownLatch latch) &#123; mLatch = latch; &#125; abstract void onTestSuccess(T result); @Override public void onSuccess(T result) &#123; onTestSuccess(result); mLatch.countDown(); &#125; @Override public void onCancel() &#123; System.out.println(Thread.currentThread() + " onCancel: "); mLatch.countDown(); &#125; @Override public void onFail(Throwable t) &#123; System.out.println(Thread.currentThread() + " onFail: " + t); mLatch.countDown(); &#125; &#125; &lt;T&gt; void asyncTest(int threadCount, TestRunnable&lt;T&gt; runnable) throws Exception &#123; CountDownLatch latch = new CountDownLatch(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; runnable.run(i, latch); &#125; latch.await(); &#125; interface TestRunnable&lt;T&gt; &#123; void run(final int index, CountDownLatch latch); &#125;&#125; 最后想说的话感谢大家一起陪伴 AndroidUtilCode 的成长，核心工具类几乎都已囊括，也是汇集了我大量的心血，把开源做到了极致，希望大家可以用的舒心，大大提升开发效率，早日赢取白富美，走上人生巅峰。 后文再添加一个个人对 OkHttp 的线程池的使用分析，算是送上个小福利。 OkHttp 中的线程池使用查看 OkHttp 的源码发现，不论是同步请求还是异步请求，最终都是交给 Dispatcher 做处理，我们看下该类和线程池有关的的主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public final class Dispatcher &#123; // 最大请求数 private int maxRequests = 64; // 相同 host 最大请求数 private int maxRequestsPerHost = 5; // 请求执行线程池，懒加载 private @Nullable ExecutorService executorService; // 就绪状态的异步请求队列 private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); // 运行中的异步请求队列，包括还没完成的请求 private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); public Dispatcher(ExecutorService executorService) &#123; this.executorService = executorService; &#125; public Dispatcher() &#123; &#125; public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; // 和 CachedThreadPool 很相似 executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; synchronized void enqueue(AsyncCall call) &#123; // 不超过最大请求数并且不超过 host 最大请求数 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; // 添加到运行中的异步请求队列 runningAsyncCalls.add(call); // 添加到线程池中运行 executorService().execute(call); &#125; else &#123; // 添加到就绪的异步请求队列 readyAsyncCalls.add(call); &#125; &#125; // 当该异步请求结束的时候，会调用此方法，用于将运行中的异步请求队列中的该请求移除并调整请求队列 // 此时就绪队列中的请求就可以进入运行中的队列 void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true); &#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; // 根据 maxRequests 和 maxRequestsPerHost 来调整 runningAsyncCalls 和 readyAsyncCalls // 使运行中的异步请求不超过两种最大值，并且如果队列有空闲，将就绪状态的请求归类为运行中。 private void promoteCalls() &#123; // 如果运行中的异步队列不小于最大请求数，直接返回 if (runningAsyncCalls.size() &gt;= maxRequests) return; // 如果就绪队列为空，直接返回 if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. // 遍历就绪队列并插入到运行队列 for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; // 运行队列中的数量到达最大请求数，直接返回 if (runningAsyncCalls.size() &gt;= maxRequests) return; &#125; &#125;&#125; 可以发现 OkHttp 不是在线程池中维护线程的个数，线程是通过 Dispatcher 间接控制，线程池中的请求都是运行中的请求，这也就是说线程的重用不是线程池控制的，通过源码我们发现线程重用的地方是请求结束的地方 finished(AsyncCall call) ，而真正的控制是通过 promoteCalls 方法， 根据 maxRequests 和 maxRequestsPerHost 来调整 runningAsyncCalls 和 readyAsyncCalls，使运行中的异步请求不超过两种最大值，并且如果队列有空闲，将就绪状态的请求归类为运行中。]]></content>
      <categories>
        <category>Android</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>工具类</tag>
        <tag>线程池</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这个 RxBus 稳如老狗]]></title>
    <url>%2F2018%2F05%2F09%2Fawesome-rxbus%2F</url>
    <content type="text"><![CDATA[DownloadGradle:1implementation "com.blankj:rxbus:1.0" How to use非粘性事件 注册事件 123456789101112131415161718192021222324252627282930public class YourActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 注册 String 类型事件 RxBus.getDefault().subscribe(this, new RxBus.Callback&lt;String&gt;() &#123; @Override public void onEvent(String s) &#123; Log.e("eventTag", s); &#125; &#125;); // 注册带 tag 为 "my tag" 的 String 类型事件 RxBus.getDefault().subscribe(this, "my tag", new RxBus.Callback&lt;String&gt;() &#123; @Override public void onEvent(String s) &#123; Log.e("eventTag", s); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 注销 RxBus.getDefault().unregister(this); &#125;&#125; 发送事件 12345// 发送 String 类型事件RxBus.getDefault().post("without tag");// 发送带 tag 为 "my tag" 的 String 类型事件RxBus.getDefault().post("with tag", "my tag"); 粘性事件（也就是先发送事件，在之后注册的时候便会收到之前发送的事件） 发送事件 12345// 发送 String 类型的粘性事件RxBus.getDefault().postSticky("without tag");// 发送带 tag 为 "my tag" 的 String 类型的粘性事件RxBus.getDefault().postSticky("with tag", "my tag"); 注册事件 123456789101112131415161718192021222324252627282930public class YourActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 注册 String 类型事件 RxBus.getDefault().subscribeSticky(this, new RxBus.Callback&lt;String&gt;() &#123; @Override public void onEvent(String s) &#123; Log.e("eventTag", s); &#125; &#125;); // 注册带 tag 为 "my tag" 的 String 类型事件 RxBus.getDefault().subscribeSticky(this, "my tag", new RxBus.Callback&lt;String&gt;() &#123; @Override public void onEvent(String s) &#123; Log.e("eventTag", s); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 注销 RxBus.getDefault().unregister(this); &#125;&#125; Nice wrap如果用到事件总线的地方比较多，那么可以把事件总线的使用放到一个 Manager 中使用，比如我 Demo 中做的封装如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940public class RxBusManager &#123; private static final String MY_TAG = "MY_TAG"; public static void subscribeRxBusManagerActivity(final RxBusManagerActivity activity)&#123; RxBus.getDefault().subscribe(activity, new RxBus.Callback&lt;String&gt;() &#123; @Override public void onEvent(String s) &#123; activity.updateText("without " + s); &#125; &#125;); RxBus.getDefault().subscribe(activity, MY_TAG, new RxBus.Callback&lt;String&gt;() &#123; @Override public void onEvent(String s) &#123; activity.updateText("with " + s); &#125; &#125;); &#125; public static void postToRxBusManagerActivity(final String event) &#123; RxBus.getDefault().post(event); &#125; public static void postWithMyTagToRxBusManagerActivity(final String event) &#123; RxBus.getDefault().post(event, MY_TAG); &#125; public static void postStickyToRxBusManagerActivity(final String event) &#123; RxBus.getDefault().postSticky(event); &#125; public static void postStickyWithMyTagToRxBusManagerActivity(final String event) &#123; RxBus.getDefault().postSticky(event, MY_TAG); &#125; public static void unregisterRxBusManagerActivity(final RxBusManagerActivity activity) &#123; RxBus.getDefault().unregister(activity); &#125;&#125; 可以看出这是在 RxBusManagerActivity 中要使用 RxBus 的相关代码，这样可以更方便地管理应用中所有的事件总线，而不至于发了个事件都不清楚接收方在哪的尴尬。 How it comes网上现有 RxBus 存有的问题： 使用的 RxBus 大多停留在 RxJava1 版本 RxBus 实现的粘性事件很多都是有问题的 如果事件抛了异常，之后便再也无法接收到的问题 同类型事件需自己再次封装 Bean 进行区别。 介于以上问题，我还是亲自封装一个简洁的供大家使用，库已经依赖了 RxAndroid 和 RxJava，所以导入了该库的就不需要再额外导入那两库了。 当然，如果通信频率比较高追求效率的话还是推荐使用 EventBus。 Principle 利用 FlowableProcessor 既可以作为观察者又可以作为被观察者来实现事件总线 粘性事件原理就是发送的时候把事件存到一个 hash 表中，在注册的时候查询下 hash 表中是否存在符合的事件，有的话就消费掉即可 替换原有 LambdaSubscriber 来让抛了异常之后可以继续接收到后续事件 封装了 TagMessage 来区分不同类别的 tag 动态识别范型对象来省去传入 Type 类型 还有一些细节就自己看源码去了解吧，总共有用的代码不超过 300 行哈。 Change log]]></content>
      <categories>
        <category>Android</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxBus</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitBook 使用教程]]></title>
    <url>%2F2018%2F04%2F16%2Fgitbook-use%2F</url>
    <content type="text"><![CDATA[GitBook 使用教程首先先献上 我的 GitBook 地址，可以在我的 博客 导航栏处找到，下面进行相关的介绍。 背景由于之前都把零散的知识都写在 Gist 上，要查找的时候不是很系统化，所以打算挪到 GitBook 上来统一管理，而且 GitBook 写完编译后可以生成静态页面发布到博客上，逼格满满的样子。 GitBook 简介 GitBook 官网 GitBook 文档 GitBook 准备工作安装 Node.jsGitBook 是一个基于 Node.js 的命令行工具，下载安装 Node.js，安装完成之后，你可以使用下面的命令来检验是否安装成功。 12$ node -vv7.7.1 安装 GitBook输入下面的命令来安装 GitBook。 1$ npm install gitbook-cli -g 安装完成之后，你可以使用下面的命令来检验是否安装成功。 123$ gitbook -VCLI version: 2.3.2GitBook version: 3.2.3 更多详情请参照 GitBook 安装文档 来安装 GitBook。 安装 GitBook 编辑器去 GitBook 官网 下载 GitBook 编辑器；如果是 Mac 用户且安装过 brew cask 的话可以使用 brew cask install gitbook-editor 命令行来安装 GitBook 编辑器。 先睹为快GitBook 准备工作做好之后，我们进入一个你要写书的目录，输入如下命令。 12345$ gitbook initwarn: no summary file in this bookinfo: create README.mdinfo: create SUMMARY.mdinfo: initialization is finished 可以看到他会创建 README.md 和 SUMMARY.md 这两个文件，README.md 应该不陌生，就是说明文档，而 SUMMARY.md 其实就是书的章节目录，其默认内容如下所示： 123# Summary* [Introduction](README.md) 接下来，我们输入 $ gitbook serve 命令，然后在浏览器地址栏中输入 http://localhost:4000 便可预览书籍。 效果如下所示： 运行该命令后会在书籍的文件夹中生成一个 _book 文件夹, 里面的内容即为生成的 html 文件，我们可以使用下面命令来生成网页而不开启服务器。 1gitbook build 下面我们来详细介绍下 GitBook 目录结构及相关文件。 目录结构GitBook 基本的目录结构如下所示： 12345678910.├── book.json├── README.md├── SUMMARY.md├── chapter-1/| ├── README.md| └── something.md└── chapter-2/ ├── README.md └── something.md 下面我们主要来讲讲 book.json 和 SUMMARY.md 文件。 book.json该文件主要用来存放配置信息，我先放出我的配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&#123; "title": "Blankj's Glory", "author": "Blankj", "description": "select * from learn", "language": "zh-hans", "gitbook": "3.2.3", "styles": &#123; "website": "./styles/website.css" &#125;, "structure": &#123; "readme": "README.md" &#125;, "links": &#123; "sidebar": &#123; "我的狗窝": "https://blankj.com" &#125; &#125;, "plugins": [ "-sharing", "splitter", "expandable-chapters-small", "anchors", "github", "github-buttons", "donate", "sharing-plus", "anchor-navigation-ex", "favicon" ], "pluginsConfig": &#123; "github": &#123; "url": "https://github.com/Blankj" &#125;, "github-buttons": &#123; "buttons": [&#123; "user": "Blankj", "repo": "glory", "type": "star", "size": "small", "count": true &#125; ] &#125;, "donate": &#123; "alipay": "https://blankj.com/gitbook/source/images/donate.png", "title": "", "button": "赞赏", "alipayText": " " &#125;, "sharing": &#123; "douban": false, "facebook": false, "google": false, "hatenaBookmark": false, "instapaper": false, "line": false, "linkedin": false, "messenger": false, "pocket": false, "qq": false, "qzone": false, "stumbleupon": false, "twitter": false, "viber": false, "vk": false, "weibo": false, "whatsapp": false, "all": [ "google", "facebook", "weibo", "twitter", "qq", "qzone", "linkedin", "pocket" ] &#125;, "anchor-navigation-ex": &#123; "showLevel": false &#125;, "favicon":&#123; "shortcut": "./source/images/favicon.jpg", "bookmark": "./source/images/favicon.jpg", "appleTouch": "./source/images/apple-touch-icon.jpg", "appleTouchMore": &#123; "120x120": "./source/images/apple-touch-icon.jpg", "180x180": "./source/images/apple-touch-icon.jpg" &#125; &#125; &#125;&#125; 相信很多节点自己也能猜到是什么意思，我还是简单介绍下吧。 title本书标题 author本书作者 description本书描述 language本书语言，中文设置 “zh-hans” 即可 gitbook指定使用的 GitBook 版本 styles自定义页面样式 structure指定 Readme、Summary、Glossary 和 Languages 对应的文件名 links在左侧导航栏添加链接信息 plugins配置使用的插件 pluginsConfig配置插件的属性 SUMMARY.md这个文件主要决定 GitBook 的章节目录，它通过 Markdown 中的列表语法来表示文件的父子关系，下面是一个简单的示例： 123456789# Summary* [Introduction](README.md)* [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md)* [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) 这个配置对应的目录结构如下所示: 我们通过使用 标题 或者 水平分割线 将 GitBook 分为几个不同的部分，如下所示： 12345678910111213141516# Summary### Part I* [Introduction](README.md)* [Writing is nice](part1/writing.md)* [GitBook is nice](part1/gitbook.md)### Part II* [We love feedback](part2/feedback_please.md)* [Better tools for authors](part2/better_tools.md)---* [Last part without title](part3/title.md) 这个配置对应的目录结构如下所示: 插件GitBook 有 插件官网，默认带有 5 个插件，highlight、search、sharing、font-settings、livereload，如果要去除自带的插件， 可以在插件名称前面加 -，比如： 123&quot;plugins&quot;: [ &quot;-search&quot;] 如果要配置使用的插件可以在 book.json 文件中加入即可，比如我们添加 plugin-github，我们在 book.json 中加入配置如下即可： 12345678&#123; &quot;plugins&quot;: [ &quot;github&quot; ], &quot;pluginsConfig&quot;: &#123; &quot;github&quot;: &#123; &quot;url&quot;: &quot;https://github.com/your/repo&quot; &#125; &#125;&#125; 然后在终端输入 gitbook install ./ 即可。 如果要指定插件的版本可以使用 plugin@0.3.1，因为一些插件可能不会随着 GitBook 版本的升级而升级。 结语这是我对 GitBook 使用的总结，希望能帮到今后需要的小伙伴。]]></content>
      <categories>
        <category>GitBook</category>
      </categories>
      <tags>
        <tag>GitBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 AS 3.1.0 版本 Logcat 合并多条日志的问题]]></title>
    <url>%2F2018%2F04%2F12%2Fsolve-logcat%2F</url>
    <content type="text"><![CDATA[在升级到 AS 3.1.0 版本后，Logcat 会合并短时间内同 tag 的日志，具体情况如下图所示： 一些三方日志库都会存在上述问题，当然，AndroidUtilCode 在第一时间就解决了该问题，如今只需使用 1.13.8 以上版本即可，如果嫌 AndroidUtilCode 太庞大的话，我这里也提供了单一的日志库：一个精简、全面、方便的 Android 日志库：ALog。对如上日志输出如下所示： 当然，你如果还想要以前那样的效果，我也做了兼容，只需要初始化的时候进行如下设置即可。 1setSingleTagSwitch(false)// 一条日志仅输出一条，默认开，为美化 AS 3.1.0 的 Logcat` 再顺带说一下日志工具的功能吧 兼容 Android Studio 3.1.0 的 Logcat 完美显示日志 兼容 Kotlin 可设置 Log 开启和关闭 可设置是否输出到控制台（Logcat） 可设置 Log 全局 Tag 全局 Tag 为空时 Tag 为当前类名 可设置 Log 是否显示头部信息 Log 文件顶部显示设备信息 Log 头部含有当前线程名 Log 头部含有当前类及行号和函数名，支持点击跳转 可设置 Log 是否写入文件 可设置 Log 写入文件目录 可设置 Log 写入文件前缀 可设置 Log 是否显示边框 可设置 Log 控制台过滤器 可设置 Log 文件过滤器 可设置 Log 栈深度 支持控制台长字符串的输出 支持多参数输出 支持单独写入文件 支持 JSON 串的输出 支持 XML 串的输出 支持 Live Templates 如果正好帮到了你，那可真是巧了哈。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Logcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射工具类，如斯优雅]]></title>
    <url>%2F2018%2F01%2F17%2Fawesome-reflectutils%2F</url>
    <content type="text"><![CDATA[Foreword反射的作用我在这就不多说了，每次用到反射都是那么一坨代码丢进去，总是让人觉得很不优雅，如今有了我这个反射工具类，那么大家就可以一句话优雅地来完成反射的工作，该工具类是站在 jOOR 的肩膀上进行改造，修复了它没有完成的工作，至于修复了什么，后面源码分析会详述，至于这个工具类在哪，现已加入至 1.12.0 版本的 AndroidUtilCode，下面来介绍下其功能。 Functions其 APIs 如下所示： 反射相关 -&gt; ReflectUtils.java -&gt; Test 12345reflect : 设置要反射的类newInstance: 实例化反射对象field : 设置反射的字段method : 设置反射的方法get : 获取反射想要获取的 Use实例化反射对象比如，我们实例化一个 String 对象可以这样做： 12345678String str1 = ReflectUtils.reflect(String.class).newInstance().get();// equals: String str1 = new String();String str2 = ReflectUtils.reflect("java.lang.String").newInstance("abc").get();// equals: String str2 = new String("abc");String str3 = ReflectUtils.reflect(String.class).newInstance("abc".getBytes()).get();// equals: String str3 = new String("abc".getBytes()); 设置反射的方法比如，我们想要调用 String 的 substring 函数可以这样做： 12345String str1 = ReflectUtils.reflect((Object) "1234").method("substring", 2).get();// equals: String str1 = "1234".substring(2);String str2 = ReflectUtils.reflect((Object) "1234").method("substring", 0, 2).get();// equals: String str1 = "1234".substring(0, 2); 设置反射的字段比如，TestPrivateStaticFinal.java 如下所示： 1234public class TestPrivateStaticFinal &#123; private static final int I1 = new Integer(1); private static final Integer I2 = new Integer(1);&#125; 我们要设置其 I1、I2 值为 2，可以如下操作： 12ReflectUtils.reflect(TestPrivateStaticFinal.class).field("I1", 2);ReflectUtils.reflect(TestPrivateStaticFinal.class).field("I2", 2); 要获取其 I1、I2 值的话，可以如下操作： 12ReflectUtils.reflect(TestPrivateStaticFinal.class).field("I1").get()ReflectUtils.reflect(TestPrivateStaticFinal.class).field("I2").get() 当然，字段操作也有更高级的操作，比如 Test1.java 测试类如下所示： 123456789public class Test1 &#123; public static int S_INT1; public static Integer S_INT2; public int I_INT1; public Integer I_INT2; public static Test1 S_DATA; public Test1 I_DATA;&#125; 我对其进行的单元测试如下所示： 12345678910111213141516@Testpublic void fieldAdvanced() throws Exception &#123; ReflectUtils.reflect(Test1.class) .field("S_DATA", ReflectUtils.reflect(Test1.class).newInstance())// 设置 Test1.class 中 S_DATA 字段 为 new Test1() .field("S_DATA")// 获取到 Test1.class 中 S_DATA 字段 .field("I_DATA", ReflectUtils.reflect(Test1.class).newInstance())// 获取到 Test1.class 中 S_DATA 字段 的 I_DATA 为 new Test1() .field("I_DATA")// 获取到 Test1.class 中 S_DATA 字段 的 I_DATA 字段 .field("I_INT1", 1)// 设置 Test1.class 中 S_DATA 字段 的 I_DATA 字段的 I_INT1 值为 1 .field("S_INT1", 2);// 设置 Test1.class 中 S_DATA 字段 的 S_INT1 字段的 I_INT1 值为 2 assertEquals(2, Test1.S_INT1);// 静态变量就是最后设置的 2 assertEquals(null, Test1.S_INT2);// 没操作过就是 null assertEquals(0, Test1.S_DATA.I_INT1);// 没操作过就是 0 assertEquals(null, Test1.S_DATA.I_INT2);// 没操作过就是 0 assertEquals(1, Test1.S_DATA.I_DATA.I_INT1);// 倒数第二步操作设置为 1 assertEquals(null, Test1.S_DATA.I_DATA.I_INT2);// 没操作过就是 null&#125; 根据如上注释相信大家也可以理解一二了，如果还想了解更多使用方式，可以查看我写的单元测试类 ReflectUtilsTest，其使用方式就介绍到这里，下面介绍其实现方式。 Achieve实现的话是站在 jOOR 的肩膀上进行改造，其内部封装了一个 private final Object object; 变量，每次进行反射操作时都会重新实例化一个变量并把结果赋予该变量，最终 get() 就是获取其值，比如我们来看一下 newInstance 的操作，其涉及的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 实例化反射对象 * * @param args 实例化需要的参数 * @return &#123;@link ReflectUtils&#125; */public ReflectUtils newInstance(Object... args) &#123; Class&lt;?&gt;[] types = getArgsType(args); try &#123; Constructor&lt;?&gt; constructor = type().getDeclaredConstructor(types); return newInstance(constructor, args); &#125; catch (NoSuchMethodException e) &#123; List&lt;Constructor&lt;?&gt;&gt; list = new ArrayList&lt;&gt;(); for (Constructor&lt;?&gt; constructor : type().getDeclaredConstructors()) &#123; if (match(constructor.getParameterTypes(), types)) &#123; list.add(constructor); &#125; &#125; if (list.isEmpty()) &#123; throw new ReflectException(e); &#125; else &#123; sortConstructors(list); return newInstance(list.get(0), args); &#125; &#125;&#125;private Class&lt;?&gt;[] getArgsType(final Object... args) &#123; if (args == null) return new Class[0]; Class&lt;?&gt;[] result = new Class[args.length]; for (int i = 0; i &lt; args.length; i++) &#123; Object value = args[i]; result[i] = value == null ? NULL.class : value.getClass(); &#125; return result;&#125;private void sortConstructors(List&lt;Constructor&lt;?&gt;&gt; list) &#123; Collections.sort(list, new Comparator&lt;Constructor&lt;?&gt;&gt;() &#123; @Override public int compare(Constructor&lt;?&gt; o1, Constructor&lt;?&gt; o2) &#123; Class&lt;?&gt;[] types1 = o1.getParameterTypes(); Class&lt;?&gt;[] types2 = o2.getParameterTypes(); int len = types1.length; for (int i = 0; i &lt; len; i++) &#123; if (!types1[i].equals(types2[i])) &#123; if (wrapper(types1[i]).isAssignableFrom(wrapper(types2[i]))) &#123; return 1; &#125; else &#123; return -1; &#125; &#125; &#125; return 0; &#125; &#125;);&#125;private ReflectUtils newInstance(final Constructor&lt;?&gt; constructor, final Object... args) &#123; try &#123; return new ReflectUtils( constructor.getDeclaringClass(), accessible(constructor).newInstance(args) ); &#125; catch (Exception e) &#123; throw new ReflectException(e); &#125;&#125;private final Class&lt;?&gt; type;private final Object object;private ReflectUtils(final Class&lt;?&gt; type, Object object) &#123; this.type = type; this.object = object;&#125; jOOR 所没有做到的就是没有对多个符合的 Constructor 进行排序，而是直接返回了第一个与之匹配的。这样说有点抽象，我举个例子应该就明白了，比如说有两个构造函数如下所示： 12345678public class Test &#123; public Test(Number n) &#123; &#125; public Test(Object n) &#123; &#125;&#125; jOOR 反射调用构造函数参数传入 Long 类型，很可能就会走 Test(Object n) 这个构造函数，而我修改过后就是对多个符合的 Constructor 进行排序，匹配出与之最接近的父类，也就是会走 Test(Number n) 这个构造函数，同理，在后面的 method 中的参数匹配 jOOR 也是存在这个问题，我也已经对其修复了。 还有就是 jOOR 对 private static final 字段先 get 再 set 会报异常 java.lang.IllegalAccessException 异常，是因为对 private static final 字段 get 的时候没有去除 final 属性，如果在 get 时就把 final 去掉即可解决，那样在 set 的时候就不会报错。然而，在 Android 的 SDK 中是没有 Field.class.getDeclaredField(&quot;modifiers&quot;) 这个字段的，所以会报 NoSuchFieldException 异常，这方面我做了容错处理，相关代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 设置反射的字段 * * @param name 字段名 * @return &#123;@link ReflectUtils&#125; */public ReflectUtils field(final String name) &#123; try &#123; Field field = getField(name); return new ReflectUtils(field.getType(), field.get(object)); &#125; catch (IllegalAccessException e) &#123; throw new ReflectException(e); &#125;&#125;/** * 设置反射的字段 * * @param name 字段名 * @param value 字段值 * @return &#123;@link ReflectUtils&#125; */public ReflectUtils field(String name, Object value) &#123; try &#123; Field field = getField(name); field.set(object, unwrap(value)); return this; &#125; catch (Exception e) &#123; throw new ReflectException(e); &#125;&#125;private Field getField(String name) throws IllegalAccessException &#123; Field field = getAccessibleField(name); if ((field.getModifiers() &amp; Modifier.FINAL) == Modifier.FINAL) &#123; try &#123; Field modifiersField = Field.class.getDeclaredField("modifiers"); modifiersField.setAccessible(true); modifiersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL); &#125; catch (NoSuchFieldException ignore) &#123; // runs in android will happen &#125; &#125; return field;&#125;private Field getAccessibleField(String name) &#123; Class&lt;?&gt; type = type(); try &#123; return accessible(type.getField(name)); &#125; catch (NoSuchFieldException e) &#123; do &#123; try &#123; return accessible(type.getDeclaredField(name)); &#125; catch (NoSuchFieldException ignore) &#123; &#125; type = type.getSuperclass(); &#125; while (type != null); throw new ReflectException(e); &#125;&#125;private Object unwrap(Object object) &#123; if (object instanceof ReflectUtils) &#123; return ((ReflectUtils) object).get(); &#125; return object;&#125; 所以该工具类既完美支持 Java，也完美支持 Android。 Conclusion好了，这次反射工具类就介绍到这了，是不是觉得如斯优雅，如果觉得好的话以后遇到反射的问题，那就快用我这个工具类吧，这么好的东西藏着不用真的是可惜了哦。 关于安卓核心常用工具类我已经差不多都封装了，今后应该也不会在核心的里面新增了，除非确实很需要我才会再新增某个工具类，其余不常用的我都会放在 subutil 中，感谢大家一直陪伴着 AndroidUtilCode 的成长。]]></content>
      <categories>
        <category>Android</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于等到你--权限工具类]]></title>
    <url>%2F2018%2F01%2F10%2Ffinally-get-permissionutils%2F</url>
    <content type="text"><![CDATA[Foreword之前总是有小伙伴问 AndroidUtilCode 中有没有权限工具类，但都被我怼回去了，让先用着其他第三方的，不过，到了如今的 1.11.0 版本的 AndroidUtilCode，这个一直拖欠着的权限工具类总算要问世了，以后小伙伴们如果用 AndroidUtilCode 需要动态授权的话，就不用再多依赖一个第三方库了，下面来介绍下其功能。 Functions 兼容安卓各版本，包括 Android 8.0 支持任意地方申请权限，不仅限于 Activity 和 Fragment 等 支持多权限同时申请 采用链式调用，一句话解决权限申请 Achieve首先来介绍其实现方式，关于运行时权限的介绍可以在官网查看 -&gt; 传送门。关于危险权限列表，我封装危险权限常量类 PermissionConstants.java，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import android.Manifest;import android.Manifest.permission;import android.annotation.SuppressLint;import android.support.annotation.StringDef;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * &lt;pre&gt; * author: Blankj * blog : http://blankj.com * time : 2017/12/29 * desc : 权限相关常量 * &lt;/pre&gt; */@SuppressLint("InlinedApi")public final class PermissionConstants &#123; public static final String CALENDAR = Manifest.permission_group.CALENDAR; public static final String CAMERA = Manifest.permission_group.CAMERA; public static final String CONTACTS = Manifest.permission_group.CONTACTS; public static final String LOCATION = Manifest.permission_group.LOCATION; public static final String MICROPHONE = Manifest.permission_group.MICROPHONE; public static final String PHONE = Manifest.permission_group.PHONE; public static final String SENSORS = Manifest.permission_group.SENSORS; public static final String SMS = Manifest.permission_group.SMS; public static final String STORAGE = Manifest.permission_group.STORAGE; private static final String[] GROUP_CALENDAR = &#123; permission.READ_CALENDAR, permission.WRITE_CALENDAR &#125;; private static final String[] GROUP_CAMERA = &#123; permission.CAMERA &#125;; private static final String[] GROUP_CONTACTS = &#123; permission.READ_CONTACTS, permission.WRITE_CONTACTS, permission.GET_ACCOUNTS &#125;; private static final String[] GROUP_LOCATION = &#123; permission.ACCESS_FINE_LOCATION, permission.ACCESS_COARSE_LOCATION &#125;; private static final String[] GROUP_MICROPHONE = &#123; permission.RECORD_AUDIO &#125;; private static final String[] GROUP_PHONE = &#123; permission.READ_PHONE_STATE, permission.READ_PHONE_NUMBERS, permission.CALL_PHONE, permission.ANSWER_PHONE_CALLS, permission.READ_CALL_LOG, permission.WRITE_CALL_LOG, permission.ADD_VOICEMAIL, permission.USE_SIP, permission.PROCESS_OUTGOING_CALLS &#125;; private static final String[] GROUP_SENSORS = &#123; permission.BODY_SENSORS &#125;; private static final String[] GROUP_SMS = &#123; permission.SEND_SMS, permission.RECEIVE_SMS, permission.READ_SMS, permission.RECEIVE_WAP_PUSH, permission.RECEIVE_MMS, &#125;; private static final String[] GROUP_STORAGE = &#123; permission.READ_EXTERNAL_STORAGE, permission.WRITE_EXTERNAL_STORAGE &#125;; @StringDef(&#123;CALENDAR, CAMERA, CONTACTS, LOCATION, MICROPHONE, PHONE, SENSORS, SMS, STORAGE,&#125;) @Retention(RetentionPolicy.SOURCE) public @interface Permission &#123; &#125; public static String[] getPermissions(@Permission final String permission) &#123; switch (permission) &#123; case CALENDAR: return GROUP_CALENDAR; case CAMERA: return GROUP_CAMERA; case CONTACTS: return GROUP_CONTACTS; case LOCATION: return GROUP_LOCATION; case MICROPHONE: return GROUP_MICROPHONE; case PHONE: return GROUP_PHONE; case SENSORS: return GROUP_SENSORS; case SMS: return GROUP_SMS; case STORAGE: return GROUP_STORAGE; &#125; return new String[]&#123;permission&#125;; &#125;&#125; 为了适配 Android 8.0，我在申请权限的时候，会把清单文件中使用到的同组的权限都一次性申请完毕，相关代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private static final List&lt;String&gt; PERMISSIONS = getPermissions();/** * 获取应用权限 * * @return 清单文件中的权限列表 */public static List&lt;String&gt; getPermissions() &#123; return getPermissions(Utils.getApp().getPackageName());&#125;/** * 获取应用权限 * * @param packageName 包名 * @return 清单文件中的权限列表 */public static List&lt;String&gt; getPermissions(final String packageName) &#123; PackageManager pm = Utils.getApp().getPackageManager(); try &#123; return Arrays.asList( pm.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS) .requestedPermissions ); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); return Collections.emptyList(); &#125;&#125;/** * 设置请求权限 * * @param permissions 要请求的权限 * @return &#123;@link PermissionUtils&#125; */public static PermissionUtils permission(@Permission final String... permissions) &#123; return new PermissionUtils(permissions);&#125;private PermissionUtils(final String... permissions) &#123; mPermissions = new LinkedHashSet&lt;&gt;(); for (String permission : permissions) &#123; for (String aPermission : PermissionConstants.getPermissions(permission)) &#123; if (PERMISSIONS.contains(aPermission)) &#123; mPermissions.add(aPermission); &#125; &#125; &#125; sInstance = this;&#125; 为了支持任意地方都可以申请权限，我在 PermissionUtils.java 中封装了 PermissionActivity，源码如下所示： 12345678910111213141516171819202122232425262728293031323334353637@RequiresApi(api = Build.VERSION_CODES.M)public static class PermissionActivity extends Activity &#123; public static void start(final Context context) &#123; Intent starter = new Intent(context, PermissionActivity.class); starter.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(starter); &#125; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; if (sInstance.mThemeCallback != null) &#123; sInstance.mThemeCallback.onActivityCreate(this); &#125; else &#123; Window window = getWindow(); window.setBackgroundDrawable(null); int option = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN; window.getDecorView().setSystemUiVisibility(option); window.setStatusBarColor(Color.TRANSPARENT); &#125; super.onCreate(savedInstanceState); if (sInstance.rationale(this)) &#123; finish(); return; &#125; if (sInstance.mPermissionsRequest != null) &#123; int size = sInstance.mPermissionsRequest.size(); requestPermissions(sInstance.mPermissionsRequest.toArray(new String[size]), 1); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; sInstance.onRequestPermissionsResult(this); finish(); &#125;&#125; 这样我们便可以自己全权处理权限请求，但启动的这个 PermissionActivity 的主题并不一定符合小伙伴们应用的 Activity 相关主题，所以我留了个设置主题的回调接口，比如可以把这个 Activity 设置为全屏等操作，这样便可无感知地启动一个 Activity，相关主题属性如下： 123456789101112&lt;style name=&quot;ActivityTranslucent&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 这个应该能适配很多应用了。 当然，如果有设置 rationale 的话，也就是设置拒绝权限后再次请求的回调接口，此时便会走 sInstance.rationale(this)，具体代码如下所示： 12345678910111213141516171819202122232425@RequiresApi(api = Build.VERSION_CODES.M)private boolean rationale(final Activity activity) &#123; boolean isRationale = false; if (mOnRationaleListener != null) &#123; for (String permission : mPermissionsRequest) &#123; if (activity.shouldShowRequestPermissionRationale(permission)) &#123; getPermissionsStatus(activity); mOnRationaleListener.rationale(new ShouldRequest() &#123; @Override public void again(boolean again) &#123; if (again) &#123; startPermissionActivity(); &#125; else &#123; requestCallback(); &#125; &#125; &#125;); isRationale = true; break; &#125; &#125; mOnRationaleListener = null; &#125; return isRationale;&#125; 逻辑就是如果 rationale 回调接口 执行了 shouldRequest.again(true);，那么就会继续申请下去，反之则不再申请，多用在弹出一个提示对话框来让用户选择是否继续请求权限。 最终就是发起请求和接受请求，并把最终状态保存到 mPermissionsGranted、mPermissionsDenied 和 mPermissionsDeniedForever 中，最终回调 callback 的接口，相关代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void getPermissionsStatus(final Activity activity) &#123; for (String permission : mPermissionsRequest) &#123; if (isGranted(permission)) &#123; mPermissionsGranted.add(permission); &#125; else &#123; mPermissionsDenied.add(permission); if (!activity.shouldShowRequestPermissionRationale(permission)) &#123; mPermissionsDeniedForever.add(permission); &#125; &#125; &#125;&#125;private void requestCallback() &#123; if (mSimpleCallback != null) &#123; if (mPermissionsRequest.size() == 0 || mPermissions.size() == mPermissionsGranted.size()) &#123; mSimpleCallback.onGranted(); &#125; else &#123; if (!mPermissionsDenied.isEmpty()) &#123; mSimpleCallback.onDenied(); &#125; &#125; mSimpleCallback = null; &#125; if (mFullCallback != null) &#123; if (mPermissionsRequest.size() == 0 || mPermissions.size() == mPermissionsGranted.size()) &#123; mFullCallback.onGranted(mPermissionsGranted); &#125; else &#123; if (!mPermissionsDenied.isEmpty()) &#123; mFullCallback.onDenied(mPermissionsDeniedForever, mPermissionsDenied); &#125; &#125; mFullCallback = null; &#125; mOnRationaleListener = null; mThemeCallback = null;&#125;private void onRequestPermissionsResult(final Activity activity) &#123; getPermissionsStatus(activity); requestCallback();&#125; Use说了那么多，总算到使用了，其实使用起来非常方便，一句话即可，比如我们要申请 android.permission.READ_CALENDAR 权限，那么我们可以去 PermissionConstants.java 中找到其所属组，也就是 CALENDAR，而应用是全屏类型的应用，那么我们可以像下面这样发起请求。 12345678910111213141516171819202122232425262728PermissionUtils.permission(PermissionConstants.CALENDAR) .rationale(new PermissionUtils.OnRationaleListener() &#123; @Override public void rationale(final ShouldRequest shouldRequest) &#123; PermissionHelper.showRationaleDialog(shouldRequest); &#125; &#125;) .callback(new PermissionUtils.FullCallback() &#123; @Override public void onGranted(List&lt;String&gt; permissionsGranted) &#123; updateAboutPermission(); &#125; @Override public void onDenied(List&lt;String&gt; permissionsDeniedForever, List&lt;String&gt; permissionsDenied) &#123; if (!permissionsDeniedForever.isEmpty()) &#123; PermissionHelper.showOpenAppSettingDialog(); &#125; LogUtils.d(permissionsDeniedForever, permissionsDenied); &#125; &#125;) .theme(new PermissionUtils.ThemeCallback() &#123; @Override public void onActivityCreate(Activity activity) &#123; ScreenUtils.setFullScreen(activity); &#125; &#125;) .request(); 如果还有不会的可以参考 AndroidUtilCode 中的 demo -&gt; PermissionActivity.java Tips：推荐小伙伴们最好把权限请求相关的操作都放在一个 helper 类中，就像我 AndroidUtilCode 中 demo 的做法，创建一个 PermissionHelper.java，毕竟有很多权限请求都是重复。 Conclusion好了，本次的权限工具类介绍就到此结束了，在这么简洁的工具类背后都是本柯基辛勤付出的汗水，疯狂地 debug，疯狂地测试来消除内存泄漏的问题，虽然路途很艰辛，但最终还是成功地完成了该工具类，终于等到你。]]></content>
      <categories>
        <category>Android</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启你的终端装逼第一步]]></title>
    <url>%2F2017%2F12%2F05%2Flet-ur-term-dress-b%2F</url>
    <content type="text"><![CDATA[作为开发人员，和终端的亲密度那肯定不是一般地高，以上便是我打开终端迎面而来的画面，是不是逼格满满，23333，下面来教大家如何在 mac 上配置，其他系统应该也同理。 首先打开终端（这一步要是不会，那老铁你就别配置了吧）。 输入 cd /etc 进入目录。 输入 sudo pico motd,然后输入密码后进入修改页面。 然后在其中输入你想显示的装逼内容，再此提供一个图形界面网站：这是一个神奇的网站，干货满满吧，顺带提供我的，如下所示。 123456789101112131415161718192021222324252627282930 ________________________________________________________________/ _____________________________________________________________ \| | | || | &gt;_ . | || | . * | || | &quot; .. | || | .=*&amp;æ..=&quot;&quot;&quot;*. | || | . &quot;&quot; * | || | &amp; * | || | &amp;c . | || | *e * | || | &quot;&amp;b . | || | &amp;æ . . | || | &amp;ææ&quot;&quot;æ= | || | &quot; | || | ______ ______ ______ | || | |______||_____/ | | | || | | | \ |______| | || | | || |_____________________________________________________________| |\____________________________________________________________________/ \_______________________________________/ .---------------------------------------------. _-&apos;.... .-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-. ....`-_ _-&apos;..... .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--. .....`-_ _-&apos;....... .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-`__`. .......`-__-&apos;......... .-----.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-----. .........`-__-&apos;........... .---.-. .-----------------------------. .-.---. ...........`-_:-----------------------------------------------------------------------------:`-----------------------------------------------------------------------------&apos; 最后 control + x，输入 y 保存，重启终端就可以看到逼格满满的欢迎页了。]]></content>
      <categories>
        <category>装逼</category>
      </categories>
      <tags>
        <tag>终端</tag>
        <tag>装逼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facebook面经记]]></title>
    <url>%2F2017%2F10%2F31%2Ffacebook-interview%2F</url>
    <content type="text"><![CDATA[背景可能由于我 GitHub 较为活跃，国庆期间居然收到了 Facebook 的面试邀请函，既然有这机肥，当然不能浪费，试试那就试试吧，下面是我的 GitHub 页面及面试邀请函。 准备电面流程在和HR交流前我也查看了很多关于 Facebook 面试相关流程，正所谓知己知彼，百战百胜。HR是在新加坡的，和他交流还是用中国话，简单交流完之后就给我发了面试相关邮件，不过之后的电话面试当然得用英文了。邮件中介绍了电面相关流程，总时长45分钟左右，前5分钟自我介绍下并回答几个简单的 Android 问题，接下来的35分钟就是 coding 了，最后5分钟就是你可以问面试官几个问题。 LeetCode面试FLAG（Facebook、Linkedin、Amazon、Google）这样的外企，数据结构和算法肯定是要过关的，并且可以脱离IDE编写代码，也就是所谓的白板编程，Facebook 是用 CoderPad 在线coding，题目的话着重推荐 LeetCode，所以我推荐把题目拷贝到 CoderPad 上，然后在 CoderPad 上完整地写出AC代码，如果某些APIs不熟悉的话，那就去IDE上面查一下，确保自己写出的代码等同于IDE格式化后的代码。下面附上一首诗。 明有科举八股，今有LeetCode。八股定格式而取文采心意，LeetCode定题目且重答案背诵。美其名曰：”practice makes perfect.”为何今不如古？非也非也，科举为国取士，LeetCode为Google筛码工，各取所需也。 这方面的话，幸好我大学是ACMer，数据结构和算法相关的还是有点底子的，为了方便大家，我在 GitHub 上开了 awesome-java-leetcode，其中包括了 Java 语言的 LeetCode 相关题解，觉得不错的话给个 star 吧。说句题外话，我一直都觉得数据结构和算法是作为一名程序员必须掌握和善于利用的，即便我没这个机会面试 Facebook，我也是照样会去刷 LeetCode 的，今后也会不断更新 LeetCode 题解。 以下是和HR交流之后他发给我的部分面试准备内容。 其中也有提及 LeetCode 相关内容，可见其重要性。 简历面试外企一份英文简历是必不可少的，我花了两天时间做了份 Markdown 通用的简历，利用 Pandoc 可以很方便导出各种格式，至于为什么花了两天，当然是为了之后能分享给你们哈。 之前写过一篇文章：为跳槽的你献计献策（Android） 有很多小伙伴想要查看我的简历，而当时我只提供了模板。如果现在小伙伴们还不清楚怎么写简历或者觉得自己的简历不够完美，那你们可以借鉴我的自己去修改修改，我已把它上传到了 GitHub，这里是传送门，喜欢的话记得 star 哦。 注意点Facebook 更为注重的是团队精神，即便你 coding 水平一流，在面试的时候你声也不吭地敲完了所有代码，即便是 bug-free ，那面试官心里也肯定会想：“wc，老子肯定不希望跟这种人做同事！”。所以coding 的时候要和面试官进行交流哈，不要闷头就敲代码，而是要表现得是在和面试官在一起讨论问题，比如要问清楚数据的边界，你要用什么方式去解决这个问题，时间复杂度，空间复杂度等等，做完之后不要忘了测试用例，当然，最终目的肯定是需要 bug-free 的。 结语以上便是我的面试总结，不论我之后还有没有机肥面试下一轮（Facebook应该是至少四面），我还是会继续巩固数据结构和算法，不断更新我的 awesome-java-leetcode，毕竟面试 Facebook 的机肥年年都有，即使不为 Facebook，这也是我作为程序员应该坚持的，完结，撒花。]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>简历</tag>
        <tag>Facebook</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio升级到3.0 Terminal 中文显示异常]]></title>
    <url>%2F2017%2F10%2F27%2Fupdate-as3-terminal-problem%2F</url>
    <content type="text"><![CDATA[遇到这个问题的话应该是平时终端用的是zsh造成的，如果不是的话，那我也没办法，至少我是这么解决的，希望也可以帮到你。 具体Bug如下所示 内心有一万匹草泥马呼啸而过，捣豉了很久，最终在某群中问了下得到了答案，解决途径如下。 打开~/.zshrc文件，找到如下两行。 12# You may need to manually set your language environment# export LANG=en_US.UTF-8 我们把第二行取消注释即可，保存之后重启AS即可，熟悉的中文又出现在终端中，如下所示。 希望大家可以绕过这个坑。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode题解之Java版(updating)]]></title>
    <url>%2F2017%2F04%2F16%2Fawesome-java-leetcode%2F</url>
    <content type="text"><![CDATA[我如今是一名Android Developer，大学的我曾是一名ACMer，为了不想让算法淡出我的记忆，故重拾LeetCode之Algorithm，语言选择的是Java，题库会一点点完善起来，按简单，中等，困难分类，相应难度下按题号排序，工程代码在project目录中，相关解题都在note目录中，欢迎star。 如今有机会面试Facebook，附上LeetCode上Facebook的面试题目序号，希望可以帮助到以后想入Facebook的小伙伴:-) 123451,10,13,15,17,20,23,25,26,28,33,38,43,44,49,50,56,57,67,68,69,71,75,7678,79,80,85,88,90,91,98,102,117,121,125,127,128,133,139,146,157,158,161168,173,200,206,208,209,210,211,215,218,221,234,235,236,238,252,253,257261,265,269,273,274,275,277,278,282,283,285,286,297,301,311,314,325,334341,377,380,398,404,410,461,477,494,523,525,534,535,543,554 如果想知道更多公司LeetCode面试题，可以参看Companies.md。 Easy # Title Tag 1 Two Sum Array, Hash Table 7 Reverse Integer Math 9 Palindrome Number Math 13 Roman to Integer Math, String 14 Longest Common Prefix String 20 Valid Parentheses Stack, String 21 Merge Two Sorted Lists Linked List 26 Remove Duplicates from Sorted Array Array, Two Pointers 27 Remove Element Array, Two Pointers 28 Implement strStr() Two Pointers, String 35 Search Insert Position String 38 Count and Say String 53 Maximum Subarray Array, Dynamic Programming, Divide and Conquer 58 Length of Last Word String 66 Plus One Array, Math 67 Add Binary Math, String 69 Sqrt(x) Binary Search, Math 70 Climbing Stairs Dynamic Programming 83 Remove Duplicates from Sorted List Linked List 88 Merge Sorted Array Array, Two Pointers 100 Same Tree Tree, Depth-first Search 101 Symmetric Tree Tree, Depth-first Search, Breadth-first Search 104 Maximum Depth of Binary Tree Tree, Depth-first Search 107 Binary Tree Level Order Traversal II Tree, Breadth-first Search 108 Convert Sorted Array to Binary Search Tree Tree, Depth-first Search 110 Balanced Binary Tree Tree, Depth-first Search 111 Minimum Depth of Binary Tree Tree, Depth-first Search, Breadth-first Search 112 Path Sum Tree, Depth-first Search 118 Pascal’s Triangle Array 119 Pascal’s Triangle II Array 121 Best Time to Buy and Sell Stock Array, Dynamic Programmin 122 Best Time to Buy and Sell Stock II Array, Greedy 543 Diameter of Binary Tree Tree Medium # Title Tag 2 Add Two Numbers Linked List, Math 3 Longest Substring Without Repeating Characters Hash Table, Two Pointers, String 8 String to Integer (atoi) Math, String 15 3Sum Array, Two Pointers 17 Letter Combinations of a Phone Number String, Backtracking 19 Remove Nth Node From End of List Linked List, Two Pointers 33 Search in Rotated Sorted Array Arrays, Binary Search 43 Multiply Strings Math, String 49 Group Anagrams Hash Table, String 50 Pow(x, n) Math, Binary Search 56 Merge Intervals Array, Sort 554 Brick Wall Hash Table Hard # Title Tag 4 Median of Two Sorted Arrays Array, Binary Search, Divide and Conquer 10 Regular Expression Matching String, Dynamic Programming, Backtracking 23 Merge k Sorted Lists Linked List, Divide and Conquer, Heap 25 Reverse Nodes in k-Group Linked List 44 Reverse Nodes in k-Group String, Dynamic Programming, Backtracking, Greedy 57 Insert Interval Array, Sort]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 开发规范（完结版）]]></title>
    <url>%2F2017%2F03%2F08%2Fandroid-standard-dev-final%2F</url>
    <content type="text"><![CDATA[摘要 1 前言 2 AS 规范 3 命名规范 4 代码样式规范 5 资源文件规范 6 版本统一规范 7 第三方库规范 8 注释规范 9 测试规范 10 其他的一些规范 1 前言为了有利于项目维护、增强代码可读性、提升 Code Review 效率以及规范团队安卓开发，故提出以下安卓开发规范，该规范结合本人多年的开发经验并吸取多家之精华，可谓是本人的呕心沥血之作，称其为当前最完善的安卓开发规范一点也不为过，如有更好建议，欢迎到 GitHub 提 issue，原文地址：Android 开发规范（完结版）。相关 Demo，可以查看我的 Android 开发工具类集合项目：Android 开发人员不得不收集的代码。后续可能会根据该规范出一个 CheckStyle 插件来检查是否规范，当然也支持在 CI 上运行。 2 AS 规范工欲善其事，必先利其器。 尽量使用最新的稳定版的 IDE 进行开发； 编码格式统一为 UTF-8； 编辑完 .java、.xml 等文件后一定要 格式化，格式化，格式化（如果团队有公共的样式包，那就遵循它，否则统一使用 AS 默认模板即可）； 删除多余的 import，减少警告出现，可利用 AS 的 Optimize Imports（Settings -&gt; Keymap -&gt; Optimize Imports）快捷键； Android 开发者工具可以参考这里：Android 开发者工具； 3 命名规范代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。正确的英文拼写和语法可以让阅读者易于理解，避免歧义。 注意：即使纯拼音命名方式也要避免采用。但 alibaba、taobao、youku、hangzhou 等国际通用的名称，可视同英文。 3.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线，采用反域名命名规则，全部使用小写字母。一级包名是顶级域名，通常为 com、edu、gov、net、org 等，二级包名为公司名，三级包名根据应用进行命名，后面就是对包名的划分了，关于包名的划分，推荐采用 PBF（按功能分包 Package By Feature），一开始我们采用的也是 PBL（按层分包 Package By Layer），很坑爹。PBF 可能不是很好区分在哪个功能中，不过也比 PBL 要好找很多，且 PBF 与 PBL 相比较有如下优势： package 内高内聚，package 间低耦合 哪块要添新功能，只改某一个 package 下的东西。 PBL 降低了代码耦合，但带来了 package 耦合，要添新功能，需要改 model、dbHelper、view、service 等等，需要改动好几个 package 下的代码，改动的地方越多，越容易产生新问题，不是吗？ PBF 的话 featureA 相关的所有东西都在 featureA 包，feature 内高内聚、高度模块化，不同 feature 之间低耦合，相关的东西都放在一起，还好找。 package 有私有作用域（package-private scope） 你负责开发这块功能，这个目录下所有东西都是你的。 PBL 的方式是把所有工具方法都放在 util 包下，小张开发新功能时候发现需要一个 xxUtil，但它又不是通用的，那应该放在哪里？没办法，按照分层原则，我们还得放在 util 包下，好像不太合适，但放在其它包更不合适，功能越来越多，util 类也越定义越多。后来小李负责开发一块功能时发现需要一个 xxUtil，同样不通用，去 util 包一看，怎么已经有了，而且还没法复用，只好放弃 xx 这个名字，改为 xxxUtil……，因为 PBL 的 package 没有私有作用域，每一个包都是 public（跨包方法调用是很平常的事情，每一个包对其它包来说都是可访问的）；如果是 PBF，小张的 xxUtil 自然放在 featureA 下，小李的 xxUtil 在 featureB 下，如果觉得 util 好像是通用的，就去 util 包看看要不要把工具方法添进 xxUtil, class 命名冲突没有了。 PBF 的 package 有私有作用域，featureA 不应该访问 featureB 下的任何东西（如果非访问不可，那就说明接口定义有问题）。 很容易删除功能 统计发现新功能没人用，这个版本那块功能得去掉。 如果是 PBL，得从功能入口到整个业务流程把受到牵连的所有能删的代码和 class 都揪出来删掉，一不小心就完蛋。 如果是 PBF，好说，先删掉对应包，再删掉功能入口（删掉包后入口肯定报错了），完事。 高度抽象 解决问题的一般方法是从抽象到具体，PBF 包名是对功能模块的抽象，包内的 class 是实现细节，符合从抽象到具体，而 PBL 弄反了。 PBF 从确定 AppName 开始，根据功能模块划分 package，再考虑每块的具体实现细节，而 PBL 从一开始就要考虑要不要 dao 层，要不要 com 层等等。 只通过 class 来分离逻辑代码 PBL 既分离 class 又分离 package，而 PBF 只通过 class 来分离逻辑代码。 没有必要通过 package 分离，因为 PBL 中也可能出现尴尬的情况： 12├── service ├── MainService.java 按照 PBL, service 包下的所有东西都是 Service，应该不需要 Service 后缀，但实际上通常为了方便，直接 import service 包，Service 后缀是为了避免引入的 class 和当前包下的 class 命名冲突，当然，不用后缀也可以，得写清楚包路径，比如 new com.domain.service.MainService()，麻烦；而 PBF 就很方便，无需 import，直接 new MainService() 即可。 package 的大小有意义了 PBL 中包的大小无限增长是合理的，因为功能越添越多，而 PBF 中包太大（包里 class 太多）表示这块需要重构（划分子包）。 如要知道更多好处，可以查看这篇博文：Package by features, not layers，当然，我们大谷歌也有相应的 Sample：todo-mvp，其结构如下所示，很值得学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445com└── example └── android └── architecture └── blueprints └── todoapp ├── BasePresenter.java ├── BaseView.java ├── addedittask │ ├── AddEditTaskActivity.java │ ├── AddEditTaskContract.java │ ├── AddEditTaskFragment.java │ └── AddEditTaskPresenter.java ├── data │ ├── Task.java │ └── source │ ├── TasksDataSource.java │ ├── TasksRepository.java │ ├── local │ │ ├── TasksDbHelper.java │ │ ├── TasksLocalDataSource.java │ │ └── TasksPersistenceContract.java │ └── remote │ └── TasksRemoteDataSource.java ├── statistics │ ├── StatisticsActivity.java │ ├── StatisticsContract.java │ ├── StatisticsFragment.java │ └── StatisticsPresenter.java ├── taskdetail │ ├── TaskDetailActivity.java │ ├── TaskDetailContract.java │ ├── TaskDetailFragment.java │ └── TaskDetailPresenter.java ├── tasks │ ├── ScrollChildSwipeRefreshLayout.java │ ├── TasksActivity.java │ ├── TasksContract.java │ ├── TasksFilterType.java │ ├── TasksFragment.java │ └── TasksPresenter.java └── util ├── ActivityUtils.java ├── EspressoIdlingResource.java └── SimpleCountingIdlingResource.java 参考以上的代码结构，按功能分包具体可以这样做： 12345678910111213141516171819202122com└── domain └── app ├── App.java 定义 Application 类 ├── Config.java 定义配置数据（常量） ├── base 基础组件 ├── custom_view 自定义视图 ├── data 数据处理 │ ├── DataManager.java 数据管理器， │ ├── local 来源于本地的数据，比如 SP，Database，File │ ├── model 定义 model（数据结构以及 getter/setter、compareTo、equals 等等，不含复杂操作） │ └── remote 来源于远端的数据 ├── feature 功能 │ ├── feature0 功能 0 │ │ ├── feature0Activity.java │ │ ├── feature0Fragment.java │ │ ├── xxAdapter.java │ │ └── ... 其他 class │ └── ...其他功能 ├── injection 依赖注入 ├── util 工具类 └── widget 小部件 3.2 类名类名都以 UpperCamelCase 风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 名词，采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的， 比如 HTML、URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 Activity 类 Activity 为后缀标识 欢迎页面类 WelcomeActivity Adapter 类 Adapter 为后缀标识 新闻详情适配器 NewsDetailAdapter 解析类 Parser 为后缀标识 首页解析类 HomePosterParser 工具方法类 Utils 或 Manager 为后缀标识 线程池管理类：ThreadPoolManager日志工具类：LogUtils（Logger 也可）打印工具类：PrinterUtils 数据库类 以 DBHelper 后缀标识 新闻数据库：NewsDBHelper Service 类 以 Service 为后缀标识 时间服务 TimeService BroadcastReceiver 类 以 Receiver 为后缀标识 推送接收 JPushReceiver ContentProvider 类 以 Provider 为后缀标识 ShareProvider 自定义的共享基础类 以 Base 开头 BaseActivity, BaseFragment 测试类的命名以它要测试的类的名称开始，以 Test 结束。例如：HashTest 或 HashIntegrationTest。 接口（interface）：命名规则与类一样采用大驼峰命名法，多以 able 或 ible 结尾，如 interface Runnable、interface Accessible。 注意：如果项目采用 MVP，所有 Model、View、Presenter 的接口都以 I 为前缀，不加后缀，其他的接口采用上述命名规则。 3.3 方法名方法名都以 lowerCamelCase 风格编写。 方法名通常是动词或动词短语。 方法 说明 initXX() 初始化相关方法，使用 init 为前缀标识，如初始化布局 initView() isXX(), checkXX() 方法返回值为 boolean 型的请使用 is/check 为前缀标识 getXX() 返回某个值的方法，使用 get 为前缀标识 setXX() 设置某个属性值 handleXX(), processXX() 对数据进行处理的方法 displayXX(), showXX() 弹出提示框和提示信息，使用 display/show 为前缀标识 updateXX() 更新数据 saveXX(), insertXX() 保存或插入数据 resetXX() 重置数据 clearXX() 清除数据 removeXX(), deleteXX() 移除数据或者视图等，如 removeView() drawXX() 绘制数据或效果相关的，使用 draw 前缀标识 3.4 常量名常量名命名模式为 CONSTANT_CASE，全部字母大写，用下划线分隔单词。那到底什么算是一个常量？ 每个常量都是一个 static final 字段，但不是所有 static final 字段都是常量。在决定一个字段是否是一个常量时，得考虑它是否真的感觉像是一个常量。例如，如果观测任何一个该实例的状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变的对象一般是不够的，它要真的一直不变才能将它示为常量。 1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableListNAMES = ImmutableList.of("Ed", "Ann");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final SetmutableCollection = new HashSet();static final ImmutableSetmutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these", "can", "change"&#125;; 3.5 非常量字段名非常量字段名以 lowerCamelCase 风格的基础上改造为如下风格：基本结构为 scope{Type0}VariableName{Type1}、type0VariableName{Type1}、variableName{Type1}。 说明：{} 中的内容为可选。 注意：所有的 VO（值对象）统一采用标准的 lowerCamelCase 风格编写，所有的 DTO（数据传输对象）就按照接口文档中定义的字段名编写。 3.5.1 scope（范围）非公有，非静态字段命名以 m 开头。 静态字段命名以 s 开头。 其他字段以小写字母开头。 例如： 1234567public class MyClass &#123; public int publicField; private static MyClass sSingleton; int mPackagePrivate; private int mPrivate; protected int mProtected;&#125; 使用 1 个字符前缀来表示作用范围，1 个字符的前缀必须小写，前缀后面是由表意性强的一个单词或多个单词组成的名字，而且每个单词的首写字母大写，其它字母小写，这样保证了对变量名能够进行正确的断句。 3.5.2 Type0（控件类型）考虑到 Android 众多的 UI 控件，为避免控件和普通成员变量混淆以及更好地表达意思，所有用来表示控件的成员变量统一加上控件缩写作为前缀（具体见附录UI 控件缩写表）。 例如：mIvAvatar、rvBooks、flContainer。 3.5.3 VariableName（变量名）变量名中可能会出现量词，我们需要创建统一的量词，它们更容易理解，也更容易搜索。 例如：mFirstBook、mPreBook、curBook。 量词列表 量词后缀说明 First 一组变量中的第一个 Last 一组变量中的最后一个 Next 一组变量中的下一个 Pre 一组变量中的上一个 Cur 一组变量中的当前变量 3.5.4 Type1（数据类型）对于表示集合或者数组的非常量字段名，我们可以添加后缀来增强字段的可读性，比如： 集合添加如下后缀：List、Map、Set。 数组添加如下后缀：Arr。 例如：mIvAvatarList、userArr、firstNameSet。 注意：如果数据类型不确定的话，比如表示的是很多书，那么使用其复数形式来表示也可，例如 mBooks。 3.6 参数名参数名以 lowerCamelCase 风格编写，参数应该避免用单个字符命名。 3.7 局部变量名局部变量名以 lowerCamelCase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是 final 和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 3.8 临时变量临时变量通常被取名为 i、j、k、m 和 n，它们一般用于整型；c、d、e，它们一般用于字符型。 如：for (int i = 0; i &lt; len; i++)。 3.9 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字（如：E, T, X, T2）。 以类命名方式（参考3.2 类名），后面加个大写的 T（如：RequestT, FooBarT）。 更多还可参考：阿里巴巴 Java 开发手册 4 代码样式规范4.1 使用标准大括号样式左大括号不单独占一行，与其前面的代码位于同一行： 1234567891011class MyClass &#123; int func() &#123; if (something) &#123; // ... &#125; else if (somethingElse) &#123; // ... &#125; else &#123; // ... &#125; &#125;&#125; 我们需要在条件语句周围添加大括号。例外情况：如果整个条件语句（条件和主体）适合放在同一行，那么您可以（但不是必须）将其全部放在一行上。例如，我们接受以下样式： 123if (condition) &#123; body();&#125; 同样也接受以下样式： 1if (condition) body(); 但不接受以下样式： 12if (condition) body(); // bad! 4.2 编写简短方法在可行的情况下，尽量编写短小精炼的方法。我们了解，有些情况下较长的方法是恰当的，因此对方法的代码长度没有做出硬性限制。如果某个方法的代码超出 40 行，请考虑是否可以在不破坏程序结构的前提下对其拆解。 4.3 类成员的顺序这并没有唯一的正确解决方案，但如果都使用一致的顺序将会提高代码的可读性，推荐使用如下排序： 常量 字段 构造函数 重写函数和回调 公有函数 私有函数 内部类或接口 例如： 123456789101112131415161718192021222324public class MainActivity extends Activity &#123; private static final String TAG = MainActivity.class.getSimpleName(); private String mTitle; private TextView mTextViewTitle; @Override public void onCreate() &#123; ... &#125; public void setTitle(String title) &#123; mTitle = title; &#125; private void setUpView() &#123; ... &#125; static class AnInnerClass &#123; &#125;&#125; 如果类继承于 Android 组件（例如 Activity 或 Fragment），那么把重写函数按照他们的生命周期进行排序是一个非常好的习惯，例如，Activity 实现了 onCreate()、onDestroy()、onPause()、onResume()，它的正确排序如下所示： 1234567891011121314public class MainActivity extends Activity &#123; //Order matches Activity lifecycle @Override public void onCreate() &#123;&#125; @Override public void onResume() &#123;&#125; @Override public void onPause() &#123;&#125; @Override public void onDestroy() &#123;&#125;&#125; 4.4 函数参数的排序在 Android 开发过程中，Context 在函数参数中是再常见不过的了，我们最好把 Context 作为其第一个参数。 正相反，我们把回调接口应该作为其最后一个参数。 例如： 12345// Context always goes firstpublic User loadUser(Context context, int userId);// Callbacks always go lastpublic void loadUserAsync(Context context, int userId, UserCallback callback); 4.5 字符串常量的命名和值Android SDK 中的很多类都用到了键值对函数，比如SharedPreferences、Bundle、Intent，所以，即便是一个小应用，我们最终也不得不编写大量的字符串常量。 当时用到这些类的时候，我们 必须 将它们的键定义为 static final 字段，并遵循以下指示作为前缀。 类 字段名前缀 SharedPreferences PREF_ Bundle BUNDLE_ Fragment Arguments ARGUMENT_ Intent Extra EXTRA_ Intent Action ACTION_ 说明：虽然 Fragment.getArguments() 得到的也是 Bundle ，但因为这是 Bundle 的常用用法，所以特意为此定义一个不同的前缀。 例如： 12345678// 注意：字段的值与名称相同以避免重复问题static final String PREF_EMAIL = "PREF_EMAIL";static final String BUNDLE_AGE = "BUNDLE_AGE";static final String ARGUMENT_USER_ID = "ARGUMENT_USER_ID";// 与意图相关的项使用完整的包名作为值的前缀static final String EXTRA_SURNAME = "com.myapp.extras.EXTRA_SURNAME";static final String ACTION_OPEN_USER = "com.myapp.action.ACTION_OPEN_USER"; 4.6 Activities 和 Fragments 的传参当 Activity 或 Fragment 传递数据通过 Intent 或 Bundle 时，不同值的键须遵循上一条所提及到的。 当 Activity 或 Fragment 启动需要传递参数时，那么它需要提供一个 public static 的函数来帮助启动或创建它。 这方面，AS 已帮你写好了相关的 Live Templates，启动相关 Activity 的只需要在其内部输入 starter 即可生成它的启动器，如下所示： 12345public static void start(Context context, User user) &#123; Intent starter = new Intent(context, MainActivity.class); starter.putParcelableExtra(EXTRA_USER, user); context.startActivity(starter);&#125; 同理，启动相关 Fragment 在其内部输入 newInstance 即可，如下所示： 1234567public static MainFragment newInstance(User user) &#123; Bundle args = new Bundle(); args.putParcelable(ARGUMENT_USER, user); MainFragment fragment = new MainFragment(); fragment.setArguments(args); return fragment;&#125; 注意：这些函数需要放在 onCreate() 之前的类的顶部；如果我们使用了这种方式，那么 extras 和 arguments 的键应该是 private 的，因为它们不再需要暴露给其他类来使用。 4.7 行长限制代码中每一行文本的长度都应该不超过 100 个字符。虽然关于此规则存在很多争论，但最终决定仍是以 100 个字符为上限，如果行长超过了 100（AS 窗口右侧的竖线就是设置的行宽末尾 ），我们通常有两种方法来缩减行长。 提取一个局部变量或方法（最好）。 使用换行符将一行换成多行。 不过存在以下例外情况： 如果备注行包含长度超过 100 个字符的示例命令或文字网址，那么为了便于剪切和粘贴，该行可以超过 100 个字符。 导入语句行可以超出此限制，因为用户很少会看到它们（这也简化了工具编写流程）。 4.7.1 换行策略这没有一个准确的解决方案来决定如何换行，通常不同的解决方案都是有效的，但是有一些规则可以应用于常见的情况。 4.7.1.1 操作符的换行除赋值操作符之外，我们把换行符放在操作符之前，例如： 12int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 赋值操作符的换行我们放在其后，例如： 12int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 4.7.1.2 函数链的换行当同一行中调用多个函数时（比如使用构建器时），对每个函数的调用应该在新的一行中，我们把换行符插入在 . 之前。 例如： 1Picasso.with(context).load("https://blankj.com/images/avatar.jpg").into(ivAvatar); 我们应该使用如下规则： 123Picasso.with(context) .load("https://blankj.com/images/avatar.jpg") .into(ivAvatar); 4.7.1.3 多参数的换行当一个方法有很多参数或者参数很长的时候，我们应该在每个 , 后面进行换行。 比如： 1loadPicture(context, "https://blankj.com/images/avatar.jpg", ivAvatar, "Avatar of the user", clickListener); 我们应该使用如下规则： 12345loadPicture(context, "https://blankj.com/images/avatar.jpg", ivAvatar, "Avatar of the user", clickListener); 4.7.1.4 RxJava 链式的换行RxJava 的每个操作符都需要换新行，并且把换行符插入在 . 之前。 例如： 123456789101112131415public Observable&lt;Location&gt; syncLocations() &#123; return mDatabaseHelper.getAllLocations() .concatMap(new Func1&lt;Location, Observable&lt;? extends Location&gt;&gt;() &#123; @Override public Observable&lt;? extends Location&gt; call(Location location) &#123; return mRetrofitService.getLocation(location.id); &#125; &#125;) .retry(new Func2&lt;Integer, Throwable, Boolean&gt;() &#123; @Override public Boolean call(Integer numRetries, Throwable throwable) &#123; return throwable instanceof RetrofitError; &#125; &#125;);&#125; 5 资源文件规范资源文件命名为全部小写，采用下划线命名法。 如果想对资源文件进行分包可以参考我这篇文章：Android Studio 下对资源进行分包。 5.1 动画资源文件（anim/ 和 animator/）安卓主要包含属性动画和视图动画，其视图动画包括补间动画和逐帧动画。属性动画文件需要放在 res/animator/ 目录下，视图动画文件需放在 res/anim/ 目录下。 命名规则：{模块名_}逻辑名称。 说明：{} 中的内容为可选，逻辑名称 可由多个单词加下划线组成。 例如：refresh_progress.xml、market_cart_add.xml、market_cart_remove.xml。 如果是普通的补间动画或者属性动画，可采用：动画类型_方向 的命名方式。 例如： 名称 说明 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小 5.2 颜色资源文件（color/）专门存放颜色相关的资源文件。 命名规则：类型_逻辑名称。 例如：sel_btn_font.xml。 颜色资源也可以放于 res/drawable/ 目录，引用时则用 @drawable 来引用，但不推荐这么做，最好还是把两者分开。 5.3 图片资源文件（drawable/ 和 mipmap/）res/drawable/ 目录下放的是位图文件（.png、.9.png、.jpg、.gif）或编译为可绘制对象资源子类型的 XML 文件，而 res/mipmap/ 目录下放的是不同密度的启动图标，所以 res/mipmap/ 只用于存放启动图标，其余图片资源文件都应该放到 res/drawable/ 目录下。 命名规则：类型{_模块名}_逻辑名称、类型{_模块名}_颜色。 说明：{} 中的内容为可选；类型 可以是可绘制对象资源类型，也可以是控件类型（具体见附录UI 控件缩写表）；最后可加后缀 _small 表示小图，_big 表示大图。 例如： 名称 说明 btn_main_about.png 主页关于按键 类型_模块名_逻辑名称 btn_back.png 返回按键 类型_逻辑名称 divider_maket_white.png 商城白色分割线 类型_模块名_颜色 ic_edit.png 编辑图标 类型_逻辑名称 bg_main.png 主页背景 类型_逻辑名称 btn_red.png 红色按键 类型_颜色 btn_red_big.png 红色大按键 类型_颜色 ic_head_small.png 小头像图标 类型_逻辑名称 bg_input.png 输入框背景 类型_逻辑名称 divider_white.png 白色分割线 类型_颜色 bg_main_head.png 主页头部背景 类型_模块名_逻辑名称 def_search_cell.png 搜索页面默认单元图片 类型_模块名_逻辑名称 ic_more_help.png 更多帮助图标 类型_逻辑名称 divider_list_line.png 列表分割线 类型_逻辑名称 sel_search_ok.xml 搜索界面确认选择器 类型_模块名_逻辑名称 shape_music_ring.xml 音乐界面环形形状 类型_模块名_逻辑名称 如果有多种形态，如按钮选择器：sel_btn_xx.xml，采用如下命名： 名称 说明 sel_btn_xx 作用在 btn_xx 上的 selector btn_xx_normal 默认状态效果 btn_xx_pressed state_pressed 点击效果 btn_xx_focused state_focused 聚焦效果 btn_xx_disabled state_enabled 不可用效果 btn_xx_checked state_checked 选中效果 btn_xx_selected state_selected 选中效果 btn_xx_hovered state_hovered 悬停效果 btn_xx_checkable state_checkable 可选效果 btn_xx_activated state_activated 激活效果 btn_xx_window_focused state_window_focused 窗口聚焦效果 注意：使用 Android Studio 的插件 SelectorChapek 可以快速生成 selector，前提是命名要规范。 5.4 布局资源文件（layout/）命名规则：类型_模块名、类型{_模块名}_逻辑名称。 说明：{} 中的内容为可选。 例如： 名称 说明 activity_main.xml 主窗体 类型_模块名 activity_main_head.xml 主窗体头部 类型_模块名_逻辑名称 fragment_music.xml 音乐片段 类型_模块名 fragment_music_player.xml 音乐片段的播放器 类型_模块名_逻辑名称 dialog_loading.xml 加载对话框 类型_逻辑名称 ppw_info.xml 信息弹窗（PopupWindow） 类型_逻辑名称 item_main_song.xml 主页歌曲列表项 类型_模块名_逻辑名称 5.5 菜单资源文件（menu/）菜单相关的资源文件应放在该目录下。 命名规则：{模块名_}逻辑名称 说明：{} 中的内容为可选。 例如：main_drawer.xml、navigation.xml。 5.6 values 资源文件（values/）values/ 资源文件下的文件都以 s 结尾，如 attrs.xml、colors.xml、dimens.xml，起作用的不是文件名称，而是 &lt;resources&gt; 标签下的各种标签，比如 &lt;style&gt; 决定样式，&lt;color&gt; 决定颜色，所以，可以把一个大的 xml 文件分割成多个小的文件，比如可以有多个 style 文件，如 styles.xml、styles_home.xml、styles_item_details.xml、styles_forms.xml。 5.6.1 colors.xml&lt;color&gt; 的 name 命名使用下划线命名法，在你的 colors.xml 文件中应该只是映射颜色的名称一个 ARGB 值，而没有其它的。不要使用它为不同的按钮来定义 ARGB 值。 例如，不要像下面这样做： 123456789&lt;resources&gt; &lt;color name="button_foreground"&gt;#FFFFFF&lt;/color&gt; &lt;color name="button_background"&gt;#2A91BD&lt;/color&gt; &lt;color name="comment_background_inactive"&gt;#5F5F5F&lt;/color&gt; &lt;color name="comment_background_active"&gt;#939393&lt;/color&gt; &lt;color name="comment_foreground"&gt;#FFFFFF&lt;/color&gt; &lt;color name="comment_foreground_important"&gt;#FF9D2F&lt;/color&gt; ... &lt;color name="comment_shadow"&gt;#323232&lt;/color&gt; 使用这种格式，会非常容易重复定义 ARGB 值，而且如果应用要改变基色的话会非常困难。同时，这些定义是跟一些环境关联起来的，如 button 或者 comment，应该放到一个按钮风格中，而不是在 colors.xml 文件中。 相反，应该这样做： 12345678910111213141516&lt;resources&gt; &lt;!-- grayscale --&gt; &lt;color name="white" &gt;#FFFFFF&lt;/color&gt; &lt;color name="gray_light"&gt;#DBDBDB&lt;/color&gt; &lt;color name="gray" &gt;#939393&lt;/color&gt; &lt;color name="gray_dark" &gt;#5F5F5F&lt;/color&gt; &lt;color name="black" &gt;#323232&lt;/color&gt; &lt;!-- basic colors --&gt; &lt;color name="green"&gt;#27D34D&lt;/color&gt; &lt;color name="blue"&gt;#2A91BD&lt;/color&gt; &lt;color name="orange"&gt;#FF9D2F&lt;/color&gt; &lt;color name="red"&gt;#FF432F&lt;/color&gt;&lt;/resources&gt; 向应用设计者那里要这个调色板，名称不需要跟 &quot;green&quot;、&quot;blue&quot; 等等相同。&quot;brand_primary&quot;、&quot;brand_secondary&quot;、&quot;brand_negative&quot; 这样的名字也是完全可以接受的。像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。通常一个具有审美价值的 UI 来说，减少使用颜色的种类是非常重要的。 注意：如果某些颜色和主题有关，那就单独写一个 colors_theme.xml。 5.6.2 dimens.xml像对待 colors.xml 一样对待 dimens.xml 文件，与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。 一个好的例子，如下所示： 123456789101112131415161718192021&lt;resources&gt; &lt;!-- font sizes --&gt; &lt;dimen name="font_22"&gt;22sp&lt;/dimen&gt; &lt;dimen name="font_18"&gt;18sp&lt;/dimen&gt; &lt;dimen name="font_15"&gt;15sp&lt;/dimen&gt; &lt;dimen name="font_12"&gt;12sp&lt;/dimen&gt; &lt;!-- typical spacing between two views --&gt; &lt;dimen name="spacing_40"&gt;40dp&lt;/dimen&gt; &lt;dimen name="spacing_24"&gt;24dp&lt;/dimen&gt; &lt;dimen name="spacing_14"&gt;14dp&lt;/dimen&gt; &lt;dimen name="spacing_10"&gt;10dp&lt;/dimen&gt; &lt;dimen name="spacing_4"&gt;4dp&lt;/dimen&gt; &lt;!-- typical sizes of views --&gt; &lt;dimen name="button_height_60"&gt;60dp&lt;/dimen&gt; &lt;dimen name="button_height_40"&gt;40dp&lt;/dimen&gt; &lt;dimen name="button_height_32"&gt;32dp&lt;/dimen&gt;&lt;/resources&gt; 布局时在写 margins 和 paddings 时，你应该使用 spacing_xx 尺寸格式来布局，而不是像对待 string 字符串一样直接写值，像这样规范的尺寸很容易修改或重构，会使应用所有用到的尺寸一目了然。 这样写会非常有感觉，会使组织和改变风格或布局非常容易。 5.6.3 strings.xml&lt;string&gt; 的 name 命名使用下划线命名法，采用以下规则：{模块名_}逻辑名称，这样方便同一个界面的所有 string 都放到一起，方便查找。 名称 说明 main_menu_about 主菜单按键文字 friend_title 好友模块标题栏 friend_dialog_del 好友删除提示 login_check_email 登录验证 dialog_title 弹出框标题 button_ok 确认键 loading 加载文字 5.6.4 styles.xml&lt;style&gt; 的 name 命名使用大驼峰命名法，几乎每个项目都需要适当的使用 styles.xml 文件，因为对于一个视图来说，有一个重复的外观是很常见的，将所有的外观细节属性（colors、padding、font）放在 styles.xml 文件中。 在应用中对于大多数文本内容，最起码你应该有一个通用的 styles.xml 文件，例如： 1234&lt;style name=&quot;ContentText&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;@dimen/font_normal&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@color/basic_black&lt;/item&gt;&lt;/style&gt; 应用到 TextView 中： 123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/price&quot; style=&quot;@style/ContentText&quot; /&gt; 或许你需要为按钮控件做同样的事情，不要停止在那里，将一组相关的和重复 android:xxxx 的属性放到一个通用的 &lt;style&gt; 中。 5.7 id 命名命名规则：view缩写{_模块名}_逻辑名，例如： btn_main_search、btn_back。 如果在项目中有用黄油刀的话，使用 AS 的插件：ButterKnife Zelezny，可以非常方便帮助你生成注解；没用黄油刀的话可以使用 Android Code Generator 插件。 6 版本统一规范Android 开发存在着众多版本的不同，比如 compileSdkVersion、minSdkVersion、targetSdkVersion 以及项目中依赖第三方库的版本，不同的 module 及不同的开发人员都有不同的版本，所以需要一个统一版本规范的文件。 具体可以参考我写的这篇博文：Android 开发之版本统一规范。 如果是开发多个系统级别的应用，当多个应用同时用到相同的 so 库时，一定要确保 so 库的版本一致，否则可能会引发应用崩溃。 7 第三方库规范别再闭门造车了，用用最新最火的技术吧，安利一波：Android 流行框架查速表，顺便带上自己的干货：Android 开发人员不得不收集的代码。 希望 Team 能用时下较新的技术，对开源库的选取，一般都需要选择比较稳定的版本，作者在维护的项目，要考虑作者对 issue 的解决，以及开发者的知名度等各方面。选取之后，一定的封装是必要的。 个人推荐 Team 可使用如下优秀轮子： Retrofit RxAndroid OkHttp Glide/Fresco Gson/Fastjson EventBus/AndroidEventBus GreenDao Dagger2（选用） Tinker（选用） 8 注释规范为了减少他人阅读你代码的痛苦值，请在关键地方做好注释。 8.1 类注释每个类完成后应该有作者姓名和联系方式的注释，对自己的代码负责。 123456789101112/** * &lt;pre&gt; * author : Blankj * e-mail : xxx@xx * time : 2017/03/07 * desc : xxxx 描述 * version: 1.0 * &lt;/pre&gt; */public class WelcomeActivity &#123; ...&#125; 具体可以在 AS 中自己配制，进入 Settings -&gt; Editor -&gt; File and Code Templates -&gt; Includes -&gt; File Header，输入 123456789/** * &lt;pre&gt; * author : $&#123;USER&#125; * e-mail : xxx@xx * time : $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125; * desc : * version: 1.0 * &lt;/pre&gt; */ 这样便可在每次新建类的时候自动加上该头注释。 8.2 方法注释每一个成员方法（包括自定义成员方法、覆盖方法、属性方法）的方法头都必须做方法头注释，在方法前一行输入 /** + 回车 或者设置 Fix doc comment（Settings -&gt; Keymap -&gt; Fix doc comment）快捷键，AS 便会帮你生成模板，我们只需要补全参数即可，如下所示。 12345678910111213/** * bitmap 转 byteArr * * @param bitmap bitmap 对象 * @param format 格式 * @return 字节数组 */public static byte[] bitmap2Bytes(Bitmap bitmap, CompressFormat format) &#123; if (bitmap == null) return null; ByteArrayOutputStream baos = new ByteArrayOutputStream(); bitmap.compress(format, 100, baos); return baos.toByteArray();&#125; 8.3 块注释块注释与其周围的代码在同一缩进级别。它们可以是 /* ... */ 风格，也可以是 // ... 风格（//后最好带一个空格）。对于多行的 /* ... */ 注释，后续行必须从 * 开始， 并且与前一行的 * 对齐。以下示例注释都是 OK 的。 12345678910/* * This is * okay. */// And so// is this./* Or you can* even do this. */ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行（即注释像段落风格一样），那么使用 /* ... */。 8.4 其他一些注释AS 已帮你集成了一些注释模板，我们只需要直接使用即可，在代码中输入 todo、fixme 等这些注释模板，回车后便会出现如下注释。 12// TODO: 17/3/14 需要实现，但目前还未实现的功能的说明// FIXME: 17/3/14 需要修正，甚至代码是错误的，不能工作，需要修复的说明 9 测试规范业务开发完成之后，开发人员做单元测试，单元测试完成之后，保证单元测试全部通过，同时单元测试代码覆盖率达到一定程度（这个需要开发和测试约定，理论上越高越好），开发提测。 9.1 单元测试测试类的名称应该是所测试类的名称加 Test，我们创建 DatabaseHelper 的测试类，其名应该叫 DatabaseHelperTest。 测试函数被 @Test 所注解，函数名通常以被测试的方法为前缀，然后跟随是前提条件和预期的结果。 模板：void methodName前提条件和预期结果() 例子：void signInWithEmptyEmailFails() 注意：如果函数足够清晰，那么前提条件和预期的结果是可以省略的。 有时一个类可能包含大量的方法，同时需要对每个方法进行几次测试。在这种情况下，建议将测试类分成多个类。例如，如果 DataManager 包含很多方法，我们可能要把它分成 DataManagerSignInTest、DataManagerLoadUsersTest 等等。 9.2 Espresso 测试每个 Espresso 测试通常是针对 Activity，所以其测试名就是其被测的 Activity 的名称加 Test，比如 SignInActivityTest。 10 其他的一些规范 合理布局，有效运用 &lt;merge&gt;、&lt;ViewStub&gt;、&lt;include&gt; 标签； Activity 和 Fragment 里面有许多重复的操作以及操作步骤，所以我们都需要提供一个 BaseActivity 和 BaseFragment，让所有的 Activity 和 Fragment 都继承这个基类。 方法基本上都按照调用的先后顺序在各自区块中排列； 相关功能作为小区块放在一起（或者封装掉）； 当一个类有多个构造函数，或是多个同名函数，这些函数应该按顺序出现在一起，中间不要放进其它函数； 数据提供统一的入口。无论是在 MVP、MVC 还是 MVVM 中，提供一个统一的数据入口，都可以让代码变得更加易于维护。比如可使用一个 DataManager，把 http、preference、eventpost、database 都放在 DataManager 里面进行操作，我们只需要与 DataManager打交道； 多用组合，少用继承； 提取方法，去除重复代码。对于必要的工具类抽取也很重要，这在以后的项目中是可以重用的。 可引入 Dagger2 减少模块之间的耦合性。Dagger2 是一个依赖注入框架，使用代码自动生成创建依赖关系需要的代码。减少很多模板化的代码，更易于测试，降低耦合，创建可复用可互换的模块； 项目引入 RxAndroid 响应式编程，可以极大的减少逻辑代码； 通过引入事件总线，如：EventBus、AndroidEventBus、RxBus，它允许我们在 DataLayer 中发送事件，以便 ViewLayer 中的多个组件都能够订阅到这些事件，减少回调； 尽可能使用局部变量； 及时关闭流； 尽量减少对变量的重复计算； 如下面的操作： 123for (int i = 0; i &lt; list.size(); i++) &#123; ...&#125; 建议替换为： 123for (int i = 0, len = list.size(); i &lt; len; i++) &#123; ...&#125; 尽量采用懒加载的策略，即在需要的时候才创建； 例如： 1234String str = "aaa";if (i == 1) &#123; list.add(str);&#125; 建议替换为： 1234if (i == 1) &#123; String str = "aaa"; list.add(str);&#125; 不要在循环中使用 try…catch…，应该把其放在最外层； 使用带缓冲的输入输出流进行 IO 操作； 尽量使用 HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用 HashTable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销； 尽量在合适的场合使用单例； 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： 控制资源的使用，通过线程同步来控制资源的并发访问。 控制实例的产生，以达到节约资源的目的。 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。 把一个基本数据类型转为字符串，基本数据类型.toString() 是最快的方式，String.valueOf(数据) 次之，数据 + &quot;&quot; 最慢； 使用 AS 自带的 Lint 来优化代码结构（什么，你不会？右键 module、目录或者文件，选择 Analyze -&gt; Inspect Code）； 最后不要忘了内存泄漏的检测； 最后啰嗦几句： 好的命名规则能够提高代码质量，使得新人加入项目的时候降低理解代码的难度； 规矩终究是死的，适合团队的才是最好的； 命名规范需要团队一起齐心协力来维护执行，在团队生活里，谁都不可能独善其身； 一开始可能会有些不习惯，持之以恒，总会成功的。 附录UI 控件缩写表 名称 缩写 Button btn CheckBox cb EditText et FrameLayout fl GridView gv ImageButton ib ImageView iv LinearLayout ll ListView lv ProgressBar pb RadioButton rb RecyclerView rv RelativeLayout rl ScrollView sv SeekBar sb Spinner spn TextView tv ToggleButton tb VideoView vv WebView wv 常见的英文单词缩写表 名称 缩写 average avg background bg（主要用于布局和子布局的背景） buffer buf control ctrl current cur default def delete del document doc error err escape esc icon ic（主要用在 App 的图标） increment inc information info initial init image img Internationalization I18N length len library lib message msg password pwd position pos previous pre selector sel（主要用于某一 view 多种状态，不仅包括 ListView 中的 selector，还包括按钮的 selector） server srv string str temporary tmp window win 程序中使用单词缩写原则：不要用缩写，除非该缩写是约定俗成的。 参考Android 包命名规范 Android 开发最佳实践 Android 编码规范 阿里巴巴 Java 开发手册 Project and code style guidelines Google Java 编程风格指南 小细节，大用途，35 个 Java 代码性能优化总结！ 版本日志 17/12/05: 新增 logo； 17/12/04: 完善按功能分包，修复 typo，定该版为完结版； 17/12/03: 完善代码样式规范和测试规范； 17/12/02: 新增代码样式规范； 17/12/01: 对资源文件规范进行重构； 17/11/29: 格式化中英混排； 17/03/14: 包名划分为按功能划分； 17/03/13: 新增其他注释； 17/03/08: 规范排版，修复 typo 及新增一些规范； 17/03/07: 修订目录排版，完善某些细节； 17/03/06: 发布初版；]]></content>
      <categories>
        <category>Android</category>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为跳槽的你献计献策（Android）]]></title>
    <url>%2F2017%2F02%2F16%2Ffind-job%2F</url>
    <content type="text"><![CDATA[背景首先先介绍下我的境况吧，上周一提交的辞职报告，周二正式离开了我的EX公司，也就是裸辞吧，毕竟我还没有收到任何面试通知和offer，但是我在上周一之前已把简历写好，并在相关的平台投出了多份简历，只欠东风了。当然，裸辞也有裸辞的好处（什么，裸辞还有好处？），裸辞状态下你可以更全面地准备知识，到新公司面试的时候如果是离职状态的话，一般新公司也更喜欢离职的员工，因为可以更快地入职，从而成功跳槽。互联网简历平台我还是比较推荐 拉勾网 的，就互联网简历推送平台对比而言，我对某联和某同城印象还是不怎么好的，记得刚找工作那会，收到某些培训机构的面试通知，唉，浪费时间真是。当然，你身边有内推渠道的话，千万不要浪费了这机会哈，一定要全面运用身边的资源，既然说到了简历，那就谈谈它吧。 简历作为ITer，要时刻记得 GitHub 这个平台，它不仅可以解决你的技术难题，当然也有你想不到的简历轮子，献上 传送门~ 拿好，别掉了哈。链接是Android版本的，当然其他方向版本也都是有的哈，见如下截图。 该说的基本都在传送门里面了，在此再推荐一个Trinea大大的 80% 以上简历都是不合格的，我用的简历模板就是他提供的模板一：传送门~。 我提一下需要着重注意的几点吧。 曾经公司负责的项目职责，如果有战绩显赫的那一定要突出对公司带来的收益什么的，没有的话，那就写一下对你自身的成长。 罗列出自己比较了解的技术点，千万不要写一些自己都不清楚的知识，那样面试官一旦考到你，那你就GG吧。（什么，你没有比较了解的，那你赶紧去升下级吧，可以参看我下方写的干货） 最好有自己设计的开源库或者技术博客，那样你在介绍的时候就游刃有余了，可以说说你设计的思想，带来的好处等等。 面试干货在简历通过筛选之后，总算是有了面试机会，面试之前准备的话，对于我们这种初中及开发者，这个 传送门~ 中的内容已经足以和技术面试官怼一战了。 你总算承受住了技术面试官的压力，下面就是你发问的时刻了，哈哈，我这里也给你们提供一些问题模板哈。 我所应聘的这个职位为何会出现空缺（一般的话会有三点，1、公司扩招：如果是这个原因那就是公司在迅速发展，遇到这样的公司还是不错的；2、原人才升职：那你接着便可以套出如何升职；3、原人才跳槽：这个因素的话那你就得好好衡量了，是否要为这虎穴买单） 试用期内可能遇到最大的困难挑战是什么（这个是很有必要问清楚的，毕竟关系着你将来可能要面对的困难） 如何评估试用期内的工作表现（这个问题可以了解到该家公司的办公做事风格，也决定了你的工作状态要达到什么程度） 贵公司是如何保证人才的不流失（优秀的企业一般都为员工提供清晰明了的职业发展道路，在员工能力增长的同时，也为公司带来价值，这也会让面试官觉得你是一个对公司和对自己都负责的面试者） 之后的话可能就是和HR和高管的面试了，这个的话就看你发挥了，讨论薪资的话也不要不好意思说出口，如果你真的很喜欢那家公司的话，那即使低于你的期望，你应该也是可以接受的，如果真的不知道开多少的话，你可以委婉点表达，说想要得到贵公司该职位的正常薪水多百分之十到百分之三十，具体后面的值就看你面试发挥和个人能力了，一般公司对一个职位薪水都有一个幅度的，也就是那个范围之间。具体其他的那就是你自己问了哈，比如试用期时长，是否双休，五险一金等，但千万不要什么琐碎都问，比如通讯费、全勤奖金、生日津贴等，这样反而会扣你的印象分。 你以为到这基本已经完结了，那你就错了，是不经常有小伙伴碰到“回去等我们通知吧”，然而苦苦久等都没有答复。我在临走前都会对HR或者面试官说，无论结果如何，请贵公司尽快给予我答复。 好了，说了这么多，柯基希望你们都能找到如意的工作，跳槽成功，迎娶白富美，走上人生巅峰。]]></content>
      <categories>
        <category>Android</category>
        <category>跳槽</category>
      </categories>
      <tags>
        <tag>跳槽</tag>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神注释大全（欢迎补充）]]></title>
    <url>%2F2017%2F01%2F11%2Fawesome-comment%2F</url>
    <content type="text"><![CDATA[awesome-comment欢迎提交issue来完善这个神级注释 写在前面的话：一时兴起就收集了以下神注释，希望能为广大ITer带来快乐，缓解你们工作中的压力，下面开车，先自爆头像，下文会给出制作链接。 123456789101112131415161718192021222324252627282930313233343536/** * 瓦瓦 十 * 十齱龠己 亅瓦車己 * 乙龍龠毋日丶 丶乙己毋毋丶 * 十龠馬鬼車瓦 己十瓦毋毋 * 鬼馬龠馬龠十 己己毋車毋瓦 * 毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己 * 乙龠龍龍鬼龍瓦 十瓦毋乙瓦龠瓦亅 * 馬齱龍馬鬼十丶日己己己毋車乙丶 * 己齱馬鬼車十十毋日乙己己乙乙 * 車馬齱齱日乙毋瓦己乙瓦日亅 * 亅車齺龖瓦乙車龖龍乙乙十 * 日龠龠十亅車龍毋十十 * 日毋己亅 己己十亅亅 * 丶己十十乙 丶丶丶丶丶 * 亅己十龍龖瓦 丶 丶 乙十 * 亅己十龠龖毋 丶丶 丶己鬼鬼瓦亅 * 十日十十日亅丶亅丶 丶十日毋鬼馬馬車乙 * 十日乙十亅亅亅丶 十乙己毋鬼鬼鬼龍齺馬乙 * 丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十 * 乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶 * 亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅 * 十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車 * 亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車 * 亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼 * 丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼 * 亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼 * 亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦 * 丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日 * 十乙己日十 丶己鬼龍齱齺齱龍馬馬馬車毋己 * 丶十己乙亅丶 亅瓦馬龠龍龠龠馬毋瓦乙 * 丶十十乙亅十 亅己瓦車馬龠鬼車瓦乙 * 丶十乙十十丶 丶丶亅十瓦鬼車瓦己 * 丶亅亅丶 亅日瓦日 * 丶 */ 就不卖关子了，图片转字符可以上这个传送门，白底的话会按空格补全，否则都为字符。 前面的传送门貌似出了点问题，下面再补上个新的传送门，也是很好用的，可以选择质量。 这不，下面的两只doge和一头滑稽就是产自于它，have fun，快去制作专属的字符注释吧。 再补上一个好玩的网站Ascii World，由于这网站的图形太多了，我就不贴上来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798/** * .,:,,, .::,,,::. * .::::,,;;, .,;;:,,....:i: * :i,.::::,;i:. ....,,:::::::::,.... .;i:,. ......;i. * :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i. * ;;..,::::;;;;ri,,,. ..,,:;s1s1ssrr;,.;r, * :;. ,::;ii;:, . ................... .;iirri;;;,,;i, * ,i. .;ri:. ... ............................ .,,:;:,,,;i: * :s,.;r:... ....................................... .::;::s; * ,1r::. .............,,,.,,:,,........................,;iir; * ,s;........... ..::.,;:,,. ...............,;1s * :i,..,. .,:,,::,. .......... .......;1, * ir,....:rrssr;:, ,,.,::. .r5S9989398G95hr;. ....,.:s, * ;r,..,s9855513XHAG3i .,,,,,,,. ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r: * :r;..rGGh, :SAG;;G@BS:.,,,,,,,,,.r83: hHH1sXMBHHHM3..,,,,.ir. * ,si,.1GS, sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8 3@HXHBMBHBBH#X,.,,,,,,rr * ;1:,,SH: .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS, 3@MHABM&amp;59M#As..,,,,:,is, * .rr,,,;9&amp;1 hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s; r9&amp;BMHBHMB9: . .,,,,;ri. * :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr. ...,:rs. * ;s. .:sS8G8GG889hi. ....,,:;:,.:irssrriii:,. ...,,i1, * ;1, ..,....,,isssi;, .,,. ....,.i1, * ;h: i9HHBMBBHAX9: . ...,,,rs, * ,1i.. :A#MBBBBMHB##s ....,,,;si. * .r1,.. ,..;3BMBBBHBB#Bh. .. ....,,,,,i1; * :h;.. .,..;,1XBMMMMBXs,.,, .. :: ,. ....,,,,,,ss. * ih: .. .;;;, ;;:s58A3i,.. ,. ,.:,,. ...,,,,,:,s1, * .s1,.... .,;sh, ,iSAXs;. ,. ,,.i85 ...,,,,,,:i1; * .rh: ... rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr .....,,,,,,,ih; * .s5: ..... i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r: ........,,,,:,,sh; * . ihr, ... . .. ........,,,,,;11:. * ,s1i. ... ..,,,..,,,.,,.,,.,.. ........,,.,,.;s5i. * .:s1r,...................... ..............;shs, * . .:shr:. .... ..............,ishs. * .,issr;,... ...........................,is1s;. * .,is1si;:,....................,:;ir1sr;, * ..:isssssrrii;::::::;;iirsssssr;:.. * .,::iiirsssssssssrri;;:. */ /** * ii. ;9ABH, * SA391, .r9GG35&amp;G * &amp;#ii13Gh; i3X31i;:,rB1 * iMs,:,i5895, .5G91:,:;:s1:8A * 33::::,,;5G5, ,58Si,,:::,sHX;iH1 * Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG * .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8 * :SB9s:,............................,,,.,,,SASh53h,1G. * .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX, * ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi * i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1 * 59;.....,. .,,,,,,,,,,,... .............,..:1;.:&amp;s * s8,..;53S5S3s. .,,,,,,,.,.. i15S5h1:.........,,,..,,:99 * 93.:39s:rSGB@A; ..,,,,..... .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83 * G5.G8 9#@@@@@X. .,,,,,,..... iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh * Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX: * ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M; ....,,,,,,,,S8 * X3 iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs ...,,,,,,,:Gs * r8, ,,,...,,,,,,,,,,..... ,h8XABMMHX3r. .,,,,,,,.rX: * :9, . .:,..,:;;;::,.,,,,,.. .,,. ..,,,,,,.59 * .Si ,:.i8HBMMMMMB&amp;5,.... . .,,,,,.sMr * SS :: h@@@@@@@@@@#; . ... . ..,,,,iM5 * 91 . ;:.,1&amp;@@@@@@MXs. . .,,:,:&amp;S * hS .... .:;,,,i3MMS1;..,..... . . ... ..,:,.99 * ,8; ..... .,:,..,8Ms:;,,,... .,::.83 * s&amp;: .... .sS553B@@HX3s;,. .,;13h. .:::&amp;1 * SXr . ...;s3G99XA&amp;X88Shss11155hi. ,;:h&amp;, * iH8: . .. ,;iiii;,::,,,,,. .;irHA * ,8X5; . ....... ,;iihS8Gi * 1831, .,;irrrrrs&amp;@ * ;5A8r. .:;iiiiirrss1H * :X@H3s....... .,:;iii;iiiiirsrh * r#h:;,...,,.. .,,:;;;;;:::,... .:;;;;;;iiiirrss1 * ,M8 ..,....,.....,,::::::,,... . .,;;;iiiiiirss11h * 8B;.,,,,,,,.,..... . .. .:;;;;iirrsss111h * i@5,:::,,,,,,,,.... . . .:::;;;;;irrrss111111 * 9Bi,:,,,,...... ..r91;;;;;iirrsss1ss1111 *//** * .,, .,:;;iiiiiiiii;;:,,. .,, * rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS, * r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1, * .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii: * :rsriii;;r::::::::::::::::::::::;;,;;iiirsi, * .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,. * ,9BM&amp;, .,:;;:,,,,,,,,,,,hXA8: ..,,,. * ,;&amp;@@#r:;;;;;::::,,. ,r,,,,,,,,,,iA@@@s,,:::;;;::,,. .;. * :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,.. * .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri * iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir; * ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir. * iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir: * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir. * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir. * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir. * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri * ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir: * .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri * ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir, * irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir: * irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir: * ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr: * :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri, * .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr: * .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:. * .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;, * .:irrrriiiiii;;;;;;;;iiiiiirrrr;,. * .,:;iirrrrrrrrrrrrrrrrri;:. * ..,:::;;;;:::,,. */ /** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│&quot; &apos;│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ *//** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\ = /O * ____/`---&apos;\____ * . &apos; \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| &apos;&apos;\---/&apos;&apos; | | * \ .-\__ `-` ___/-. / * ___`. .&apos; /--.--\ `. . __ * .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-&apos;====== * `=---=&apos; * * ............................................. * 佛祖保佑 永无BUG *//** * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ *//** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\ = /O * ___/`---&apos;\____ * . &apos; \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| &apos;&apos;\---/&apos;&apos; | | * \ .-\__ `-` ___/-. / * ___`. .&apos; /--.--\ `. . __ * .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-&apos;====== * `=---=&apos; * ............................................. * 佛曰：bug泛滥，我已瘫痪！ *//** * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ *//** * .::::. * .::::::::. * ::::::::::: FUCK YOU * ..:::::::::::&apos; * &apos;::::::::::::&apos; * .:::::::::: * &apos;::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::&apos; .:::. * ::::&apos; &apos;:::::&apos; .::::::::. * .::::&apos; :::: .:::::::&apos;::::. * .:::&apos; ::::: .:::::::::&apos; &apos;:::::. * .::&apos; :::::.:::::::::&apos; &apos;:::::. * .::&apos; ::::::::::::::&apos; ``::::. * ...::: ::::::::::::&apos; ``::. * ```` &apos;:. &apos;:::::::::&apos; ::::.. * &apos;.:::::&apos; &apos;:&apos;````.. *//** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! *//** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ &gt; &lt; │ * │ │ * │ ... ⌒ ... │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! *//** * ┌─┐ ┌─┐ + + * ┌──┘ ┴───────┘ ┴──┐++ * │ │ * │ ─── │++ + + + * ███████───███████ │+ * │ │+ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ + + * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ + + + + * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ + + + + * 神兽保佑 * 代码无BUG! *//** * ___====-_ _-====___ * _--^^^#####// \\#####^^^--_ * _-^##########// ( ) \\##########^-_ * -############// |\^^/| \\############- * _/############// (@::@) \\############\_ * /#############(( \\// ))#############\ * -###############\\ (oo) //###############- * -#################\\ / VV \ //#################- * -###################\\/ \//###################- * _#/|##########/\######( /\ )######/\##########|\#_ * |/ |#/\#/\#/\/ \#/\##\ | | /##/\#/ \/\#/\#/\#| \| * ` |/ V V ` V \#\| | | |/#/ V &apos; V V \| &apos; * ` ` ` ` / | | | | \ &apos; &apos; &apos; &apos; * ( | | | | ) * __\ | | | | /__ * (vvv(VVV)(VVV)vvv) * 神兽保佑 * 代码无BUG! *//** * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \_|// |||\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \/ ||| \\ _/~~- * __---~~~.==~||\=_ -_--~/_-~|- |\\ \\ _/~ * _-~~ .=~ | \\-_ &apos;-~7 /- / || \ / * .~ .~ | \\ -_ / /- / || \ / * / ____ / | \\ ~-_/ /|- _/ .|| \ / * |~~ ~~|--~~~~--_ \ ~==-/ | \~--===~~ .\ * &apos; ~-| /| |-~\~~ __--~~ * |-~~-_/ | | ~\_ _-~ /\ * / \ \__ \/~ \__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-&gt;/~ &apos;.|||&apos; -_| ~~-/ , . _|| * -_ ~\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\ * 神兽保佑 * 代码无BUG! *//** _ * _._ _..._ .-&apos;, _.._(`)) * &apos;-. ` &apos; /-._.-&apos; &apos;,/ * ) \ &apos;. * / _ _ | \ * | a a / | * \ .-. ; * &apos;-(&apos;&apos; ).-&apos; ,&apos; ; * &apos;-; | .&apos; * \ \ / * | 7 .__ _.-\ \ * | | | ``/ /` / * /,_| | /,_/ / * /,_/ &apos;`-&apos; *//** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-&quot; &quot;-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; &quot;=._ | )(__/ \__)( | _.=&quot; &lt; | * * | (_/&quot;=._&quot;=._ |/ /\ \| _.=&quot;_.=&quot;\_) | * * | &quot;=._&quot;(_ ^^ _)&quot;_.=&quot; | * * | &quot;=\__|IIIIII|__/=&quot; | * * | _.=&quot;| \IIIIII/ |&quot;=._ | * * | _ _.=&quot;_.=&quot;\ /&quot;=._&quot;=._ _ | * * | ( \_.=&quot;_.=&quot; `--------` &quot;=._&quot;=._/ ) | * * | &gt; _.=&quot; &quot;=._ &lt; | * * | (_/ \_) | * * | | * * &apos;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&apos; * * * * LASCIATE OGNI SPERANZA, VOI CH&apos;ENTRATE * ************************************************************** *//** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * 又看源码，看你妹妹呀！ *//** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ *//** * ,%%%%%%%%, * ,%%/\%%%%/\%% * ,%%%\c &quot;&quot; J/%%% * %. %%%%/ o o \%%% * `%%. %%%% _ |%%% * `%% `%%%%(__Y__)%%&apos; * // ;%%%%`\-/%%%&apos; * (( / `%%%%%%%&apos; * \\ .&apos; | * \\ / \ | | * \\/ ) | | * \ /_ | |__ * (___________))))))) 攻城湿 * * _ _ * __ _(_)_ _(_) __ _ _ __ * \ \ / / \ \ / / |/ _` |&apos;_ \ * \ V /| |\ V /| | (_| | | | | * \_/ |_| \_/ |_|\__,_|_| |_| *//** * https://gold.xitu.io/ * １１１ １ * １１１ １１１１１１１１１１１１ １１１ * １１ １１１１１１１１１１１１ １１１１１ * １１ １１１ １１ １１１１１１１ * １１１１ １ １１１１１１１１１１１ １１１ １１１１ * １１１１１１ １１１１１１１１１１１ １１１１ １１１１１ * １１１１１１ １１ １１１１ １１１１１１ * １１ １１１１１１１１ １１ １１１１１１１１１１１１１１１１１１ * １１ １１１１１１１１１１１ １１１１１１１１１１１１１１１１１１１ * １１１１１１１１１ １１ １１ １１ １１ * １１１１１１１１１１１１１１１１１１ １１ * １１１１ １１１１１１１１１１１１ １１１１１１１１１１１１１１ * １１１１ １１ １１ １１１１１１１１１１１１１１ * １１ １１ １１ １１ １１１ １１ １１ １１１ * １１ １１ １１ １１ １１ １１１ １１ １１１ * １１ １１１ １１ １１ １１ １１１ １１ １１１ * １１１１ １１１ １１１１１１１１１ １１ １１１ １１ １１１１１１１ * １１１１１１ １１１１１１１１１１ １１１１１１１１１１１１１１１１１ * １１ １１１ １１１ １１１１１１１１１１１１１１１１１ *//** * https://www.zhihu.com/ * _____ _____ _____ _____ * /\ \ /\ \ /\ \ /\ \ * /::\____\ /::\ \ /::\ \ /::\ \ * /:::/ / \:::\ \ /::::\ \ /::::\ \ * /:::/ / \:::\ \ /::::::\ \ /::::::\ \ * /:::/ / \:::\ \ /:::/\:::\ \ /:::/\:::\ \ * /:::/____/ \:::\ \ /:::/__\:::\ \ /:::/__\:::\ \ * /::::\ \ /::::\ \ /::::\ \:::\ \ /::::\ \:::\ \ * /::::::\ \ _____ ____ /::::::\ \ /::::::\ \:::\ \ /::::::\ \:::\ \ * /:::/\:::\ \ /\ \ /\ \ /:::/\:::\ \ /:::/\:::\ \:::\____\ /:::/\:::\ \:::\ \ * /:::/ \:::\ /::\____\/::\ \/:::/ \:::\____\/:::/ \:::\ \:::| |/:::/__\:::\ \:::\____\ * \::/ \:::\ /:::/ /\:::\ /:::/ \::/ /\::/ |::::\ /:::|____|\:::\ \:::\ \::/ / * \/____/ \:::\/:::/ / \:::\/:::/ / \/____/ \/____|:::::\/:::/ / \:::\ \:::\ \/____/ * \::::::/ / \::::::/ / |:::::::::/ / \:::\ \:::\ \ * \::::/ / \::::/____/ |::|\::::/ / \:::\ \:::\____\ * /:::/ / \:::\ \ |::| \::/____/ \:::\ \::/ / * /:::/ / \:::\ \ |::| ~| \:::\ \/____/ * /:::/ / \:::\ \ |::| | \:::\ \ * /:::/ / \:::\____\ \::| | \:::\____\ * \::/ / \::/ / \:| | \::/ / * \/____/ \/____/ \|___| \/____/ *//** * http://www.freebuf.com/ * _.._ ,------------. * ,&apos; `. ( We want you! ) * / __) __` \ `-,----------&apos; * ( (`-`(-&apos;) ) _.-&apos; * /) \ = / ( * /&apos; |--&apos; . \ * ( ,---| `-.)__` * )( `-.,--&apos; _`-. * &apos;/,&apos; ( Uu&quot;, * (_ , `/,-&apos; ) * `.__, : `-&apos;/ /`--&apos; * | `--&apos; | * ` `-._ / * \ ( * /\ . \. freebuf * / |` \ ,-\ * / \| .) / \ * ( ,&apos;|\ ,&apos; : * | \,`.`--&quot;/ &#125; * `,&apos; \ |,&apos; / * / &quot;-._ `-/ | * &quot;-. &quot;-.,&apos;| ; * / _/[&quot;---&apos;&quot;&quot;] * : / |&quot;- &apos; * &apos; | / * ` | *//** * https://campus.alibaba.com/ * `:::::::::::, * `::;:::::::;:::::::, ` * `::;;:::::::@@@@;:::::::` * ,:::::::::::::@ #@&apos;:::::` * :::::::::::::::&apos;@@ @;:::: * ::::::::::::&apos;@@@@&apos;``` .+:::` * ::::::::::;@@@#. ,:::, * .::::::::+@#@` :::: * :::::::+@@&apos; :::: * `:::::&apos;@@: `:::. * ,::::@@: ` :::: * ;::::::@ .:::; * :;:::::;@` ` :::; * :::::::::@` @ ;:::: * :::::::::#` @` ,:::: * :::::::::@` +@ @ .::::` * .::::::&apos;@@` `@@&apos; @ ::::, * :::::::++@@@@@@@@@@. ::::; * ;:::::::+, `..` ::::: * ,::::::::&apos;, ::::: * :::::::::+, :::::` * :::::::::+@. ,::::.` `, * ::::::;;@+ .::;:: `; * :::::::@@ `:::;: `::`` * ::::::#@ ;:::: .::` * :::::;@ :::::` .;::` * :::::@ `:;::: `::::; * :::::# :::::. `,;::::: * :::::: ` ::::::,.,::::::::::. * ,::::::` .:: ::::::::::::::::;` * ;::::::::,````.,:::::, ::::::::::::::. * :::::::::::::::::: ` `::::::::::` * `::::::::::::, .:::. * `..` *//** * http://www.flvcd.com/ * .--, .--, * ( ( \.---./ ) ) * &apos;.__/o o\__.&apos; * &#123;= ^ =&#125; * &gt; - &lt; * / \ * // \\ * //| . |\\ * &quot;&apos;\ /&apos;&quot;_.-~^`&apos;-. * \ _ /--&apos; ` * ___)( )(___ * (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。 *//** * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂 * 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂 * 頂頂頂頂 頂頂頂頂 頂頂頂頂 *//** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 *//** * /88888888888888888888888888\ * |88888888888888888888888888/ * |~~____~~~~~~~~~&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;| * / \_________/&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\ * / | \ \ * / | 88 88 \ \ * / | 88 88 \ \ * / / \ | * / | ________ \ | * \ | \______/ / | * /&quot;\ \ \____________ / | * | |__________\_ | | / / * /&quot;&quot;&quot;&quot;\ \_------&apos; &apos;-------/ -- * \____/,___________\ -------/ * ------* | \ * || | \ * || | ^ \ * || | | \ \ * || | | \ \ * || | | \ \ * \| / /&quot;&quot;&quot;\/ / * ------------- | | / * |\--_ \____/___/ * | |\-_ | * | | \_ | * | | \ | * | | \_ | * | | ----___ | * | | \----------| * / | | ----------&quot;&quot;\ * /&quot;\--&quot;--_| | | \ * |_______/ \______________/ ) * \___/ *//** * d*##$. * zP&quot;&quot;&quot;&quot;&quot;$e. $&quot; $o * 4$ &apos;$ $&quot; $ * &apos;$ &apos;$ J$ $F * &apos;b $k $&gt; $ * $k $r J$ d$ * &apos;$ $ $&quot; $~ * &apos;$ &quot;$ &apos;$E $ * $ $L $&quot; $F ... * $. 4B $ $$$*&quot;&quot;&quot;*b * &apos;$ $. $$ $$ $F * &quot;$ R$ $F $&quot; $ * $k ?$ u* dF .$ * ^$. $$&quot; z$ u$$$$e * #$b $E.dW@e$&quot; ?$ * #$ .o$$# d$$$$c ?F * $ .d$$#&quot; . zo$&gt; #$r .uF * $L .u$*&quot; $&amp;$$$k .$$d$$F * $$&quot; &quot;&quot;^&quot;$$$P&quot;$P9$ * JP .o$$$$u:$P $$ * $ ..ue$&quot; &quot;&quot; $&quot; * d$ $F $ * $$ ....udE 4B * #$ &quot;&quot;&quot;&quot;` $r @$ * ^$L &apos;$ $F * RN 4N $ * *$b d$ * $$k $F * $$b $F * $&quot;&quot; $F * &apos;$ $ * $L $ * &apos;$ $ * $ $ *//** * ,----------------, ,---------, * ,-----------------------, ,&quot; ,&quot;| * ,&quot; ,&quot;| ,&quot; ,&quot; | * +-----------------------+ | ,&quot; ,&quot; | * | .-----------------. | | +---------+ | * | | | | | | -==----&apos;| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\&gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ,&quot; * | `-----------------&apos; |,&quot; .;&apos;| |(((( | ,&quot; * +-----------------------+ ;; | | |,&quot; * /_)______________(_/ //&apos; | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \,&quot;----------- * / ==ooooooooooooooo==.o. ooo= // ,`\--&#123;)B ,&quot; * /_==__==========__==_ooo__ooo=_/&apos; /___________,&quot; * *//** * .-~~~~~~~~~-._ _.-~~~~~~~~~-. * __.&apos; ~. .~ `.__ * .&apos;// \./ \\`. * .&apos;// | \\`. * .&apos;// .-~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~~~~-._ | _,-~~~~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~-. \\`. * .&apos;//.-&quot; `-. | .-&apos; &quot;-.\\`. * .&apos;//______.============-.. \ | / ..-============.______\\`. * .&apos;______________________________\|/______________________________`. * *//** 无可奉告 一颗赛艇 * uJjYJYYLLv7r7vJJ5kqSFFFUUjJ7rrr7LLYLJLJ7 * JuJujuYLrvuEM@@@B@@@B@B@B@@@MG5Y7vLjYjJL * JYjYJvr7XM@BB8GOOE8ZEEO8GqM8OBBBMu77LLJ7 * LJLY7ru@@@BOZ8O8NXFFuSkSu25X0OFZ8MZJ;vLv * YvL7i5@BM8OGGqk22uvriiriii;r7LuSZXEMXrvr * vv7iU@BMNkF1uY7v7rr;iiii:i:i:ii7JEPNBPir * L7iL@BM8Xjuujvv77rr;ri;i;:iiiii:iLXFOBJ: * 7ri@B@MOFuUS2Y7L7777rii;:::::i:iirjPG@O: * 7:1B@BBOPjXXSJvrL7rr7iiii:i::::i;iv5MBB, * r:0@BBM8SFPX2Y77rri::iirri:::::iii75O@G. * 7:SB@BBGqXPk0122UJL::i::r:::i:i;i:v2@Bk. * ri:MB@BBEqEMGq2JLLL1u7.iX51u77LF27iSB@r, * ri,v@B@MB8@qqNEqN1u:5B8BOFE0S7ii7qMB@F:: * ii,J80Eq1MZkqPPX5YkPE@B@iXPE52j7:vBjE7:: * ii:7MSqkS0PvLv7rrii0@L.Z1iLr::ir:rO,vi:: * ii::EZXPSkquLvii:iF@N:.,BUi7ri,::UY;r::: * i::.2ONXqkPXS5FUUEOPP;..iSPXkjLYLLrr:::, * :::,iMXNP0NPLriiLGZ@BB1P87;JuL7r:7ri:::, * :::,.UGqNX0EZF2uUjUuULr:::,:7uuvv77::::. * ::::..5OXqXNJ50NSY;i:.,,,:i77Yvr;v;,,::. * :::,:.jOEPqPJiqBMMMO8NqP0SYLJriirv:.:,:. * ,:,,,.,Zq0P0X7vPFqF1ujLv7r:irrr7j7.,,::. * ,,,....0qk0080v75ujLLv7ri:i:rvj2J...,,,. * ......8@UXqZEMNvJjr;ii::,:::7uuv...,.,,. * .....B@BOvX88GMGk52vririiirJS1i.......,. * .JEMB@B@BMvL0MOMMMO8PE8GPqSk2L:......... * @B@@@B@M@B@L:7PGBOO8MOMOEP0Xri@B@Mk7,... * B@B@BBMBB@B@0::rJP8MO0uvvu7..,B@B@B@B@Z7 * MMBM@BBB@B@B@Br:i,..:Lur:....7@OMMBM@B@@ * 8OOMMMOMMMMBB@B:....,PZENNi..JBOZ8GMOOOO */ 以上为魔性图 以下为神注释 1234/** * 这个公司没有年终奖的,兄弟别指望了,也别来了,我准备辞职了 * 另外这个项目有很多*Bug* 你坚持不了多久的,拜拜! */ 123456789101112131415161718192021222324252627282930313233/** * 1只羊 == one sheep * 2只羊 == two sheeps * 3只羊 == three sheeps * 4只羊 == four sheeps * 5只羊 == five sheeps * 6只羊 == six sheeps * 7只羊 == seven sheeps * 8只羊 == eight sheeps * 9只羊 == nine sheeps * 10只羊 == ten sheeps * 11只羊 == eleven sheeps * 12只羊 == twelve sheeps * 13只羊 == thirteen sheeps * 14只羊 == fourteen sheeps * 15只羊 == fifteen sheeps * 16只羊 == sixteen sheeps * 17只羊 == seventeen sheeps * 18只羊 == eighteen sheeps * 19只羊 == nineteen sheeps * 20只羊 == twenty sheeps * 21只羊 == twenty one sheeps * 22只羊 == twenty two sheeps * 23只羊 == twenty three sheeps * 24只羊 == twenty four sheeps * 25只羊 == twenty five sheeps * 26只羊 == twenty six sheeps * 27只羊 == twenty seven sheeps * 28只羊 == twenty eight sheeps * 29只羊 == twenty nine sheeps * 30只羊 == thirty sheeps * 现在瞌睡了吧，好了，不要再改下面的代码了，睡觉咯~~ */ 12345678910111213/** * You may think you know what the following code does. * But you dont. Trust me. * Fiddle with it, and youll spend many a sleepless * night cursing the moment you thought youd be clever * enough to &quot;optimize&quot; the code below. * Now close this file and go play with something else. *//** * 你可能会认为你读得懂以下的代码。但是你不会懂的，相信我吧。 * 要是你尝试玩弄这段代码的话，你将会在无尽的通宵中不断地咒骂自己为什么会认为自己聪明到可以优化这段代码。 * 现在请关闭这个文件去玩点别的吧。 */ 12345678/** * somedev1 - 6/7/02 Adding temporary tracking of Login screen * somedev2 - 5/22/07 Temporary my ass *//** * 一些修改1 - 2002/6/7 增加临时的跟踪登录界面 * 一些修改2 - 2007/5/22 我临时的犯傻 */ 1234567/** * 程序员1（于2010年6月7日）：在这个坑临时加入一些调料 * 程序员2（于2011年5月22日）：临你个屁啊 * 程序员3（于2012年7月23日）：楼上都是狗屎，鉴定完毕 * 程序员4（于2013年8月2日）：fuck 楼上，三年了，这坑还在！！！ * 程序员5（于2014年8月21日）：哈哈哈，这坑居然坑了这么多人，幸好我也不用填了，系统终止运行了，you&apos;re died */ 1234567891011121314/** * For the brave souls who get this far: You are the chosen ones, * the valiant knights of programming who toil away, without rest, * fixing our most awful code. To you, true saviors, kings of men, * I say this: never gonna give you up, never gonna let you down, * never gonna run around and desert you. Never gonna make you cry, * never gonna say goodbye. Never gonna tell a lie and hurt you. *//** * 致终于来到这里的勇敢的人： * 你是被上帝选中的人，是英勇的、不敌辛苦的、不眠不休的来修改我们这最棘手的代码的编程骑士。 * 你，我们的救世主，人中之龙，我要对你说：永远不要放弃，永远不要对自己失望，永远不要逃走，辜负了自己， * 永远不要哭啼，永远不要说再见，永远不要说谎来伤害自己。 */ 123456789101112131415161718/** * Dear maintainer: * * Once you are done trying to &apos;optimize&apos; this routine, * and have realized what a terrible mistake that was, * please increment the following counter as a warning * to the next guy: * * total_hours_wasted_here = 42 *//** * 亲爱的维护者： * * 如果你尝试了对这段程序进行&apos;优化&apos; * 下面这个计数器的个数用来对后来人进行警告 * * 浪费在这里的总时间 = 42h */ 12Exception up = new Exception(&quot;Something is really wrong.&quot;);throw up; //ha ha 12345678/** * When I wrote this, only God and I understood what I was doing * Now, God only knows *//*** 写这段代码的时候，只有上帝和我知道它是干嘛的* 现在，只有上帝知道*/ 1stop(); // Hammertime! 1// Autogenerated, do not edit. All changes will be undone. 12// sometimes I believe compiler ignores all my comments// 有时候我相信编译器忽略了我所有的注释 12345/** * I dedicate all this code, all my work, to my wife, Darlene, who will * have to support me and our three children and the dog once it gets * released into the public. */ 12// drunk, fix later// 有点晕了，以后再修改 12// Magic. Do not touch.// 麻鸡。勿动。 1#define TRUE FALSE// Happy debugging suckers 1// I&apos;m sorry. 1return 1; # returns 1 123456/** * Always returns true. */public boolean isAvailable() &#123; return false;&#125; 12&lt;!-- Here be dragons --&gt;&lt;!-- 前方高能 --&gt; 12double penetration; // ouch// 自行了解，不方便解释 1/////////////////////////////////////// this is a well commented line 123456// To understand recursion, see the bottom of this fileAt the bottom of the file:// To understand recursion, see the top of this file// 想要明白递归须看文件末尾到了文末// 想要明白递归须看文件顶部 1/* Please work */ 12long long ago; /* in a galaxy far far away */// 很久很久以前 在一个遥远的银河中（出自星球大战） 1234// This code sucks, you know it and I know it. // Move on and call me an idiot later.// 你我都知道这代码很烂// 先不要骂我2B了，请先继续往下看 12// I am not sure why this works but it fixes the problem.// 虽然我不知道为什么这样管用，但它却是修复了问题 12// If this comment is removed the program will blow up// 如果删了此处注释程序就炸了 12// This function has been here since 1987. DON&apos;T FXXKING TOUCH IT// 这函数1987年就这在了，别他娘动它 12// if i ever see this again i&apos;m going to start bringing guns to work// 如果要是再让我看见这样的代码，也许我会带着一把枪来上班 1234// no comments for you// it was hard to write// so it should be hard to read// 难写的代码，肯定很难读。因此，我没有注释留给你。 12// I will give you two of my seventy-two virgins if you can fix this.// 要是你能修正这个问题的话，我会在我的七十二个处女中挑两个送你 123// I am not responsible of this code.// They made me write it, against my will.// 下面的代码，我不负责。因为是他们逼我写的，违背了我的意愿。 12/* You are not expected to understand this *//* 你绝不会明白的 */ 12// I have to find a better job// 看来我需要找份更好的工作了 123/** * 这个类是Object的子类 */ 如果有更好地可以留言或者到传送门提issue，如果看到这能带给你快乐的话，那就点个稀饭吧，谢谢大佬们赏脸，愿所有的程序都永无Bug。]]></content>
      <categories>
        <category>Joke</category>
      </categories>
      <tags>
        <tag>comment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不得不了解的HTML知识]]></title>
    <url>%2F2016%2F12%2F27%2Fhave-to-konw-the-html-knowledge%2F</url>
    <content type="text"><![CDATA[这次要细说的只是块级元素和行内元素的内容，如有不对，请轻喷。 块级元素和行内元素默认情况下块级元素会始终占居一行，而行内元素并不会。除了 table 元素的 display 属性比较特殊以外，基本上所有的 HTML 元素的 display 的属性值要么是 block，要么是 inline。无论你想了解哪个 HTML 元素，第一个要问的问题就是：它是块级元素还是行内元素，然后在编写标记的时候预想到这个元素在初始状态下是如何定位的，这样才能进一步想好将来怎么用 CSS 重新定位它，因为块级元素和行内元素在定位上有很大的区别，后面会详细说明。 块级元素盒子（一个很重要的概念————盒模型）会扩展到与父元素同宽，这也是为什么块级元素会占居一行的原因了，因为所有块级元素的父元素都是 body，而它的默认宽度就是浏览器的视口大小，所以默认情况下块级元素的宽度也和浏览器的视口一样宽，这样以来，一个块级元素旁边也就没有空间来容纳另一个块级元素了。 相比于块级元素会扩展到与父元素同宽，然而行内元素的行为却是恰恰相反，它会尽量的收缩包裹其内容，这也就是为什么几个行内元素会并排显示在一行直到它们排满一行才会另起一行，而每个块级元素会直接另起一行的原因了。 下表列出了一些常见的块级元素和行内元素： 块级元素 行内元素 div span form a table img header label aside input section select article textarea figure br figcaption i h1~h6 em nav strong p small pre button blockqoute sub canvas sup ol, ul, dl code 之前提到过无论你想了解哪个 HTML 元素，第一个要问的问题就是：它是块级元素还是行内元素，因为它们在盒模型上的表现有很大的不同，不过在了解它们的不同之前我们还得先知道另外一个概念————替换元素和非替换元素，其中替换元素就是指浏览器是根据元素的属性来判断具体要显示的内容的元素，比如 img 标签，浏览器是根据其 src 的属性值来读取这个元素所包含的内容的，常见的替换元素还有 input 、textarea、 select、 object、 iframe 和 video 等等，这些元素都有一个共同的特点，就是浏览器并不直接显示其内容，而是通过其某个属性的值来显示具体的内容，比如浏览器会根据 input 中的 type 的属性值来判断到底应该显示单选按钮还是多选按钮亦或是文本输入框。而对于非替换元素，比如 p、label 元素等等，浏览器这是直接显示元素所包含的内容。看到这里你应该大概的知道了什么是替换元素和非替换元素了。 对着两个概念有了大概的了解后就可以对 block 和 inline 在盒模型上的表现差异进行了解了，首先是 margin ，W3C 对其所支持了元素对象是这么定义的： Applies to: all elements except elements with table display types other than table-caption, table and inline-table 我的理解就是所有元素都支持 margin 除了 display 属性值为 table-caption 和 table-inline 以外的所有表格显示类型比如table-row-group、 table-cell、 table-row 和 table-header-group等等,但是为了验证我的理解，我发现 display 属性值为 table 的元素也支持，可能是我对原文标准的理解有误。但还有一个要特别注意的是 margin-top 和 margin-bottom 两个属性比较特殊，它们对非替换行内元素没有效果，下面是 W3C 上对于 margin-top 和margin-bottom 支持对象的介绍： Applies to: all elements except elements with table display types other than table-caption, table and inline-tableThese properties have no effect on non-replaced inline elements. 前面一句和之前对 margin 的描述是一样的，这毫无疑问，下面这句话的意思是这些（ margin-top 和 margin-bottom ）属性对非替换行内元素没有效果比如 a 和span，注意这里是非替换行内元素而不单单是非替换元素或者是行内元素。比如 img 就是一个行内元素， margin-top 和 margin-bottom 对它是有效果的，因为它是一个替换元素而不是非替换元素，所以对于「 margin-top 和 margin-bottom 对行内元素没有效果」这种说法是不对的。 而对于 padding 的支持对象，W3C 是这么描述的： all elements except table-row-group, table-header-group, table-footer-group, table-row, table-column-group and table-column 上面这句话的意思是除了表格显示类型为 table-row-group、 table-header-group、 table-footer-group、 table-row,table-column-group 和 table-column 的元素不支持，其他所有的元素都支持。 但这里有些特殊情况需要注意的是，对行内元素比如 span 和 img 设置左右内边距的效果是可见可，但是对行内元素设置上下内边距在有些情况下是不可见的，这些情况又要分为是否为替换元素和是否设置了背景色，为了能更直观的了解这些概念，我在这里做了个表格： padding-top和padding-bottom 对于行内元素是否可见 替换元素（e.g: input） 非替换元素（e.g: span） 设置背景色 可见影响行高会撑开父元素 可见不影响行高不会撑开父元素 没有设置背景色 可见影响行高会撑开父元素 不可见不影响行高不会撑开父元素 所以对于「 padding-top 和 padding-bottom 对行内元素没有效果」这种说法也是不对的，因为它们只是对于没有设置背景色的行内非替换元素效果不可见而已，而对于行内替换元素来说，不管是否设置了背景色都是有效果了，并且会把父元素撑开。 说了这么多 block 和 inline 的区别，其实除了这两个常见的 display 属性以外还有一个属性也是非常常见的，那就是 inline-block ，没错，这就是前面两种情况的结合体，它既有 block 的特性又有 inline 的特性，比如把一个 display 属性值为 block 或者 inline 的元素属性值设置成 inline-block 后，既可以用只对行内元素有效的 text-align: center; 声明对其进行居中以外，还可以用 padding-top 和 padding-bottom 对元素设置上下内边距而无需对其设置背景色，并且能把父元素撑开。 不要问我为何知道这么多，我只献上传送门]]></content>
      <categories>
        <category>JS</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可旋转的ImageView]]></title>
    <url>%2F2016%2F11%2F10%2Frotatable-imageView%2F</url>
    <content type="text"><![CDATA[话不多少，先上效果图过一下瘾。 经我网上一搜，没有很好的实例来单独实现以上效果，所以只能老司机自己出马了。为了实现以上效果，当然离不开我们对onTouchEvent事件的处理了，老司机们应该都懂的，开始开车，嘟嘟~ 下面来说一下思路，首先上一张图，让我更方便地来为乘客们讲解。 好了，重要的都已经在图中说了，下面只需要一个回调便可在外部获取到旋转的角度，献上相关重要代码，相信根据我的注释，大家也都应该明白了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Matrix;import android.graphics.drawable.BitmapDrawable;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.widget.ImageView;/** * &lt;pre&gt; * author: Blankj * blog : http://blankj.com * time : 2016/11/8 * desc : * &lt;/pre&gt; */public class RotateImageView extends ImageView &#123; // 点击在view中所在坐标 private float x, y; // view的中心点坐标 private float ox, oy; // view的宽、高 private int w, h; private Matrix matrix; // ImageView的资源图片 Bitmap mBitmap; // 旋转过的角度 public float totalDegree = 0; // 是否初始化过 private boolean isInit = false; // 旋转角度改变的监听器 private OnRotationChangeListener mListener; public void setOnRotationChangeListener(OnRotationChangeListener listener) &#123; mListener = listener; &#125; public RotateImageView(Context context) &#123; this(context, null); &#125; public RotateImageView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RotateImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 已初始化完毕的话那就直接滚回老家去吧 if (isInit) return; int measureWidth = getWidth(); int measureHeight = getHeight(); Log.d("blankj", "onMeasure: w: " + measureWidth + ", h: " + measureHeight); // 如果没有初始化过，就初始化 if (measureWidth != 0 &amp;&amp; measureHeight != 0 &amp;&amp; !isInit) &#123; isInit = true; mBitmap = ((BitmapDrawable) this.getDrawable()).getBitmap(); w = measureWidth; h = measureHeight; ox = w &gt;&gt; 1; oy = h &gt;&gt; 1; matrix = new Matrix(); // 获取适配于ImageView的bitmap mBitmap = Bitmap.createScaledBitmap(mBitmap, w, h, true); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; Log.d("blankj", "onDraw"); // 判空以防崩溃 if (mBitmap == null) return; canvas.save(); canvas.drawBitmap(mBitmap, matrix, null); canvas.restore(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: x = event.getX(); y = event.getY(); break; case MotionEvent.ACTION_MOVE: float nowX = event.getX(); float nowY = event.getY(); // 计算三边的平方 float ab2 = (x - nowX) * (x - nowX) + (y - nowY) * (y - nowY); float oa2 = (x - ox) * (x - ox) + (y - oy) * (y - oy); float ob2 = (nowX - ox) * (nowX - ox) + (nowY - oy) * (nowY - oy); // 根据两向量的叉乘来判断顺逆时针 boolean isClockwise = ((x - ox) * (nowY - oy) - (y - oy) * (nowX - ox)) &gt; 0; // 根据余弦定理计算旋转角的余弦值 double cosDegree = (oa2 + ob2 - ab2) / (2 * Math.sqrt(oa2) * Math.sqrt(ob2)); // 异常处理，因为算出来会有误差绝对值可能会超过一，所以需要处理一下 if (cosDegree &gt; 1) &#123; cosDegree = 1; &#125; else if (cosDegree &lt; -1) &#123; cosDegree = -1; &#125; // 计算弧度 double radian = Math.acos(cosDegree); // 计算旋转过的角度，顺时针为正，逆时针为负 float degree = (float) (isClockwise ? Math.toDegrees(radian) : -Math.toDegrees(radian)); // 累加角度 totalDegree += degree; matrix.setRotate(totalDegree, ox, oy); // 更新触摸点 x = nowX; y = nowY; // 回调把角度抛出 if (mListener != null) &#123; mListener.getRotation((int) totalDegree); &#125; invalidate(); break; case MotionEvent.ACTION_UP: // 如果图片需要复原原来角度，调用下方代码// matrix.setRotate(totalDegree, ox, oy);// invalidate(); break; &#125; return true; &#125; public void reset() &#123; totalDegree = 0; matrix.setRotate(totalDegree, ox, oy); invalidate(); &#125; public interface OnRotationChangeListener &#123; void getRotation(int degree); &#125;&#125; 好了，乘客们，终点站已到，谢谢你们旅途中的陪伴，老司机马上要下班了，啊哈哈哈，还是那句话：“你不买东西也是没钱，买了东西也是没钱，那就说明买东西它不要钱啊”，祝大家双十一购物愉快。 最后献上源码地址：GetRotateDegree，欢迎大家star和fork。]]></content>
      <categories>
        <category>Android</category>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发之版本统一规范]]></title>
    <url>%2F2016%2F09%2F21%2Fandroid-keep-version-unity%2F</url>
    <content type="text"><![CDATA[Android 开发存在着众多版本的不同，比如 compileSdkVersion、minSdkVersion、targetSdkVersion 以及项目中依赖第三方库的版本，不同的 module 及不同的开发人员都有不同的版本，所以需要一个统一版本规范的文件，现在我就来介绍一种方式。 在项目根目录，也就是跟 app 同一目录下的 build.gradle 文件，如下图所示 在其最后添加如下 groovy 代码。 123456789101112131415161718ext &#123; // Sdk and tools compile_sdk_version = 26 build_tools_version = '26.0.0' min_sdk_version = 14 target_sdk_version = 22 version_code = 100900900 version_name = '1.9.9' // App dependencies support_version = '26.1.0' leakcanary_version = '1.5.4' junit_version = '4.12' robolectric_version = '3.1.2'&#125; 有了这个规范，那么我们在app下的build.gradle文件就可以这样来引用了 1234567891011121314151617android &#123; compileSdkVersion compile_sdk_version defaultConfig &#123; minSdkVersion min_sdk_version versionCode version_code versionName version_name &#125;&#125;dependencies &#123; compileOnly "com.android.support:appcompat-v7:$support_version" compileOnly "com.android.support:design:$support_version" testImplementation "junit:junit:$junit_version" testImplementation "org.robolectric:robolectric:$robolectric_version" testImplementation "com.android.support:support-v4:$support_version"&#125; 是不是一劳永逸了，今后修改版本只需要修根目录下的 build.gradle 文件即可把所有依赖版本都修改，希望可以对你们的 Android 开发规范有所帮助。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 下对资源进行分包]]></title>
    <url>%2F2016%2F09%2F21%2Fandroid-studio-classify-src-package%2F</url>
    <content type="text"><![CDATA[也许你曾经用过这个插件来对资源文件 layout 进行分类https://github.com/dmytrodanylyk/folding-plugin，但如今随着 AS 版本的升高，该插件已经不再支持。 now，我来分享一种比这个插件更加优秀合理地对资源进行分包，让你的资源文件看起来简明有序。先上效果图，如下所示： 从图中可以看出新增了 res_core 和 res_sub 两个资源包，这样我们可以对每个模块的资源都进行具体分类，是不是心动了，赶紧照着如下配置试一试吧，别再让资源文件们“混为一潭”了。 方法很简单，配置我们的app文件夹下的 build.gradle 文件，比如我的 12345678android &#123; ... sourceSets &#123; main &#123; res.srcDirs(&apos;src/main/res&apos;, &apos;src/main/res_core&apos;, &apos;src/main/res_sub&apos;) &#125; &#125;&#125; 配置完之后，sync project 一下就成功了。 补充：发现有小伙伴试验不成功，好伐，是我疏漏了，文件夹是要自己创建的，因为自己创建的文件夹 gradle 不能解析为资源文件来使用，所以需要在 build.gradle 中进行配置，这样你们就懂了吧。 如果还有问题，可以参照AndroidUtilCode的使用]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现滑动的七种方法(Android群英传)]]></title>
    <url>%2F2016%2F08%2F01%2Fachieve-srcoll-seven-ways-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 当了解了Android坐标系和触控事件后，我们再来看看如何使用系统提供的API来实现动态地修改一个View的坐标，即实现滑动效果。而不管采用哪一种方式，其实现的思想基本是一致的，当触摸View时，系统记下当前触摸点坐标；当手指移动时，系统记下移动后的触摸点坐标，从而获取到相对于前一次坐标点的偏移量，并通过偏移量来修改View的坐标，这样不断重复，从而实现滑动过程。 下面我们就通过一个实例，来看看在Android中该如何实现滑动效果。定义一个View，并置于一个LinearLayout中，实现一个简单的布局，代码如下所示。 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;com.blankj.achievescroll.DragView android:layout_width="100dp" android:layout_height="100dp" android:background="#ff09cfb1"/&gt;&lt;/LinearLayout&gt; 我们的目的就是让这个自定义View随着手指在屏幕上的滑动而滑动。初始化时显示效果如下图所示。 layout方法 我们知道，在View进行绘制时，会调用onLayout()方法来设置显示的位置。同样，可以通过修改View的left，top，right，bottom四个属性来控制View的坐标。与前面提供的模板代码一样，在每次回调onTouchEvent的时候，我们都来获取一下触摸点的坐标，代码如下所示。12int x = (int) event.getX();int y = (int) event.getY(); 接着，在ACTION_DOWN事件中记录触摸点的坐标，代码如下所示。 12345case MotionEvent.ACTION_DOWN: // 记录触摸点坐标 lastX = x; lastY = y; break; 最后，可以在ACTION_MOVE事件中计算偏移量，并将偏移量作用到Layout的left，top，right，bottom基础上，增加计算出来的偏移量，代码如下所示。 12345678910case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY; // 在当前left、top、right、bottom的基础上加上偏移量 layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY); break; 这样每次移动后，View都会调用Layout方法来对自己重新布局，从而达到移动View的效果。 在上面的代码中，使用的是getX()、getY()方法来获取坐标值，即通过视图坐标来获取偏移量。当然，同样可以使用getRawX()、getRawY()来获取坐标，并使用绝对坐标来计算偏移量，代码如下所示。 1234567891011121314151617181920212223242526@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; int rawX = (int) event.getRawX(); int rawY = (int) event.getRawY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录触摸点坐标 lastX = rawX; lastY = rawY; break; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = rawX - lastX; int offsetY = rawY - lastY; // 在当前left、top、right、bottom的基础上加上偏移量 layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY); // 重新设置初始坐标 lastX = rawX; lastY = rawY; break; &#125; return true;&#125; 使用绝对坐标系，有一点非常需要注意的地方，就是在每次执行完ACTION_MOVE的逻辑后，一定要重新设置初始坐标，这样才能准确地获取偏移量，两种方式的不同点一定要自己想清楚原因哦。 offsetLeftAndRight()与offsetTopAndBottom() 这个方法相当于系统提供的一个对左右、上下移动的API的封装。当计算出偏移量后，只需要使用如下代码就可以完成View的重新布局，效果与使用Layout方法一样，代码如下所示。 1234// 同时对left和right进行偏移offsetLeftAndRight(offsetX);// 同时对top和bottom进行偏移offsetTopAndBottom(offsetY); 这里的offsetX、offSetY与在Layout方法中计算offset方法一样，这里就不重复了。 LayoutParams LayoutParams保存了一个View的布局参数。因此可以在程序中，通过改变LayoutParams来动态地修改一个布局的位置参数，从而达到改变View位置的效果。我们可以很方便地在程序中使用getLayoutParams()来获取一个View的LayouParams。当然，计算偏移量的方法与在Layout方法中计算offset也是一样。当获取到偏移量之后，就可以通过setLayoutParams来改变其LayoutParams，代码如下所示。 1234LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) getLayoutParams();layoutParams.leftMargin = getLeft() + offsetX;layoutParams.topMargin = getTop() + offsetY;setLayoutParams(layoutParams); 不过这里需要注意的是，通过getLayoutParams()获取LayoutParams时，需要根据View所在父布局的类型来设置不同的类型，比如这里将View放在LinearLayout中，那么就可以使用LinearLayout.LayoutParams。类似地，如果在RelativeLayout中，就要使用RelativeLayout.LayoutParams。当然，这一切的前提是你必须要有一个父布局，不然系统不法获取LayoutParams。 在通过改变LayoutParams来改变一个View的位置时，通常改变的是这个View的Margin属性，所以除了使用布局的LayoutParams之后，还可以使用ViewGroup.MarginLayoutParams来实现这样一个功能，代码如下所示。 1234ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();layoutParams.leftMargin = getLeft() + offsetX;layoutParams.topMargin = getTop() + offsetY;setLayoutParams(layoutParams); 我们可以发现，使用ViewGroup.MarginLayoutParams更加的方便，不需要考虑父布局的类型，当然他们的本质都是一样的。 scrollTo与scrollBy 在一个View中，系统提供了scrollTo、scrollBy两种方式来改变一个View的位置。这两个方法的区别非常好理解，与英文的To与By的区别类似，scrollTo(x, y)表示移动到一个具体的坐标点(x, y)，而scrollBy(dx, dy) 表示移动的增量为dx、dy。 与前面几种方式不同，在获取偏移量后使用scrollBy来移动View，代码如下所示。 123int offsetX = x - lastX;int offsetY = y - lastY;scrollBy(offsetX, offsetY); 但是，当我们拖动View的时候，你会发现View并没有移动！难道是我们方法写错了吗？其实，方法没有写错，View也确实移动了，只是它移动的并不是我们想要移动的东西。scrollTo、scrollBy方法移动的都View的content，即让View的内容移动，如果在ViewGroup中使用scrollTo、scrollBy方法，那么移动的将是所有子View，但如果在View中使用，那么移动的将是View的内容，例如TextView，content就是它的文本；ImageView，content就是它的drawable对象。 相信通过上面的分析，读者朋友应该知道为什么不能在View中使用这个两个方法来拖动这个View了。那么我们就该View所在的ViewGroup中来视同scrollBy方法，移动它的子View，代码如下所示。 1((View) getParent()).scrollBy(offsetX, offsetY); 但是，当再次拖动View的时候，你会发现View虽然移动了，但却在乱动，并不是我们想要的跟随触摸点的移动而移动。这里需要先了解一下视图移动的一些知识。大家在理解这个问题的时候，不妨这样想象手机屏幕是一个中空的盖板，盖板下面是一个巨大的画布，也就是我们想要显示的视图。当把这个盖板盖在画布上的某一处时，透过中间空的矩形，我们看见了手机屏幕上的视图，而画布在其他地方的视图，则被盖板盖住了无法看见。我们的视图与这个例子非常类似，我们没有看见视图，并不代表它就不存在，有可能只是在屏幕外面而已。当调用scrollBy方法时，可以想象为外面的盖板在移动，这么说比较抽象，来看一个具体的例子，如下图所示。 在上图中，中间的矩形相当于屏幕，即可视区域。后面的content就相当于画布，代表视图。大家可以看到，只有视图的中间部分目前是可视的，其他部分都不可见。在可见区域中，我们设置了一个Button，它的坐标是(20,10)。 下面使用scrollBy方法，将盖板(屏幕、可视区域)，在水平方向上向X轴正方向(右方)平移20，在竖直方向上向Y轴正方向(下方)平移10，那么平移后的可视区域如下图所示。 我们可以发现，虽然设置scrollBy(20, 10)，偏移量均为X轴、Y轴正方向上的正数，但是在屏幕的可视区域内，Button却向X轴、Y轴负方向上移动了。这就是因为参考系选择的不同，而产生的不同效果。 通过上面的分析可以发现，如果将scrollBy中的参数dx和dy设置为正数，那么content将向坐标轴负方向移动；如果将scrollBy中的参数dx和dy设置为负数，那么content将向坐标轴正方向移动。因此回到前面的例子，要实现跟随手指移动而滑动的效果，就必须将偏移量改为负值，代码如下所示。 123int offsetX = x - lastX;int offsetY = y - lastY;((View) getParent()).scrollBy(-offsetX, -offsetY); 再去试验一下，大家就可以发现，效果与前面几种方式的效果相同了。类似地，在使用绝对坐标时，也可以通过scrollTo方法来实现这一效果。 Scroller 既然提到了scrollTo、scrollBy方法，就不得不再来说一说Scroller类。Scroller类与scrollTo、scrollBy方法十分相似，有着千丝万缕的联系。那么它们之间具体有什么区别呢？要解答这个问题，首先来看一个小例子。假如要完成这样一个效果：通过点击按钮，让一个ViewGroup的子View向右移动100个像素。问题看似非常简单，只要在按钮的点击事件中使用前面讲的scrollBy方法设置下偏移量不就可以了吗？的确，通过这样一个方法可以让ViewGroup中的子View平移。但是读者朋友可以发现，不管使用scrollTo还是scrollBy方法，子View的平移都是瞬间发生的，在事件执行的时候平移就已经完成了，这样的效果会让人感觉非常突兀。Google建议使用自然的过度动画来实现移动效果，当然也要遵循这一原则。因此，Scroller类就这样应运而生了，通过Scroller类可以实现平滑移动的效果，而不再是瞬间完成的移动。 说到Scroller类的实现原理，其实它与前面使用scrollTo和scrollBy方法来实现子View跟随手指移动的原理基本类似。虽然scrollBy方法是让子View瞬间从某点移动到另一个点，但是由于在ACTION_MOVE事件中不断获取手指移动的微小的偏移量，这样就将一段距离划分成了N个非常小的偏移量。虽然在每个偏移量里面，通过scrollBy方法进行了瞬间移动，但是在整体上却可以获得一个平滑移动的效果。这个原理与动画的实现原理基本类似，他们都是利用了人眼的视觉暂留特性。 下面我们就演示一下如何使用Scroller类实现平滑移动。在这个实例中，同样让子View跟随手指的滑动而滑动，但是在手指离开屏幕时，让子View平滑地移动到初始位置，即屏幕左上角。一般情况下，使用Scroller类需要如下三个步骤。 初始化Scroller 首先，通过它的构造方法来创建一个Scroller对象，代码如下所示。12// 初始化ScrollermScroller = new Scroller(context); 重写computeScroll()方法，实现模拟滚动 下面我们需要重写computeScroll()方法，它是使用Scroller类的核心，系统在绘制View的时候会在draw()方法中调用该方法。这个方法实际上就是使用scrollTo方法。再结合Scroller对象，帮助获取到当前的滚动值。我们可以通过不断地瞬间移动一个小的距离来实现整体上的平滑移动效果。通常情况下，computeScroll的代码可以利用如下模板代码来实现。 123456789101112@Overridepublic void computeScroll() &#123; super.computeScroll(); // 判断Scroller是否执行完毕 if (mScroller.computeScrollOffset()) &#123; ((View) getParent()).scrollTo( mScroller.getCurrX(), mScroller.getCurrY()); // 通过重绘来不断调用computeScroll invalidate(); &#125;&#125; Scroller类提供了computeScrollOffset()方法来判断是否完成了整个滑动，同时也提供了getCurrX()、getCurrY()方法来获取当前滑动坐标。在上面的代码中，唯一需要注意的是invalidate()方法，因为只能在computeScroll()方法中获取模拟过程中的scrollX和scrollY坐标。但computeScroll()方法是不会自动调用的，只能通过invalidate()→draw()→computeScroll()来间接调用computeScroll()方法，所以需要在模板代码中调用invalidate()方法，实现循环获取scrollX和scrollY的目的。而当模拟过程结束后，scroller.computeScrollOffset()方法会返回false，从而中断循环，完成整个平滑移动过程。 startScroll开启模拟过程 最后，万事俱备只欠东风。我们在需要使用平滑移动事件中，使用Scroller类的startScroll()方法来开启平滑移动过程。startScroll()方法具有两个重载方法。 public void startScroll(int startX, int startY, int dx, int dy, int duration) public void startScroll(int startX, int startY, int dx, int dy) 可以看到他们的区别就是一个具有指定的持续时长，而另一个没有。这个非常好理解，与在动画中设置durarion和使用默认的显示时长是一个道理。而其他四个坐标，则与它们的命名含义相同，就是起始坐标与偏移量。在获取坐标时，通常可以使用getScrollX()和getScrollerY()方法来获取父视图中content所滑动到的电的坐标，不过要注意的是这个值的正负，它与在scrollBy和scrollTo中讲解的情况是一样的。 通过上面三个步骤，我们就可以使用Scroller类来实现平滑移动了，下面回到实例中，在构造方法中初始化Scroller对象，并重写View的computeScroll()方法。最后，需要监听手指离开屏幕的事件，并在该事件中通过调用startScroll()方法完成平滑移动。那么要监听手指离开屏幕的事件，只需要在onTouchEvent中增加一个ACTION_UP监听选项即可，代码如下所示。 123456789case MotionEvent.ACTION_UP: // 手指离开时，执行滑动过程 View viewGroup = ((View) getParent()); mScroller.startScroll( viewGroup.getScrollX(), viewGroup.getScrollY(), -viewGroup.getScrollX(), -viewGroup.getScrollY()); invalidate(); 在startScroll()方法中，我们获取子View移动的距离——getScrollX()、getScrollY()，并将偏移量设置为其相反数，从而将子View滑动到原来位置。这里需要注意的还是invalidate()方法，需要使用这个方法来通知View进行重绘，从而来调用conputeScroll()的模拟过程。当然，也可以给startScroll()方法增加一个duration的参数来设置滑动的持续时长。 属性动画 为视图增加位移动画，视图进行位移偏移后，利用视图动画在松手后视图回到原处，具体代码如下所示。 1234567891011121314151617181920212223242526272829@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录触摸点坐标 lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: // 计算偏移量 int offsetX = x - lastX; int offsetY = y - lastY;// 同时对left和right进行偏移 offsetLeftAndRight(offsetX); // 同时对top和bottom进行偏移 offsetTopAndBottom(offsetY); break; case MotionEvent.ACTION_UP: // 手指离开时，执行滑动过程 ObjectAnimator animator1 = ObjectAnimator.ofFloat(this, "translationX", -getLeft()); ObjectAnimator animator2 = ObjectAnimator.ofFloat(this, "translationY", -getTop()); AnimatorSet set = new AnimatorSet(); set.playTogether(animator1, animator2); set.start(); break; &#125; return true;&#125; ViewDragHelper Google在其support库中为我们提供了DrawerLayout和SlidingPaneLayout两个布局来帮助开发者实现侧边栏滑动的效果。这两个新的布局，大大方便了我们创建自己的滑动布局界面。然而，这两个功能强大的布局背后，却隐藏着一个鲜为人知却功能强大的类——ViewDragHelper。通过ViewDragHelper，基本可以实现各种不同的滑动、拖放需求，因此这个方法也是各种滑动方案中的终极绝招。 ViewDragHelper虽然功能强大，但其使用方法也是这次最复杂的。读者朋友需要在理解ViewDragHelper基本使用方法的基础上，通过不断练习来掌握它的技巧。下面通过一个实例，来演示一下如何使用ViewDragHelper创建一个滑动布局。在这个例子中，准备实现类似QQ滑动侧边栏的布局，初始时显示内容界面，当用户手指滑动超过一段距离时，内容界面侧滑显示菜单界面，整个过程如下图所示。 下面来看具体的代码是如何实现的。 初始化ViewDragHelper 首先，自然是需要初始化ViewDragHelper。ViewDragHelper通常定义在一个ViewGroup的内部，并通过其静态工厂方法进行初始化，代码如下所示。 1mViewDragHelper = ViewDragHelper.create(this, callback); 它的第一个参数是要监听的View，通常需要是一个ViewGroup，即parentView；第二个参数是一个Callback回调，这个回调就是整个ViewDragHelper的逻辑核心，后面再来详细讲解。 拦截事件 接下来，要重写事件拦截方法，将事件传递给ViewDragHelper进行处理，代码如下所示。 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return super.onInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 将触摸事件传递给ViewDragHelper，此操作必不可少 mViewDragHelper.processTouchEvent(event); return true;&#125; 这一点我们在讲Android事件机制的时候已经进行了详细讲解，这里就不再重复了。 处理computeScroll 没错，使用ViewDragHelper同样需要重写下computeScroll()方法，因为ViewDragHelper内部也是通过Scroller来实现平滑移动的。通常情况下，可以使用如下所示的模板代码。 123456@Overridepublic void computeScroll() &#123; if (mViewDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125; 处理回调Callback 下面就是最关键的Callback实现，通过如下所示代码来创建一个ViewDragHelper.Callback。 123456private ViewDragHelper.Callback callback = new ViewDragHelper.Callback() &#123; @Override public boolean tryCaptureView(View child, int pointerId) &#123; return false; &#125;&#125;; IDE自动帮我们重写了一个方法——tryCaptureView()。通过这个方法，我们可以指定在创建ViewDragHelper时，参数parentView中哪一个子View可以被移动，例如在这个实例中自定义了一个ViewGroup，里面定义了两个子View——MenuView和MainView，当指定如下代码时，则只有MainView是可以被拖动的。 123456// 何时开始检测触摸事件@Overridepublic boolean tryCaptureView(View child, int pointerId) &#123; // 如果当前触摸的child是mMainView时开始检测 return mMainView == child;&#125; 下面来看具体的滑动方法——clampViewPositionVertical()和clampViewPositionHorizontal()，分别对应垂直和水平方向上的滑动。如果要实现滑动效果，那么这两个方法是必须要重写的。因为它默认的返回值是0，即不发生滑动。当然，如果只重写clampViewPositionVertical()或clampViewPositionHorizontal()中的一个，那么就只会实现该方向上的滑动效果了，代码如下所示。 12345678@Overridepublic int clampViewPositionVertical(View child, int top, int dy) &#123; return top;&#125;@Overridepublic int clampViewPositionHorizontal(View child, int left, int dx) &#123; return left;&#125; clampViewPositionVertical(View child, int top, int dy)中的参数top，代表在垂直方向上child移动的距离，而dy则表示比较前一次的增量。同理，clampViewPositionHorizontal(View child, int left, int dx)也是类似的含义。通常情况下，只需要返回top和left即可，但当需要更加精确地计算padding等属性的时候，就需要对left进行一些处理，并返回合适大小的值。 仅仅是通过重写上面的这三个方法，就可以实现一个最基本的滑动效果了。当用手拖动MainView的时候，它就可以跟随手指的滑动而滑动了，代码如下所示。 12345678910111213141516private ViewDragHelper.Callback callback = new ViewDragHelper.Callback() &#123; // 何时开始检测触摸事件 @Override public boolean tryCaptureView(View child, int pointerId) &#123; // 如果当前触摸的child是mMainView时开始检测 return mMainView == child; &#125; @Override public int clampViewPositionVertical(View child, int top, int dy) &#123; return 0; &#125; @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; return left; &#125;&#125;; 下面继续来优化这个实例。在讲解Scroller类时，曾实现了这样一个效果——在手指离开屏幕后，子View滑动回初始位置。当时我们是通过监听ACTION_UP事件，并通过调用Scroller类来实现的，这里使用ViewDragHelper来实现这样的效果。在ViewDragHelper.Callback中，系统提供了这样的方法——onViewReleased()，通过重写这个方法，可以非常简单地实现当手指离开屏幕后实现的操作。当然，这个方法内部是通过Scroller类来实现的，这也是前面重写computeScroll()方法的原因，这部分代码如下所示。 123456789101112131415// 拖动结束后调用@Overridepublic void onViewReleased(View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel); // 手指抬起后缓慢移动到指定位置 if (mMainView.getLeft() &lt; 500) &#123; // 关闭菜单 // 相当于Scroller的startScroll方法 mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0); &#125; else &#123; // 打开菜单 mViewDragHelper.smoothSlideViewTo(mMainView, 300, 0); &#125; ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);&#125; 设置让MainView移动后左边距小于500像素的时候，就是用smoothSlideViewTo()方法来将MainView还原到初始状态，即坐标为(0, 0)的点。而当其左边距大于500的时候，则将MainView移动到(300, 0)坐标，即显示MenuView。读者朋友可以发现如下所示的这两行代码，与在使用Scroller类的时候使用的startScroll()方法是不是非常像呢？ 1234567// ViewDragHelpermViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);// ScrollmScroller.startScroll(x, y, dx, dy);invalidate(); 通过前面一步步的分析，现在要实现类似QQ侧滑菜单的效果，是不是就非常简单了呢？下面自定义一个ViewGroup来完成整个实例的编写。滑动的处理部分前面已经讲解过了，在自定义ViewGroup的onFInishInflate()方法中，按顺序将子View分别定义成MenuView和MainView，并在onSizeChanged()方法中获得View的宽度。如果你需要根据View的宽度来处理滑动后的效果，就可以使用这个值来进行判断。这部分代码如下所示。 1234567891011@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); mMenuView = getChildAt(0); mMainView = getChildAt(1);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = mMenuView.getMeasuredWidth();&#125; 最后，整个通过ViewDragHelper实现QQ侧滑功能的完整代码参考项目地址即可。 当然，这里只是非常简单地模拟了QQ侧滑菜单这个功能。ViewDragHelper的很多强大功能还没能够得到展示。在ViewDragHelper.Callback中，系统定义了大量的监听事件来帮助我们吹各种事件，下面就列举一些事件。 onViewCaptured() 这个事件在用户触摸到View后调用。 onViewDragStateChanged() 这个事件在拖拽状态改变时回调，比如idle，dragging等状态。 onViewPositionChanged() 这个事件在位置改变时回调，常用于滑动时更改scale进行缩放等效果。 使用ViewDragHelper可以帮助我们非常好地处理程序中的滑动效果。但同时ViewDragHelper的使用也比较复杂，需要开发者对事件拦截、滑动处理都有比较清楚的认识。所以建议初学者循序渐进，在掌握前面几种解决方案的基础上，再来学习ViewDragHelper，以实现更加丰富的滑动效果。 项目地址→AchieveScroll 原文地址实现滑动的七种方法(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>5.Android Scroll分析</category>
      </categories>
      <tags>
        <tag>5.Android Scroll分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发人员不得不收集的代码(持续更新中)]]></title>
    <url>%2F2016%2F07%2F31%2Fandroid-utils-code%2F</url>
    <content type="text"><![CDATA[![logo][logo] DownloadGradle:1234implementation 'com.blankj:utilcode:1.25.8'// if u use AndroidX, use the followingimplementation 'com.blankj:utilcodex:1.25.8' APIs Activity 相关 -&gt; ActivityUtils.java -&gt; Demo123456789101112131415161718getActivityByView : 根据视图获取 ActivitygetActivityByContext : 根据上下文获取 ActivityisActivityExists : 判断 Activity 是否存在startActivity : 启动 ActivitystartActivityForResult : 启动 Activity 为返回结果startActivities : 启动多个 ActivitystartHomeActivity : 回到桌面getActivityList : 获取 Activity 栈链表getLauncherActivity : 获取启动项 ActivitygetMainActivities : 获取主的 Activity 们getTopActivity : 获取栈顶 ActivityisActivityAlive : 判断 Activity 是否存活isActivityExistsInStack : 判断 Activity 是否存在栈中finishActivity : 结束 ActivityfinishToActivity : 结束到指定 ActivityfinishOtherActivities : 结束所有其他类型的 ActivityfinishAllActivities : 结束所有 ActivityfinishAllActivitiesExceptNewest: 结束除最新之外的所有 Activity AdaptScreen 相关 -&gt; AdaptScreenUtils.java -&gt; Demo12345adaptWidth : 适配宽度adaptHeight: 适配高度closeAdapt : 关闭适配（pt 等同于 dp）pt2Px : pt 转 pxpx2Pt : px 转 pt Api 相关 -&gt; ApiUtils.java -&gt; README1getApi: 获取 api 的实例 App 相关 -&gt; AppUtils.java -&gt; Demo123456789101112131415161718192021222324252627registerAppStatusChangedListener : 注册 App 前后台切换监听器unregisterAppStatusChangedListener: 注销 App 前后台切换监听器installApp : 安装 App（支持 8.0）uninstallApp : 卸载 AppisAppInstalled : 判断 App 是否安装isAppRoot : 判断 App 是否有 root 权限isAppDebug : 判断 App 是否是 Debug 版本isAppSystem : 判断 App 是否是系统应用isAppForeground : 判断 App 是否处于前台isAppRunning : 判断 App 是否运行launchApp : 打开 ApprelaunchApp : 重启 ApplaunchAppDetailsSettings : 打开 App 具体设置exitApp : 关闭应用getAppIcon : 获取 App 图标getAppPackageName : 获取 App 包名getAppName : 获取 App 名称getAppPath : 获取 App 路径getAppVersionName : 获取 App 版本号getAppVersionCode : 获取 App 版本码getAppSignature : 获取 App 签名getAppSignatureSHA1 : 获取应用签名的的 SHA1 值getAppSignatureSHA256 : 获取应用签名的的 SHA256 值getAppSignatureMD5 : 获取应用签名的的 MD5 值getAppInfo : 获取 App 信息getAppsInfo : 获取所有已安装 App 信息getApkInfo : 获取 Apk 信息 数组相关 -&gt; ArrayUtils.java -&gt; Test123456789101112131415161718192021222324252627282930313233newArray : 新建数组newLongArray : 新建长整型数组newIntArray : 新建整型数组newShortArray : 新建 short 数组newCharArray : 新建字符数组newByteArray : 新建字节数组newDoubleArray : 新建双精度数组newFloatArray : 新建浮点数数组newBooleanArray : 新建 boolean 数组isEmpty : 判断数组是否为空getLength : 获取数组长度isSameLength : 判断两数组长度是否相等get : 获取数组的索引值set : 设置数组的索引值equals : 判断数组是否相等reverse : 逆序数组copy : 拷贝数组subArray : 截取数组add : 增加数组remove : 移除指定的索引removeElement : 移除指定的元素indexOf : 查找第一个元素的索引lastIndexOf : 查找最后一个元素的索引contains : 判断是否包含该元素toPrimitive : 装箱数组转基本类型数组toObject : 基本类型数组转装箱数组asList : 转为链表asUnmodifiableList: 转为不可变链表asArrayList : 转为数组链表asLinkedList : 转为双向链表sort : 排序forAllDo : 对所有元素做操作toString : 数组转为字符串 栏相关 -&gt; BarUtils.java -&gt; Demo12345678910111213141516getStatusBarHeight : 获取状态栏高度（px）setStatusBarVisibility : 设置状态栏是否可见isStatusBarVisible : 判断状态栏是否可见setStatusBarLightMode : 设置状态栏是否为浅色模式addMarginTopEqualStatusBarHeight : 为 view 增加 MarginTop 为状态栏高度subtractMarginTopEqualStatusBarHeight: 为 view 减少 MarginTop 为状态栏高度setStatusBarColor : 设置状态栏颜色setStatusBarColor4Drawer : 为 DrawerLayout 设置状态栏颜色getActionBarHeight : 获取 ActionBar 高度setNotificationBarVisibility : 设置通知栏是否可见getNavBarHeight : 获取导航栏高度setNavBarVisibility : 设置导航栏是否可见isNavBarVisible : 判断导航栏是否可见setNavBarColor : 设置导航栏颜色getNavBarColor : 获取导航栏颜色isSupportNavBar : 判断是否支持导航栏 亮度相关 -&gt; BrightnessUtils.java -&gt; Demo123456isAutoBrightnessEnabled : 判断是否开启自动调节亮度setAutoBrightnessEnabled: 设置是否开启自动调节亮度getBrightness : 获取屏幕亮度setBrightness : 设置屏幕亮度setWindowBrightness : 设置窗口亮度getWindowBrightness : 获取窗口亮度 Bus 相关 -&gt; BusUtils.java -&gt; README123456register : 注册unregister : 注销post : 发送postSticky : 发送粘性removeSticky: 移除粘性toString_ : 查看插入的信息 磁盘缓存相关 -&gt; CacheDiskStaticUtils.java -&gt; Test1234567891011121314setDefaultCacheDiskUtils: 设置默认磁盘缓存实例put : 缓存中写入数据getBytes : 缓存中读取字节数组getString : 缓存中读取 StringgetJSONObject : 缓存中读取 JSONObjectgetJSONArray : 缓存中读取 JSONArraygetBitmap : 缓存中读取 BitmapgetDrawable : 缓存中读取 DrawablegetParcelable : 缓存中读取 ParcelablegetSerializable : 缓存中读取 SerializablegetCacheSize : 获取缓存大小getCacheCount : 获取缓存个数remove : 根据键值移除缓存clear : 清除所有缓存 磁盘缓存相关 -&gt; CacheDiskUtils.java -&gt; Test1234567891011121314getInstance : 获取缓存实例Instance.put : 缓存中写入数据Instance.getBytes : 缓存中读取字节数组Instance.getString : 缓存中读取 StringInstance.getJSONObject : 缓存中读取 JSONObjectInstance.getJSONArray : 缓存中读取 JSONArrayInstance.getBitmap : 缓存中读取 BitmapInstance.getDrawable : 缓存中读取 DrawableInstance.getParcelable : 缓存中读取 ParcelableInstance.getSerializable: 缓存中读取 SerializableInstance.getCacheSize : 获取缓存大小Instance.getCacheCount : 获取缓存个数Instance.remove : 根据键值移除缓存Instance.clear : 清除所有缓存 二级缓存相关 -&gt; CacheDoubleStaticUtils.java -&gt; Test123456789101112131415setDefaultCacheDoubleUtils: 设置默认二级缓存实例put : 缓存中写入数据getBytes : 缓存中读取字节数组getString : 缓存中读取 StringgetJSONObject : 缓存中读取 JSONObjectgetJSONArray : 缓存中读取 JSONArraygetBitmap : 缓存中读取 BitmapgetDrawable : 缓存中读取 DrawablegetParcelable : 缓存中读取 ParcelablegetSerializable : 缓存中读取 SerializablegetCacheDiskSize : 获取磁盘缓存大小getCacheDiskCount : 获取磁盘缓存个数getCacheMemoryCount : 获取内存缓存个数remove : 根据键值移除缓存clear : 清除所有缓存 二级缓存相关 -&gt; CacheDoubleUtils.java -&gt; Test123456789101112131415getInstance : 获取缓存实例Instance.put : 缓存中写入数据Instance.getBytes : 缓存中读取字节数组Instance.getString : 缓存中读取 StringInstance.getJSONObject : 缓存中读取 JSONObjectInstance.getJSONArray : 缓存中读取 JSONArrayInstance.getBitmap : 缓存中读取 BitmapInstance.getDrawable : 缓存中读取 DrawableInstance.getParcelable : 缓存中读取 ParcelableInstance.getSerializable : 缓存中读取 SerializableInstance.getCacheDiskSize : 获取磁盘缓存大小Instance.getCacheDiskCount : 获取磁盘缓存个数Instance.getCacheMemoryCount: 获取内存缓存个数Instance.remove : 根据键值移除缓存Instance.clear : 清除所有缓存 内存缓存相关 -&gt; CacheMemoryStaticUtils.java -&gt; Test123456setDefaultCacheMemoryUtils: 设置默认内存缓存实例put : 缓存中写入数据get : 缓存中读取字节数组getCacheCount : 获取缓存个数remove : 根据键值移除缓存clear : 清除所有缓存 内存缓存相关 -&gt; CacheMemoryUtils.java -&gt; Test123456getInstance : 获取缓存实例Instance.put : 缓存中写入数据Instance.get : 缓存中读取字节数组Instance.getCacheCount: 获取缓存个数Instance.remove : 根据键值移除缓存Instance.clear : 清除所有缓存 清除相关 -&gt; CleanUtils.java -&gt; Demo1234567cleanInternalCache : 清除内部缓存cleanInternalFiles : 清除内部文件cleanInternalDbs : 清除内部数据库cleanInternalDbByName: 根据名称清除数据库cleanInternalSp : 清除内部 SPcleanExternalCache : 清除外部缓存cleanCustomDir : 清除自定义目录下的文件 点击相关 -&gt; ClickUtils.java -&gt; Demo12345applyScale : 应用点击缩放applySingleDebouncing : 对单视图应用防抖点击applyGlobalDebouncing : 对所有设置 GlobalDebouncing 的视图应用防抖点击ClickUtils#OnDebouncingClickListener: 防抖点击监听器ClickUtils#OnMultiClickListener : 连续点击监听器 克隆相关 -&gt; CloneUtils.java -&gt; Test1deepClone: 深度克隆 关闭相关 -&gt; CloseUtils.java12closeIO : 关闭 IOcloseIOQuietly: 安静关闭 IO 集合相关 -&gt; CollectionUtils.java -&gt; Test123456789101112131415161718192021222324252627282930313233343536newUnmodifiableList[NotNull]: 新建只读[非空]链表newArrayList[NotNull] : 新建数组型[非空]链表newLinkedList[NotNull] : 新建指针型[非空]链表newHashSet[NotNull] : 新建哈希[非空]集合newTreeSet[NotNull] : 新建有序[非空]集合newSynchronizedCollection : 新建同步集合newUnmodifiableCollection : 新建只读集合union : 获取并集intersection : 获取交集disjunction : 获取并集减交集subtract : 获取差集containsAny : 判断是否有交集getCardinalityMap : 获取集合中所有元素的基数isSubCollection : 是否子集isProperSubCollection : 是否真子集isEqualCollection : 判断集合是否相等cardinality : 获取集合中元素的基数find : 查找第一个符合条件的元素forAllDo : 对所有元素做操作filter : 删除原集合中不符合条件的元素select : 查找出所有符合条件的元素并返回新集合selectRejected : 查找出所有不符合条件的元素并返回新集合transform : 对原集合进行转变collect : 转变为新的集合countMatches : 查找到匹配的元素个数exists : 判断集合是否存在符合条件的元素addIgnoreNull : 新增元素如果不为空addAll : 新增多个元素get : 获取集合元素size : 获取集合个数sizeIsEmpty : 判断个数是否为零isEmpty : 判断是否为空isNotEmpty : 判断是否非空retainAll : 保留元素removeAll : 删除下来toString : 集合转为字符串 颜色相关 -&gt; ColorUtils.java123456789getColor : 获取颜色setAlphaComponent: 设置颜色透明度值setRedComponent : 设置颜色红色值setGreenComponent: 设置颜色绿色值setBlueComponent : 设置颜色蓝色值string2Int : 颜色串转颜色值int2RgbString : 颜色值转 RGB 串int2ArgbString : 颜色值转 ARGB 串getRandomColor : 获取随机色 转换相关 -&gt; ConvertUtils.java -&gt; Test123456789101112131415161718bytes2Bits, bits2Bytes : bytes 与 bits 互转bytes2Chars, chars2Bytes : bytes 与 chars 互转bytes2HexString, hexString2Bytes : bytes 与 hexString 互转memorySize2Byte, byte2MemorySize : 以 unit 为单位的内存大小与字节数互转byte2FitMemorySize : 字节数转合适内存大小timeSpan2Millis, millis2TimeSpan : 以 unit 为单位的时间长度与毫秒时间戳互转millis2FitTimeSpan : 毫秒时间戳转合适时间长度input2OutputStream, output2InputStream : inputStream 与 outputStream 互转inputStream2Bytes, bytes2InputStream : inputStream 与 bytes 互转outputStream2Bytes, bytes2OutputStream : outputStream 与 bytes 互转inputStream2String, string2InputStream : inputStream 与 string 按编码互转outputStream2String, string2OutputStream: outputStream 与 string 按编码互转bitmap2Bytes, bytes2Bitmap : bitmap 与 bytes 互转drawable2Bitmap, bitmap2Drawable : drawable 与 bitmap 互转drawable2Bytes, bytes2Drawable : drawable 与 bytes 互转view2Bitmap : view 转 Bitmapdp2px, px2dp : dp 与 px 互转sp2px, px2sp : sp 与 px 互转 崩溃相关 -&gt; CrashUtils.java1init: 初始化 设备相关 -&gt; DeviceUtils.java -&gt; Demo12345678910111213isDeviceRooted : 判断设备是否 rootedisAdbEnabled : 判断设备 ADB 是否可用getSDKVersionName: 获取设备系统版本号getSDKVersionCode: 获取设备系统版本码getAndroidID : 获取设备 AndroidIDgetMacAddress : 获取设备 MAC 地址getManufacturer : 获取设备厂商getModel : 获取设备型号getABIs : 获取设备 ABIsisTablet : 判断是否是平板isEmulator : 判断是否是模拟器getUniqueDeviceId: 获取唯一设备 IDisSameDevice : 判断是否同一设备 闪光灯相关 -&gt; FlashlightUtils.java -&gt; Demo1234isFlashlightEnable : 判断设备是否支持闪光灯isFlashlightOn : 判断闪光灯是否打开setFlashlightStatus: 设置闪光灯状态destroy : 销毁 编码解码相关 -&gt; EncodeUtils.java -&gt; Test1234567urlEncode : URL 编码urlDecode : URL 解码base64Encode : Base64 编码base64Encode2String: Base64 编码base64Decode : Base64 解码htmlEncode : Html 编码htmlDecode : Html 解码 加密解密相关 -&gt; EncryptUtils.java -&gt; Test12345678910111213141516171819202122encryptMD2, encryptMD2ToString : MD2 加密encryptMD5, encryptMD5ToString : MD5 加密encryptMD5File, encryptMD5File2String : MD5 加密文件encryptSHA1, encryptSHA1ToString : SHA1 加密encryptSHA224, encryptSHA224ToString : SHA224 加密encryptSHA256, encryptSHA256ToString : SHA256 加密encryptSHA384, encryptSHA384ToString : SHA384 加密encryptSHA512, encryptSHA512ToString : SHA512 加密encryptHmacMD5, encryptHmacMD5ToString : HmacMD5 加密encryptHmacSHA1, encryptHmacSHA1ToString : HmacSHA1 加密encryptHmacSHA224, encryptHmacSHA224ToString : HmacSHA224 加密encryptHmacSHA256, encryptHmacSHA256ToString : HmacSHA256 加密encryptHmacSHA384, encryptHmacSHA384ToString : HmacSHA384 加密encryptHmacSHA512, encryptHmacSHA512ToString : HmacSHA512 加密encryptDES, encryptDES2HexString, encryptDES2Base64 : DES 加密decryptDES, decryptHexStringDES, decryptBase64DES : DES 解密encrypt3DES, encrypt3DES2HexString, encrypt3DES2Base64: 3DES 加密decrypt3DES, decryptHexString3DES, decryptBase64_3DES : 3DES 解密encryptAES, encryptAES2HexString, encryptAES2Base64 : AES 加密decryptAES, decryptHexStringAES, decryptBase64AES : AES 解密encryptRSA, encryptRSA2HexString, encryptRSA2Base64 : RSA 加密decryptRSA, decryptHexStringRSA, decryptBase64RSA : RSA 解密 文件相关 -&gt; FileIOUtils.java -&gt; Test1234567891011writeFileFromIS : 将输入流写入文件writeFileFromBytesByStream : 将字节数组写入文件writeFileFromBytesByChannel: 将字节数组写入文件writeFileFromBytesByMap : 将字节数组写入文件writeFileFromString : 将字符串写入文件readFile2List : 读取文件到字符串链表中readFile2String : 读取文件到字符串中readFile2BytesByStream : 读取文件到字节数组中readFile2BytesByChannel : 读取文件到字节数组中readFile2BytesByMap : 读取文件到字节数组中setBufferSize : 设置缓冲区尺寸 文件相关 -&gt; FileUtils.java -&gt; Test12345678910111213141516171819202122232425262728293031323334getFileByPath : 根据文件路径获取文件isFileExists : 判断文件是否存在rename : 重命名文件isDir : 判断是否是目录isFile : 判断是否是文件createOrExistsDir : 判断目录是否存在，不存在则判断是否创建成功createOrExistsFile : 判断文件是否存在，不存在则判断是否创建成功createFileByDeleteOldFile : 判断文件是否存在，存在则在创建之前删除copyDir : 复制目录copyFile : 复制文件moveDir : 移动目录moveFile : 移动文件delete : 删除文件或目录deleteDir : 删除目录deleteFile : 删除文件deleteAllInDir : 删除目录下所有东西deleteFilesInDir : 删除目录下所有文件deleteFilesInDirWithFilter: 删除目录下所有过滤的文件listFilesInDir : 获取目录下所有文件listFilesInDirWithFilter : 获取目录下所有过滤的文件getFileLastModified : 获取文件最后修改的毫秒时间戳getFileCharsetSimple : 简单获取文件编码格式getFileLines : 获取文件行数getDirSize : 获取目录大小getFileSize : 获取文件大小getDirLength : 获取目录长度getFileLength : 获取文件长度getFileMD5 : 获取文件的 MD5 校验码getFileMD5ToString : 获取文件的 MD5 校验码getDirName : 根据全路径获取最长目录getFileName : 根据全路径获取文件名getFileNameNoExtension : 根据全路径获取文件名不带拓展名getFileExtension : 根据全路径获取文件拓展名notifySystemToScan : 通知系统扫描文件 Fragment 相关 -&gt; FragmentUtils.java -&gt; Demo123456789101112131415161718192021222324add : 新增 fragmentshow : 显示 fragmenthide : 隐藏 fragmentshowHide : 先显示后隐藏 fragmentreplace : 替换 fragmentpop : 出栈 fragmentpopTo : 出栈到指定 fragmentpopAll : 出栈所有 fragmentremove : 移除 fragmentremoveTo : 移除到指定 fragmentremoveAll : 移除所有 fragmentgetTop : 获取顶部 fragmentgetTopInStack : 获取栈中顶部 fragmentgetTopShow : 获取顶部可见 fragmentgetTopShowInStack : 获取栈中顶部可见 fragmentgetFragments : 获取同级别的 fragmentgetFragmentsInStack : 获取同级别栈中的 fragmentgetAllFragments : 获取所有 fragmentgetAllFragmentsInStack: 获取栈中所有 fragmentfindFragment : 查找 fragmentdispatchBackPress : 处理 fragment 回退键setBackgroundColor : 设置背景色setBackgroundResource : 设置背景资源setBackground : 设置背景 Gson 相关 -&gt; GsonUtils.java -&gt; Test12345678getGson : 获取 Gson 对象toJson : 对象转 Json 串fromJson : Json 串转对象getListType : 获取链表类型getSetType : 获取集合类型getMapType : 获取字典类型getArrayType: 获取数组类型getType : 获取类型 图片相关 -&gt; ImageUtils.java -&gt; Demo1234567891011121314151617181920212223242526272829bitmap2Bytes, bytes2Bitmap : bitmap 与 bytes 互转drawable2Bitmap, bitmap2Drawable: drawable 与 bitmap 互转drawable2Bytes, bytes2Drawable : drawable 与 bytes 互转view2Bitmap : view 转 bitmapgetBitmap : 获取 bitmapscale : 缩放图片clip : 裁剪图片skew : 倾斜图片rotate : 旋转图片getRotateDegree : 获取图片旋转角度toRound : 转为圆形图片toRoundCorner : 转为圆角图片addCornerBorder : 添加圆角边框addCircleBorder : 添加圆形边框addReflection : 添加倒影addTextWatermark : 添加文字水印addImageWatermark : 添加图片水印toAlpha : 转为 alpha 位图toGray : 转为灰度图片fastBlur : 快速模糊renderScriptBlur : renderScript 模糊图片stackBlur : stack 模糊图片save : 保存图片isImage : 根据文件名判断文件是否为图片getImageType : 获取图片类型compressByScale : 按缩放压缩compressByQuality : 按质量压缩compressBySampleSize : 按采样大小压缩getSize : 获取图片尺寸 意图相关 -&gt; IntentUtils.java12345678910isIntentAvailable : 判断意图是否可用getInstallAppIntent : 获取安装 App（支持 6.0）的意图getUninstallAppIntent : 获取卸载 App 的意图getLaunchAppIntent : 获取打开 App 的意图getLaunchAppDetailsSettingsIntent: 获取 App 具体设置的意图getShareTextIntent : 获取分享文本的意图getShareImageIntent : 获取分享图片的意图getComponentIntent : 获取其他应用组件的意图getShutdownIntent : 获取关机的意图getCaptureIntent : 获取拍照的意图 键盘相关 -&gt; KeyboardUtils.java -&gt; Demo123456789showSoftInput : 显示软键盘hideSoftInput : 隐藏软键盘toggleSoftInput : 切换键盘显示与否状态isSoftInputVisible : 判断软键盘是否可见registerSoftInputChangedListener : 注册软键盘改变监听器unregisterSoftInputChangedListener: 注销软键盘改变监听器fixAndroidBug5497 : 修复安卓 5497 BUGfixSoftInputLeaks : 修复软键盘内存泄漏clickBlankArea2HideSoftInput : 点击屏幕空白区域隐藏软键盘 语言相关 -&gt; LanguageUtils.java -&gt; Demo12applySystemLanguage: 应用系统语言applyLanguage : 应用语言 日志相关 -&gt; LogUtils.java -&gt; Demo1234567891011121314151617181920212223242526272829303132getConfig : 获取 log 配置Config.setLogSwitch : 设置 log 总开关Config.setConsoleSwitch : 设置 log 控制台开关Config.setGlobalTag : 设置 log 全局 tagConfig.setLogHeadSwitch : 设置 log 头部信息开关Config.setLog2FileSwitch : 设置 log 文件开关Config.setDir : 设置 log 文件存储目录Config.setFilePrefix : 设置 log 文件前缀Config.setBorderSwitch : 设置 log 边框开关Config.setSingleTagSwitch: 设置 log 单一 tag 开关（为美化 AS 3.1 的 Logcat）Config.setConsoleFilter : 设置 log 控制台过滤器Config.setFileFilter : 设置 log 文件过滤器Config.setStackDeep : 设置 log 栈深度Config.setStackOffset : 设置 log 栈偏移Config.setSaveDays : 设置 log 可保留天数Config.addFormatter : 新增 log 格式化器log : 自定义 tag 的 type 日志v : tag 为类名的 Verbose 日志vTag : 自定义 tag 的 Verbose 日志d : tag 为类名的 Debug 日志dTag : 自定义 tag 的 Debug 日志i : tag 为类名的 Info 日志iTag : 自定义 tag 的 Info 日志w : tag 为类名的 Warn 日志wTag : 自定义 tag 的 Warn 日志e : tag 为类名的 Error 日志eTag : 自定义 tag 的 Error 日志a : tag 为类名的 Assert 日志aTag : 自定义 tag 的 Assert 日志file : log 到文件json : log 字符串之 jsonxml : log 字符串之 xml Map 相关 -&gt; MapUtils.java -&gt; Test1234567891011newUnmodifiableMap: 创建 UnmodifiableMapnewHashMap : 创建 HashMapnewLinkedHashMap : 创建 LinkedHashMapnewTreeMap : 创建 TreeMapnewHashTable : 创建 HashTableisEmpty : 判断 Map 是否为空isNotEmpty : 判断 Map 是否非空size : 获取 Map 元素个数forAllDo : 对所有元素做操作transform : 对 Map 做转变toString : Map 转为字符串 MetaData 相关 -&gt; MetaDataUtils.java -&gt; Demo1234getMetaDataInApp : 获取 application 的 meta-data 值getMetaDataInActivity: 获取 activity 的 meta-data 值getMetaDataInService : 获取 service 的 meta-data 值getMetaDataInReceiver: 获取 receiver 的 meta-data 值 网络相关 -&gt; NetworkUtils.java -&gt; Demo12345678910111213141516171819202122openWirelessSettings : 打开网络设置界面isConnected : 判断网络是否连接isAvailable[Async] : 判断网络是否可用isAvailableByPing[Async] : 用 ping 判断网络是否可用isAvailableByDns[Async] : 用 DNS 判断网络是否可用getMobileDataEnabled : 判断移动数据是否打开isMobileData : 判断网络是否是移动数据is4G : 判断网络是否是 4GgetWifiEnabled : 判断 wifi 是否打开setWifiEnabled : 打开或关闭 wifiisWifiConnected : 判断 wifi 是否连接状态isWifiAvailable[Async] : 判断 wifi 数据是否可用getNetworkOperatorName : 获取移动网络运营商名称getNetworkType : 获取当前网络类型getIPAddress[Async] : 获取 IP 地址getDomainAddress[Async] : 获取域名 IP 地址getIpAddressByWifi : 根据 WiFi 获取网络 IP 地址getGatewayByWifi : 根据 WiFi 获取网关 IP 地址getNetMaskByWifi : 根据 WiFi 获取子网掩码 IP 地址getServerAddressByWifi : 根据 WiFi 获取服务端 IP 地址registerNetworkStatusChangedListener : 注册网络状态改变监听器unregisterNetworkStatusChangedListener: 注销网络状态改变监听器 对象相关 -&gt; ObjectUtils.java -&gt; Test123456isEmpty : 判断对象是否为空isNotEmpty : 判断对象是否非空equals : 判断对象是否相等requireNonNull: 检查对象非空getOrDefault : 获取非空或默认对象hashCode : 获取对象哈希值 路径相关 -&gt; PathUtils.java -&gt; Demo123456789101112131415161718192021222324252627282930313233343536getRootPath : 获取根路径getDataPath : 获取数据路径getDownloadCachePath : 获取下载缓存路径getInternalAppDataPath : 获取内存应用数据路径getInternalAppCodeCacheDir : 获取内存应用代码缓存路径getInternalAppCachePath : 获取内存应用缓存路径getInternalAppDbsPath : 获取内存应用数据库路径getInternalAppDbPath : 获取内存应用数据库路径getInternalAppFilesPath : 获取内存应用文件路径getInternalAppSpPath : 获取内存应用 SP 路径getInternalAppNoBackupFilesPath: 获取内存应用未备份文件路径getExternalStoragePath : 获取外存路径getExternalMusicPath : 获取外存音乐路径getExternalPodcastsPath : 获取外存播客路径getExternalRingtonesPath : 获取外存铃声路径getExternalAlarmsPath : 获取外存闹铃路径getExternalNotificationsPath : 获取外存通知路径getExternalPicturesPath : 获取外存图片路径getExternalMoviesPath : 获取外存影片路径getExternalDownloadsPath : 获取外存下载路径getExternalDcimPath : 获取外存数码相机图片路径getExternalDocumentsPath : 获取外存文档路径getExternalAppDataPath : 获取外存应用数据路径getExternalAppCachePath : 获取外存应用缓存路径getExternalAppFilesPath : 获取外存应用文件路径getExternalAppMusicPath : 获取外存应用音乐路径getExternalAppPodcastsPath : 获取外存应用播客路径getExternalAppRingtonesPath : 获取外存应用铃声路径getExternalAppAlarmsPath : 获取外存应用闹铃路径getExternalAppNotificationsPath: 获取外存应用通知路径getExternalAppPicturesPath : 获取外存应用图片路径getExternalAppMoviesPath : 获取外存应用影片路径getExternalAppDownloadPath : 获取外存应用下载路径getExternalAppDcimPath : 获取外存应用数码相机图片路径getExternalAppDocumentsPath : 获取外存应用文档路径getExternalAppObbPath : 获取外存应用 OBB 路径 权限相关 -&gt; PermissionUtils.java -&gt; Demo123456789101112getPermissions : 获取应用权限isGranted : 判断权限是否被授予isGrantedWriteSettings : 判断修改系统权限是否被授予requestWriteSettings : 申请修改系统权限isGrantedDrawOverlays : 判断悬浮窗权限是否被授予requestDrawOverlays : 申请悬浮窗权限launchAppDetailsSettings: 打开应用具体设置permission : 设置请求权限rationale : 设置拒绝权限后再次请求的回调接口callback : 设置回调theme : 设置主题request : 开始请求 手机相关 -&gt; PhoneUtils.java -&gt; Demo12345678910111213isPhone : 判断设备是否是手机getDeviceId : 获取设备码getSerial : 获取序列号getIMEI : 获取 IMEI 码getMEID : 获取 MEID 码getIMSI : 获取 IMSI 码getPhoneType : 获取移动终端类型isSimCardReady : 判断 sim 卡是否准备好getSimOperatorName : 获取 Sim 卡运营商名称getSimOperatorByMnc: 获取 Sim 卡运营商名称dial : 跳至拨号界面call : 拨打 phoneNumbersendSms : 跳至发送短信界面 进程相关 -&gt; ProcessUtils.java -&gt; Demo12345getForegroundProcessName : 获取前台线程包名killAllBackgroundProcesses: 杀死所有的后台服务进程killBackgroundProcesses : 杀死后台服务进程isMainProcess : 判断是否运行在主进程getCurrentProcessName : 获取当前进程名称 反射相关 -&gt; ReflectUtils.java -&gt; Test12345reflect : 设置要反射的类newInstance: 实例化反射对象field : 设置反射的字段method : 设置反射的方法get : 获取反射想要获取的 正则相关 -&gt; RegexUtils.java -&gt; Test1234567891011121314151617isMobileSimple : 简单验证手机号isMobileExact : 精确验证手机号isTel : 验证电话号码isIDCard15 : 验证身份证号码 15 位isIDCard18 : 简单验证身份证号码 18 位isIDCard18Exact: 精确验证身份证号码 18 位isEmail : 验证邮箱isURL : 验证 URLisZh : 验证汉字isUsername : 验证用户名isDate : 验证 yyyy-MM-dd 格式的日期校验，已考虑平闰年isIP : 验证 IP 地址isMatch : 判断是否匹配正则getMatches : 获取正则匹配的部分getSplits : 获取正则匹配分组getReplaceFirst: 替换正则匹配的第一部分getReplaceAll : 替换所有正则匹配的部分 资源相关 -&gt; ResourceUtils.java -&gt; Demo123456copyFileFromAssets: 从 assets 中拷贝文件readAssets2String : 从 assets 中读取字符串readAssets2List : 从 assets 中按行读取字符串copyFileFromRaw : 从 raw 中拷贝文件readRaw2String : 从 raw 中读取字符串readRaw2List : 从 raw 中按行读取字符串 Rom 相关 -&gt; RomUtils.java -&gt; Demo123456789101112131415161718192021isHuawei : 是否华为isVivo : 是否 VIVOisXiaomi : 是否小米isOppo : 是否 OPPOisLeeco : 是否乐视is360 : 是否 360isZte : 是否中兴isOneplus : 是否一加isNubia : 是否努比亚isCoolpad : 是否酷派isLg : 是否 LGisGoogle : 是否谷歌isSamsung : 是否三星isMeizu : 是否魅族isLenovo : 是否联想isSmartisan: 是否锤子isHtc : 是否 HTCisSony : 是否索尼isGionee : 是否金立isMotorola : 是否摩托罗拉getRomInfo : 获取 ROM 信息 屏幕相关 -&gt; ScreenUtils.java -&gt; Demo12345678910111213141516171819getScreenWidth : 获取屏幕的宽度（单位：px）getScreenHeight : 获取屏幕的高度（单位：px）getAppScreenWidth : 获取应用屏幕的宽度（单位：px）getAppScreenHeight : 获取应用屏幕的高度（单位：px）getScreenDensity : 获取屏幕密度getScreenDensityDpi: 获取屏幕密度 DPIsetFullScreen : 设置屏幕为全屏setNonFullScreen : 设置屏幕为非全屏toggleFullScreen : 切换屏幕为全屏与否状态isFullScreen : 判断屏幕是否为全屏setLandscape : 设置屏幕为横屏setPortrait : 设置屏幕为竖屏isLandscape : 判断是否横屏isPortrait : 判断是否竖屏getScreenRotation : 获取屏幕旋转角度screenShot : 截屏isScreenLock : 判断是否锁屏setSleepDuration : 设置进入休眠时长getSleepDuration : 获取进入休眠时长 SD 卡相关 -&gt; SDCardUtils.java -&gt; Demo123isSDCardEnableByEnvironment: 根据 Environment 判断 SD 卡是否可用getSDCardPathByEnvironment : 根据 Environment 获取 SD 卡路径getSDCardInfo : 获取 SD 卡信息 服务相关 -&gt; ServiceUtils.java123456getAllRunningServices: 获取所有运行的服务startService : 启动服务stopService : 停止服务bindService : 绑定服务unbindService : 解绑服务isServiceRunning : 判断服务是否运行 Shell 相关 -&gt; ShellUtils.java1execCmd[Async]: 执行命令 尺寸相关 -&gt; SizeUtils.java1234567dp2px, px2dp : dp 与 px 转换sp2px, px2sp : sp 与 px 转换applyDimension : 各种单位转换forceGetViewSize : 在 onCreate 中获取视图的尺寸measureView : 测量视图尺寸getMeasuredWidth : 获取测量视图宽度getMeasuredHeight: 获取测量视图高度 Snackbar 相关 -&gt; SnackbarUtils.java -&gt; Demo123456789101112131415with : 设置 snackbar 依赖 viewsetMessage : 设置消息setMessageColor: 设置消息颜色setBgColor : 设置背景色setBgResource : 设置背景资源setDuration : 设置显示时长setAction : 设置行为setBottomMargin: 设置底边距show : 显示 snackbarshowSuccess : 显示预设成功的 snackbarshowWarning : 显示预设警告的 snackbarshowError : 显示预设错误的 snackbardismiss : 消失 snackbargetView : 获取 snackbar 视图addView : 添加 snackbar 视图 SpannableString 相关 -&gt; SpanUtils.java -&gt; Demo1234567891011121314151617181920212223242526272829303132with : 设置控件setFlag : 设置标识setForegroundColor: 设置前景色setBackgroundColor: 设置背景色setLineHeight : 设置行高setQuoteColor : 设置引用线的颜色setLeadingMargin : 设置缩进setBullet : 设置列表标记setFontSize : 设置字体尺寸setFontProportion : 设置字体比例setFontXProportion: 设置字体横向比例setStrikethrough : 设置删除线setUnderline : 设置下划线setSuperscript : 设置上标setSubscript : 设置下标setBold : 设置粗体setItalic : 设置斜体setBoldItalic : 设置粗斜体setFontFamily : 设置字体系列setTypeface : 设置字体setAlign : 设置对齐setClickSpan : 设置点击事件setUrl : 设置超链接setBlur : 设置模糊setShader : 设置着色器setShadow : 设置阴影setSpans : 设置样式append : 追加样式字符串appendLine : 追加一行样式字符串appendImage : 追加图片appendSpace : 追加空白create : 创建样式字符串 SP 相关 -&gt; SPStaticUtils.java -&gt; Demo1234567891011setDefaultSPUtils: 设置默认 SP 实例put : SP 中写入数据getString : SP 中读取 StringgetInt : SP 中读取 intgetLong : SP 中读取 longgetFloat : SP 中读取 floatgetBoolean : SP 中读取 booleangetAll : SP 中获取所有键值对contains : SP 中是否存在该 keyremove : SP 中移除该 keyclear : SP 中清除所有数据 SP 相关 -&gt; SPUtils.java1234567891011getInstance : 获取 SP 实例Instance.put : SP 中写入数据Instance.getString : SP 中读取 StringInstance.getInt : SP 中读取 intInstance.getLong : SP 中读取 longInstance.getFloat : SP 中读取 floatInstance.getBoolean: SP 中读取 booleanInstance.getAll : SP 中获取所有键值对Instance.contains : SP 中是否存在该 keyInstance.remove : SP 中移除该 keyInstance.clear : SP 中清除所有数据 字符串相关 -&gt; StringUtils.java -&gt; Test123456789101112isEmpty : 判断字符串是否为 null 或长度为 0isTrimEmpty : 判断字符串是否为 null 或全为空格isSpace : 判断字符串是否为 null 或全为空白字符equals : 判断两字符串是否相等equalsIgnoreCase: 判断两字符串忽略大小写是否相等null2Length0 : null 转为长度为 0 的字符串length : 返回字符串长度upperFirstLetter: 首字母大写lowerFirstLetter: 首字母小写reverse : 反转字符串toDBC : 转化为半角字符toSBC : 转化为全角字符 线程相关 -&gt; ThreadUtils.java -&gt; Test1234567891011121314151617181920212223242526isMainThread : 判断当前是否主线程getFixedPool : 获取固定线程池getSinglePool : 获取单线程池getCachedPool : 获取缓冲线程池getIoPool : 获取 IO 线程池getCpuPool : 获取 CPU 线程池executeByFixed : 在固定线程池执行任务executeByFixedWithDelay : 在固定线程池延时执行任务executeByFixedAtFixRate : 在固定线程池按固定频率执行任务executeBySingle : 在单线程池执行任务executeBySingleWithDelay: 在单线程池延时执行任务executeBySingleAtFixRate: 在单线程池按固定频率执行任务executeByCached : 在缓冲线程池执行任务executeByCachedWithDelay: 在缓冲线程池延时执行任务executeByCachedAtFixRate: 在缓冲线程池按固定频率执行任务executeByIo : 在 IO 线程池执行任务executeByIoWithDelay : 在 IO 线程池延时执行任务executeByIoAtFixRate : 在 IO 线程池按固定频率执行任务executeByCpu : 在 CPU 线程池执行任务executeByCpuWithDelay : 在 CPU 线程池延时执行任务executeByCpuAtFixRate : 在 CPU 线程池按固定频率执行任务executeByCustom : 在自定义线程池执行任务executeByCustomWithDelay: 在自定义线程池延时执行任务executeByCustomAtFixRate: 在自定义线程池按固定频率执行任务cancel : 取消任务的执行setDeliver : 设置任务结束后交付的线程 时间相关 -&gt; TimeUtils.java -&gt; Test123456789101112131415161718192021222324252627millis2String : 将时间戳转为时间字符串string2Millis : 将时间字符串转为时间戳string2Date : 将时间字符串转为 Date 类型date2String : 将 Date 类型转为时间字符串date2Millis : 将 Date 类型转为时间戳millis2Date : 将时间戳转为 Date 类型getTimeSpan : 获取两个时间差（单位：unit）getFitTimeSpan : 获取合适型两个时间差getNowMills : 获取当前毫秒时间戳getNowString : 获取当前时间字符串getNowDate : 获取当前 DategetTimeSpanByNow : 获取与当前时间的差（单位：unit）getFitTimeSpanByNow : 获取合适型与当前时间的差getFriendlyTimeSpanByNow: 获取友好型与当前时间的差getMillis : 获取与给定时间等于时间差的时间戳getString : 获取与给定时间等于时间差的时间字符串getDate : 获取与给定时间等于时间差的 DategetMillisByNow : 获取与当前时间等于时间差的时间戳getStringByNow : 获取与当前时间等于时间差的时间字符串getDateByNow : 获取与当前时间等于时间差的 DateisToday : 判断是否今天isLeapYear : 判断是否闰年getChineseWeek : 获取中式星期getUSWeek : 获取美式式星期getValueByCalendarField : 根据日历字段获取值getChineseZodiac : 获取生肖getZodiac : 获取星座 吐司相关 -&gt; ToastUtils.java -&gt; Demo12345678910setGravity : 设置吐司位置setBgColor : 设置背景颜色setBgResource : 设置背景资源setMsgColor : 设置消息颜色setMsgTextSize : 设置消息字体大小showShort : 显示短时吐司showLong : 显示长时吐司showCustomShort: 显示短时自定义吐司showCustomLong : 显示长时自定义吐司cancel : 取消吐司显示 URI 相关 -&gt; UriUtils.java12file2Uri: file 转 uriuri2File: uri 转 file 震动相关 -&gt; VibrateUtils.java -&gt; Demo12vibrate: 震动cancel : 取消 压缩相关 -&gt; ZipUtils.java -&gt; Test123456zipFiles : 批量压缩文件zipFile : 压缩文件unzipFile : 解压文件unzipFileByKeyword: 解压带有关键字的文件getFilesPath : 获取压缩文件中的文件路径链表getComments : 获取压缩文件中的注释链表 打个小广告欢迎加入我的知识星球「基你太美」，我会在星球中分享 AucFrame 框架、大厂面经、AndroidUtilCode 更详尽的说明…一切我所了解的知识，你可以通过支付进入我的星球「基你太美」进行体验，加入后优先观看星球中精华的部分，如果觉得星球的内容对自身没有收益，你可以自行申请退款退出星球，也没必要加我好友；如果你已确定要留在我的星球，可以通过扫描如下二维码（备注：基你太美）加我个人微信，发送给我你的星球 ID，方便我后续拉你进群(PS：进得越早价格越便宜)。]]></content>
      <categories>
        <category>Android</category>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动效果是如何产生的(Android群英传)]]></title>
    <url>%2F2016%2F07%2F26%2Fhow-scroll-achieve-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 前言：相对于Android2.X版本中常见的长按、点击操作，滑动的操作方式具有更好的用户体验性。因此，从Android4.X版本开始，滑动操作就大量出现在了Android系统中，各种第三方应用也竞相模仿这种效果，来改善自己的应用，下面就将向大家展示如何在应用中添加滑动效果。 滑动一个View，本质上来说就是移动一个View。改变其当前所处的位置，它的原理与动画效果的实现非常相似，都是通过不断地改变View的坐标来实现这一效果。所以，要实现View的滑动，就必须监听用户触摸的事件，并根据事件传入的坐标，动态且不断地改变View的坐标，从而实现View跟随用户触摸的滑动而滑动。 在讲解如何实现滑动效果之前，需要先来了解一下Android中的窗口坐标体系和屏幕的触控事件——MotionEvent。 Android坐标系 在物理学中，要描述一个物体的运动，就必须选定一个参考系。所谓滑动，正是相对于参考系的运动。在Android中，将屏幕最左上角的顶点作为Android坐标系的原点，从这个点向右是X轴正方向，从这个点向下是Y轴的正方向，如下图所示。 系统提供了getLocationOnScreen(int location[])这样的方法来获取Android坐标系中点的位置，即该视图左上角在Android坐标系的坐标。另外，在触控事件中使用getRawX()、getRawY()方法所获得的坐标同样是Android坐标系中的坐标。 视图坐标系 Android中除了上面所说的这种坐标系之外，还有一个视图坐标系，它描述了子视图在父视图中的位置关系。这两种坐标系并不矛盾也不复杂，他们的作用是相辅相成的。与Android坐标系类似，视图坐标系同样是以原点向右为X轴正方向，以原点向下为Y轴正方向，只不过在视图坐标系中，原点不再是Android坐标系中的屏幕最左上角，而是以父视图左上角为坐标原点，如下图所示。 在触控事件中，通过getX()、getY()所获得的坐标就是视图坐标系中的坐标。 触控事件——MotionEvent 触控事件MotionEvent在用户交互中，站着举足轻重的地位，学好触控事件是掌握后序内容的基础。首先，来看看MotionEvent中封装的一些常用的事件常量，它定义了触控事件的不同类型。 1234567891011121314// 单点触摸按下动作public static final int ACTION_DOWN = 0;// 单点触摸离开动作public static final int ACTION_UP = 1;// 触摸点移动动作public static final int ACTION_MOVE = 2;// 触摸动作取消public static final int ACTION_CANCEL = 3;// 触摸动作超出边界public static final int ACTION_OUTSIDE = 4;// 多点触摸按下动作public static final int ACTION_POINTER_DOWN = 5;// 多点离开动作public static final int ACTION_POINTER_UP = 6; 通常情况下，我们会在onTouchEvent(MotionEvent event)方法中通过event.getAction()方法来获取触控事件的类型，并使用switch-case方法来进行筛选，这个代码的模式基本固定，如下所示。 123456789101112131415161718@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; // 获取当前输入点的X、Y坐标(视图坐标) int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 处理输入的按下事件 break; case MotionEvent.ACTION_MOVE: // 处理输入的移动事件 break; case MotionEvent.ACTION_UP: // 处理输入的离开事件 break; &#125; return true;&#125; 在不涉及多点操作的情况下，通常可以使用以上代码来完成触控事件的监听，不过这里只是一个代码模板，后面我们会在触控事件中完成具体的逻辑。 在Android中，系统提供了非常多的方法来获取坐标值、相对距离等。方法丰富固然好，但也给初学者带来了很多困惑，不知道在什么情况下使用什么方法，下面总结了一些API，结合Android坐标系来看看该如何使用它们，如下图所示。 这些方法可以分成如下两个类别： View提供的获取坐标方法getTop()：获取到的是View自身的顶边到其父布局顶边的距离。getLeft()：获取到的是View自身的左边到其父布局左边的距离。getRight()：获取到的是View自身的右边到其父布局左边的距离。getBottom()：获取到的是View自身的底边到其父布局顶边的距离。 MotionEvent提供的方法getX()：获取点击事件距离控件左边的距离，即视图坐标。getY()：获取点击事件距离控件顶边的距离，即视图坐标。getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标。getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标。 相信通过上图，读者们应该对MotionEvent和Android坐标系有了一个比较清楚的认识。 原文地址滑动效果是如何产生的(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>5.Android Scroll分析</category>
      </categories>
      <tags>
        <tag>5.Android Scroll分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView常用拓展(Android群英传)]]></title>
    <url>%2F2016%2F07%2F25%2FlistView-expand-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 ListView虽然使用广泛，但系统原生的ListView显然是不能满足用户在审美、功能上不断提高的需求。不过也不要紧，Android完全可以定制化，让我们非常方便地对原生ListView进行拓展、修改。于是，在开发者的创新下，ListView越来越丰富多彩，各种各样的基于原生ListView的拓展让人目不暇接。下面来看几个常用的ListView拓展。 具有弹性的ListView Android默认的ListView在滚动到顶端或者底端的时候，并没有很好的提示。在Android5.X中，Google为这样的行为只添加了一个半月形的阴影效果，如下图所示。 而在iOS系统中，列表都是具有弹性效果的，即滚动到底端或者顶端后会继续往下或者往上滑动一段距离。不得不说，这样的设计的确更加的友好，虽然不知道Google为什么不模仿这样的设计，但我们可以自己修改ListView，让ListView也可以“弹性十足”。 网上有很多通过重写ListView来实现弹性效果的方法，比如增加HeaderView或者使用ScrollView进行嵌套，方法有很多，不过这里可以使用一种非常简单的方法来实现这个效果。虽然不如那些方法可定制化高、效果丰富，但主要目的是让读者朋友们学会如何从源代码中找到问题的解决办法。 我们在查看ListView源代码的时候可以发现，ListView中有一个控制滑动到边缘的处理方法，如下所示。 12345protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) 可以看见这样一个参数：maxOverScrollY，注释中这样写道——Number of pixels to overscroll by in either direction along the Y axis。由此可以发现，虽然它的默认值是0，但其实只要修改这个参数的值，就可以让ListView具有弹性了！所以，既然我们不知道为什么Google不采用这样的修改，那我们就自己来修改一下吧。重写这个方法，并将maxOverScrollY改为设置的值——mMaxOverDistance，代码如下所示。 1234@Overrideprotected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) &#123; return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, mMaxOverDistance, isTouchEvent);&#125; 这样，通过对这个值得修改，就实现了一个具有弹性的ListView了。效果如下图所示。 当然，为了能够满足多分辨率的需求，我们可以在修改maxOverScrollY值的时候，可以通过屏幕的density来计算具体的值，让不同分辨率的弹性距离基本一致，代码如下所示。 12345private void initView() &#123; DisplayMetrics metrics = mContext.getResources().getDisplayMetrics(); float density = metrics.density; mMaxOverDistance = (int) (density * mMaxOverDistance);&#125; 自动显示、隐藏布局的ListView 相信通过Google+的朋友应该非常熟悉这样一个效果：当我们在ListView上滑动的时候，顶部的ActionBar或者Toolbar就会相应的隐藏或者显示。这样的效果一出现，各种App竞相模仿，不得不说，Google的应用一直都是Android设计的风向标。 大家可以发现，在滚动前界面上加载了上方的标题栏和右下角的悬浮编辑按钮，如下图所示。 当用户向下滚动时，标题栏和悬浮按钮消失了，让用户有更大的空间去阅读，如下图所示。 下面我们就来仿照这个例子设计一个类似的效果。 我们知道，让一个布局显示或者隐藏并带有动画效果，可以通过属性动画来很方便地实现，所以这个效果的关键就在于如何获得ListView的各种滑动事件。所以借助View的OnTouchListener接口来监听ListView的滑动，通过比较与上次坐标的大小，来判断滑动的方向，并通过滑动的方向来判断是否需要显示或隐藏对应的布局。在开始判断滑动事件之前，我们还要做一些准备工作，首先需要给ListView增加一个HeaderView，避免第一个Item被Toolbar遮挡，代码如下所示。 1234View header = new View(this);header.setLayoutParams(new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int) getResources().getDimension(R.dimen.abc_action_bar_default_height_material)));mListView.addHeaderView(header); 在代码中，通过使用abc_action_bar_default_height_material属性获取系统Actionbar的高度，并设置给HeaderView。另外，定义一个mTouchSlop变量来获取系统认为的最低滑动距离，即超过这个距离的移动，系统就将其定义为滑动状态了，对这个值得获取非常简单，代码如下所示。 1mTouchSlop = ViewConfiguration.get(this).getScaledTouchSlop(); 有了前面的准备工作，下面我们就可以判断滑动的事件了，关键代码如下所示。 1234567891011121314151617181920212223242526@Overridepublic boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mFirstY = event.getY(); break; case MotionEvent.ACTION_MOVE: mCurrentY = event.getY(); if (mCurrentY - mFirstY &gt; mTouchSlop) &#123; // down if (mShow) &#123; toolbarAnim(0); &#125; mShow = !mShow; &#125; else if (mCurrentY - mFirstY &lt; mTouchSlop) &#123; // up if (mShow) &#123; toolbarAnim(1); &#125; mShow = !mShow; &#125; break; case MotionEvent.ACTION_UP: break; &#125; return false; 代码逻辑非常简单，只是通过滑动点的坐标改变大小，来判断移动的方向，并根据移动方向来执行不同的动画效果。 有了前面的分析，实现这样一个效果就非常简单了，最后加上控制布局显示隐藏的动画，如下所示。 1234567891011121314private void toolbarAnim(int flag) &#123; if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel(); &#125; if (flag == 0) &#123; mAnimator = ObjectAnimator.ofFloat(mToolbar, "translationY", mToolbar.getTranslationY(), 0); &#125; else &#123; mAnimator = ObjectAnimator.ofFloat(mToolbar, "translationY", mToolbar.getTranslationY(), -mToolbar.getHeight()); &#125; mAnimator.start();&#125; 动画也是最简单的位移属性动画。不过这里需要说一点题外话，这里使用了Toorbar这样一个新控件，Google已经推荐它来逐渐取代ActionBar了，因为它更加灵活。但是在使用的时候，一定要注意使用的theme一定是要NoActionBar的，不然会引起冲突。同时，不要忘记引入编译，代码如下。 1234dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.4.0'&#125; 运行程序后初始状态如下图所示，Toorbar显示在最上方。 当向上滑动时，Toolbar隐藏，如下图所示。 再向下滑动时，Toolbar显示。 聊天ListView 通常我们使用的ListView的每一项都具有相同的布局，所以展现出来的时候，除了数据不同，只要你不隐藏布局，其他的布局应该都是类似的。而我们熟知的QQ、微信等聊天App，在聊天界面，会展示至少两种布局，即收到的消息和自己发送的消息，其实这样的效果也是通过ListView来实现的，下面我们就来模仿一个聊天软件的聊天列表界面，其效果如下图所示。 这样一个ListView与我们平时所使用的ListView最大的不同，就是它拥有两个不同的布局——收到的布局和发送的布局。要实现这样的效果，就需要拿ListView的Adapter“开刀”。 在定义BaseAdapter的时候，需要去重写它的getView()方法，这个方法就是用来获取布局的，那么只需要在获取布局的时候，判断一下该获取哪一种布局就可以了。而且，ListView在设计的时候就已经考虑到了这种情况，所以它提供了两个方法，代码如下所示。 12345678@Overridepublic int getItemViewType(int position) &#123; return super.getItemViewType(position);&#125;@Overridepublic int getViewTypeCount() &#123; return super.getViewTypeCount();&#125; getItemViewType()方法用来返回第position个Item是何种类型，而getViewTypeCount()方法用来返回不同布局的总数。通过这两个方法，再结合getView()方法，就可以很轻松地设计出上面的聊天布局了。 首先来实现两个布局——chat_item_itemin和chat_item_itemout。布局大同小异，只是方向上有区别。需要注意的是，显示聊天信息内容的TextView使用了9patch的图片，这种图片格式是Android中用来拉伸图片的，你可以把它想象成在某些方向上拉伸却不会失真、形变的图片就可以了，布局代码如下所示。由于in和out界面内容只是方向上的区别，这里只贴出一个布局的代码。 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center_vertical" android:orientation="horizontal" android:padding="10dp"&gt; &lt;ImageView android:id="@+id/icon_in" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" /&gt; &lt;TextView android:id="@+id/text_in" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/chatitem_in_bg" android:gravity="center" android:textSize="20sp" /&gt; &lt;/LinearLayout&gt; 同时，为了封装下聊天内容，便于在Adapter中获取数据信息，我们封装了一个Bean来保存聊天信息，代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940import android.graphics.Bitmap; /********************************************** author: Blankj on 2016/7/25 14:01 * blog: http://blankj.com* e-mail: blankj@qq.com*********************************************/public class ChatListViewBean &#123; private int type; private String text; private Bitmap icon; public ChatListViewBean() &#123; &#125; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public Bitmap getIcon() &#123; return icon; &#125; public void setIcon(Bitmap icon) &#123; this.icon = icon; &#125;&#125; 非常简单，我们只是声明了需要的信息并提供了get和set方法。 接下来，需要来完成最重要的BaseAdapter了，同样使用ViewHolder模式来提高ListView的效率，并在getView()方法中进行布局类型的判断，从而确定使用哪种布局，代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView;import android.widget.TextView; import java.util.List; /********************************************* * author: Blankj on 2016/7/25 14:01 * blog: http://blankj.com * e-mail: blankj@qq.com*********************************************/public class ChatListViewAdapter extends BaseAdapter &#123; private List&lt;ChatListViewBean&gt; mData; private LayoutInflater mInflater; public ChatListViewAdapter(Context context, List&lt;ChatListViewBean&gt; data) &#123; this.mData = data; mInflater = LayoutInflater.from(context); &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int position) &#123; return mData.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public int getItemViewType(int position) &#123; ChatListViewBean bean = mData.get(position); return bean.getType(); &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder viewHolder = null; if (convertView == null) &#123; viewHolder = new ViewHolder(); if (getItemViewType(position) == 0) &#123; convertView = mInflater.inflate(R.layout.chat_item_itemin, null); viewHolder.icon = (ImageView) convertView.findViewById(R.id.icon_in); viewHolder.text = (TextView) convertView.findViewById(R.id.text_in); &#125; else &#123; convertView = mInflater.inflate(R.layout.chat_item_itemout, null); viewHolder.icon = (ImageView) convertView.findViewById(R.id.icon_out); viewHolder.text = (TextView) convertView.findViewById(R.id.text_out); &#125; convertView.setTag(viewHolder); &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; viewHolder.icon.setImageBitmap(mData.get(position).getIcon()); viewHolder.text.setText(mData.get(position).getText()); return convertView; &#125; public final class ViewHolder &#123; public ImageView icon; public TextView text; &#125;&#125; 在以上代码中，通过在getView()中判断getItemType(position)的值来决定具体实例化哪一个布局，从而实现在一个ListView中多个布局内容的添加。最后，在测试的Activity里面添加了一些测试代码，来测试这个布局。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import android.app.Activity;import android.graphics.BitmapFactory;import android.os.Bundle;import android.widget.ListView; import java.util.ArrayList;import java.util.List; /********************************************** author: Blankj on 2016/7/25 13:30 * blog: http://blankj.com* e-mail: blankj@qq.com*********************************************/public class ChatListViewTest extends Activity &#123; private ListView mListView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_chat); mListView = (ListView) findViewById(R.id.lv_chat); ChatListViewBean bean1 = new ChatListViewBean(); bean1.setType(0); bean1.setIcon(BitmapFactory.decodeResource(getResources(), R.drawable.in_icon)); bean1.setText("Hello how are you?"); ChatListViewBean bean2 = new ChatListViewBean(); bean2.setType(1); bean2.setIcon(BitmapFactory.decodeResource(getResources(), R.drawable.out_icon)); bean2.setText("Fine thank you, and you?"); ChatListViewBean bean3 = new ChatListViewBean(); bean3.setType(0); bean3.setIcon(BitmapFactory.decodeResource(getResources(), R.drawable.in_icon)); bean3.setText("I am fine, too"); ChatListViewBean bean4 = new ChatListViewBean(); bean4.setType(1); bean4.setIcon(BitmapFactory.decodeResource(getResources(), R.drawable.out_icon)); bean4.setText("Bye bye"); ChatListViewBean bean5 = new ChatListViewBean(); bean5.setType(0); bean5.setIcon(BitmapFactory.decodeResource(getResources(), R.drawable.in_icon)); bean5.setText("See you"); List&lt;ChatListViewBean&gt; data = new ArrayList&lt;ChatListViewBean&gt;(); data.add(bean1); data.add(bean2); data.add(bean3); data.add(bean4); data.add(bean5); mListView.setAdapter(new ChatListViewAdapter(this, data)); &#125;&#125; 在测试代码中，简单地添加了一些模拟的聊天内容，并将信息封装到设置的Bean对象中，最后运行程序，即可得到之前所示的聊天效果界面。 动态改变ListView布局 通常情况下，如果要动态地改变点击Item的布局来达到一个Focus的效果，一般有两种方法。一种是将两种布局写在一起，通过控制布局的显示、隐藏，来达到切换布局的效果；另一种则是在getView()的时候，通过判断来选择加载不同的布局。两种方法各有利弊，关键还是看使用的场合。下面就以第二种方式，来演示一下这样的效果，程序运行后初始效果下图所示，第一个Item为默认Focus状态。 当点击其他Item的时候，点击的Item变为Focus状态，其他Item还原，效果如下图所示。 该效果实现的关键还是在于BaseAdapter。在这个实例中，通过如下所示的两个方法来给Item设置两种不同的布局——Focus和Normal。 12345678910111213141516171819202122private View addFocusView(int i) &#123; ImageView iv = new ImageView(mContext); iv.setImageResource(R.mipmap.ic_launcher); return iv;&#125;private View addNormalView(int i) &#123; LinearLayout layout = new LinearLayout(mContext); layout.setOrientation(LinearLayout.HORIZONTAL); ImageView iv = new ImageView(mContext); iv.setImageResource(R.drawable.in_icon); layout.addView(iv, new LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT)); TextView tv = new TextView(mContext); tv.setText(mData.get(i)); layout.addView(tv, new LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT)); layout.setGravity(Gravity.CENTER); return layout;&#125; 在这两个方法中，可以根据Item位置的不同来设置不同的显示图片等信息，但这里为了方便，就统一只显示一张图片。 下面回到BaseAdapter，在getView()方法中，通过判断点击的位置来改变相应的视图，代码如下所示。 1234567891011@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; LinearLayout layout = new LinearLayout(mContext); layout.setOrientation(LinearLayout.VERTICAL); if (mCurrentItem == position) &#123; layout.addView(addFocusView(position)); &#125; else &#123; layout.addView(addNormalView(position)); &#125; return layout;&#125; 在以上代码中，通过判断当前CurrentItem是否是点击的那个position，就可以动态控制显示的布局了。当然，仅仅这样是不够的，因为getView()是在初始化的时候调用，后面再点击Item的时候，并没有再次调用getView()。所以，必须要让ListView在点击后，再刷新一次。于是我们请出了notifyDataSetChanged()方法来帮助实现刷新布局的功能，代码如下所示。 12345678mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; mAdapter.setCurrentItem(position); mAdapter.notifyDataSetChanged(); &#125; &#125;); 项目地址→ListViewExpandation 原文地址ListView常用拓展(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>4.ListView使用技巧</category>
      </categories>
      <tags>
        <tag>4.ListView使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView常用优化技巧(Android群英传)]]></title>
    <url>%2F2016%2F07%2F24%2FlistView-skills-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 前言：ListView——列表，它作为一个非常重要的显示方式，不管是在Web中还是移动平台中，都是一个非常好的、不开或缺的展示信息的工具。在Android中，ListView控件接管了这一重担，在大量的场合下，我们都需要使用这个控件。虽然在Android 5.X时代，RecyclerView在很多地方都在逐渐取代ListView，但ListView的使用范围依然非常的广泛，它这万年老大哥的地位也不是轻易就能撼动的。下面就介绍一下ListView常用优化技巧。 使用ViewHolder模式提高效率 ViewHolder模式是提高ListView效率的一个很重要的方法。ViewHolder模式充分利用了ListView的视图缓存机制，避免了每次在调用getView()的时候都去通过findViewById()实例化控件。据测试，使用ViewHolder将提高50%以上的效率。使用ViewHolder模式来优化ListView非常简单，只需要在自定义Adapter中定义一个内部类ViewHolder，并将布局中的控件作为成员变量，代码如下所示。 1234public final class ViewHolder &#123; public ImageView img; public TextView title;&#125; 接下来，只要在getView()方法中通过视图缓存机制来重用以缓存即可，完整的使用ViewHolder创建ListView Adapter的实例代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView;import android.widget.TextView; import java.util.List; /********************************************** author: Blankj on 2016/7/23 15:39 * blog: http://blankj.com* e-mail: blankj@qq.com*********************************************/public class ViewHolderAdapter extends BaseAdapter &#123; private List&lt;String&gt; mData; private LayoutInflater mInflater; public ViewHolderAdapter(Context context, List&lt;String&gt; data) &#123; this.mData = data; mInflater = LayoutInflater.from(context); &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int position) &#123; return mData.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder viewHolder = null; // 判断是否缓存 if (convertView == null) &#123; viewHolder = new ViewHolder(); // 通过LayoutInflater实例化布局 convertView = mInflater.inflate(R.layout.viewholder_item, null); viewHolder.img = (ImageView) convertView.findViewById(R.id.imageView); viewHolder.title = (TextView) convertView.findViewById(R.id.textView); convertView.setTag(viewHolder); &#125;else &#123; // 通过tag找到缓存的布局 viewHolder = (ViewHolder) convertView.getTag(); &#125; // 设置布局中控件要显示的视图 viewHolder.img.setBackgroundResource(R.mipmap.ic_launcher); viewHolder.title.setText(mData.get(position)); return convertView; &#125; public final class ViewHolder &#123; public ImageView img; public TextView title; &#125;&#125; 效果很简单，这就是一个简单的ListView，如下图所示。 设置项目间分隔线 ListView的各个项目之间，可以通过设置分隔线来进行区分，系统提供了divider和dividerHeight这样两个属性来帮助我们实现这一功能。通过这两个属性，也可以控制ListView之间的分隔线和它的高度。当然，分隔线不仅仅可以设置为一个颜色，同样也可以设置为一个图片资源，分隔线的使用代码如下所示。 12android:divider="@color/colorAccent"android:dividerHeight="10dp" 以上代码所实行的效果如下图所示。 特殊情况下，当设置分隔线为如下代码时，就可以把分隔线设置为透明了。 1android:divider="@null" 隐藏ListView的滚动条 默认的ListView在滚动时，在右边会显示滚动条，指示当前滑动的位置，我们可以设置scrollbars属性，控制ListView的滚动条状态。特别地，当设置scrollbars属性为none的时候，ListView滚动或者不滚动，就都不会出现滚动条了，代码如下所示。 1android:divider="@null" 取消ListView的Item点击效果 当点击ListView中的一项时，系统默认会出现一个点击效果，在Android5.X上是一个波纹效果，而在Android5.X之下的版本则是一个改变背景颜色的效果，但可以通过修改listSelector属性来取消掉点击后的回馈效果，代码如下所示。 1android:listSelector="#00000000" 当然，也可以直接使用Android自带的透明色来实现这个效果，代码如下所示。 1android:listSelector="@android:color/transparent" 设置ListView需要显示在第几项 ListView以Item为单位进行显示，默认显示在第一个Item，当需要指定具体显示的Item时，可以通过如下代码来实现。 1mListView.setSelection(N); 其中N就是需要显示的第N个Item。 当然，这个方法类似scrollTo，是瞬间完成的移动。除此以外，还可以使用如下代码来实现平滑移动。 123mListView.smoothScrollBy(distance,duration);mListView.smoothScrollByOffset(offset);mListView.smoothScrollToPosition(index); 动态修改ListView ListView中的数据在某些情况下是需要变化的，当然可以通过重新设置ListView的Adapter来更新ListView的显示，但这也就需要重新获取一下数据，相当于重新刷新创建的ListView，这样显然不是非常友好，而且效率也不会太高。因此，可以使用一个更简单的方法来实现ListView的动态修改，代码如下所示。 12mData.add("new");mAdapter.notifyDataSetChanged(); 当修改了传递给Adapter的映射List之后，只需要通过调用Adapter的notifyDataSetChanged()方法，通知ListView更改数据源即可完成对ListView的动态修改。不过，使用这个方法有一点需要注意的是，在使用mAdapter.notifyDataSetChanged()方法时，必须保证传进Adapter的数据List是同一个List而不能是其他对象，否则将无法实现该效果。下面这个实例就演示了如何动态地修改ListView。通过点击按钮，不断地给原有的List增加一个新的Item，并调用notifyDataSetChanged()方法来实现ListView的动态更新，完整代码如下所示。 123456789101112131415161718192021222324252627282930313233343536import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.ListView; import java.util.ArrayList; public class MainActivity extends AppCompatActivity &#123; ListView mListView; ViewHolderAdapter mAdapter; ArrayList&lt;String&gt; mData; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mListView = (ListView) findViewById(R.id.listView); mData = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; ++i) &#123; mData.add(i + ""); &#125; mAdapter = new ViewHolderAdapter(this, mData); mListView.setAdapter(mAdapter); mAdapter.notifyDataSetChanged(); for (int i = 0, len = mListView.getCheckedItemCount(); i &lt; len; i++) &#123; View view = mListView.getChildAt(i); &#125; &#125; public void btnAdd(View view) &#123; mData.add("new"); mAdapter.notifyDataSetChanged(); mListView.setSelection(mData.size() - 1); &#125;&#125; 实现的效果如下图所示。 遍历ListView中的所有Item ListView作为一个ViewGroup，为我们提供了操纵子View的各种方法，最常用的就是通过getChildAt()来获取第i个子View，代码如下所示。 123for (int i = 0, len = mListView.getCheckedItemCount(); i &lt; len; i++) &#123; View view = mListView.getChildAt(i);&#125; 处理空ListView ListView用于展示列表数据，但当列表中无数据时，ListView不会显示任何数据或提示，按照完善用户体验的需求，这里应该给以无数据的提示。幸好，ListView提供了一个方法——setEmptyView()，通过这个方法，我们可以给ListView设置一个在空数据下显示的默认提示。包含ListView的布局设置如下。 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.blankj.listviewskill.MainActivity"&gt; &lt;ListView android:id="@+id/listView" android:layout_width="match_parent" android:layout_height="match_parent" android:divider="@null" android:listSelector="@android:color/transparent" android:paddingBottom="40dp"/&gt; &lt;ImageView android:id="@+id/empty_view" android:layout_width="match_parent" android:layout_height="match_parent" android:src="@mipmap/ic_launcher"/&gt;&lt;/FrameLayout&gt; 在代码中，我们通过以下方式给ListView设置空数据时要显示的布局，代码如下所示。 1mListView.setEmptyView(findViewById(R.id.empty_view)); 通过以上代码，就给ListView在空数据时显示了一张默认的图片，用来提示用户；而在有数据时，则不会显示。 ListView的滑动监听 ListView的滑动监听，是ListView中最重要的技巧，很多重写的ListView基本上都是在滑动事件的处理上下功夫，通过判断滑动事件进行不同的逻辑处理。而为了更佳精确地监听滑动事件，开发者通常还需要使用GestureDetector手势识别、VelocityTracker滑动速度检测等辅助类来完成更好的监听。这里介绍两种监听ListView滑动事件的方法，一个是通过OnTouchListener来实现监听，另一个是使用OnScrollListener来实现监听。 OnTouchListener OnTouchListener是View中的监听事件，通过监听ACTION_DOWN、ACTION_MOVE、ACTION_UP这三个事件发生时的坐标，就可以根据坐标判断用户滑动的方向，并在不同的事件中进行相应的逻辑处理，这种方式的使用代码如下所示。 1234567891011121314151617mListView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 触摸时操作 break; case MotionEvent.ACTION_MOVE: // 移动时操作 break; case MotionEvent.ACTION_UP: // 离开时操作 break; &#125; return false; &#125;&#125;); OnScrollListener OnScrollListener是AbsListView中的监听事件，它封装了很多ListView相关的信息，使用起来也更加灵活。首先来看一下OnScrollListener的一般使用方法，代码如下所示。 123456789101112131415161718192021222324mListView.setOnScrollListener(new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; switch (scrollState) &#123; case SCROLL_STATE_IDLE: // 滑动停止时 Log.d("Test", "SCROLL_STATE_IDLE"); break; case SCROLL_STATE_TOUCH_SCROLL: // 正在滚动 Log.d("Test", "SCROLL_STATE_TOUCH_SCROLL"); break; case SCROLL_STATE_FLING: // 手指抛动时，即手指用力滑动 // 在离开后ListView由于惯性继续滑动 Log.d("Test", "SCROLL_STATE_FLING"); break; &#125; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; // 滚动时一直调用 Log.d("Test", "onScroll"); &#125; OnScrollListener中有两个回调方法——onScrollStateChanged()和onScroll()。 先来看第一个方法onScrollStateChanged()，这个方法根据它的参数scrollState来决定其回调的次数，scrollState有以下三种模式： SCROLL_STATE_IDLE：滚动停止时。 SCROLL_STATE_TOUCH_SCROLL：正在滚动时。 SCROLL_STATE_FLING：手指抛动时，即手指用力滑动，在离开后ListView由于惯性继续滑动 当用户没有做手指抛动的状态时，这个方法只会回调2次，否则会回调三次，差别就是手指抛动的这个状态。通常情况下，我们会在这个方法中通过不同的状态来设置一些标志Flag，来区分不同的滑动状态，供其他方法处理。 下面再来看看onScroll()这个回调方法，它在ListView滚动时会一直回调，而方法中的后三个int类型的参数，则非常精确地显示了当前ListView滚动的状态，这三个参数如下所示。 firstVisibleItem：当前能看见的第一个Item的ID(从0开始) visibleItemCount：当前能看见的Item的总数。 totalItemCount：整个ListView的Item总数。 这里需要注意的是，当前能看见的Item数，包括没有显示完整的Item，即显示一小半的Item也包括在内了。通过这几个参数，可以很方便地进行一些判断，比如判断是否滚动到最后一行，就可以使用如下代码进行判断，当前可视的另一个Item的ID加上当前可视Item的和等于Item总数的时候，即滚动到了最后一行。 123if (firstVisibleItem + visibleItemCount == totalItemCount &amp;&amp; totalItemCount &gt; 0) &#123; Log.d("Test", "滚动到最后一行");&#125; 再比如，可以通过如下代码来判断滚动的方向，代码如下所示。 123456if(firstVisibleItem &gt; lastVisibleItem)&#123; // 上滑&#125;else if(firstVisibleItem &lt; lastVisibleItem)&#123; // 下滑&#125;lastVisibleItem = firstVisibleItem; 通过一个成员变量lastVisibleItem来记录上次第一个可视的Item的ID并于当前的可视Item的ID进行比较，即可知道当前滚动的方向。 要理解整个OnScrollListener，最好的方法还是在代码中添加Log，并打印出状态信息来进行分析学习。在以上代码中，已经添加了相应的Log，对照Log进行分析，会很快掌握OnScrollListener的用法。 当然，ListView也给我们提供了一些封装的方法来获得当前可视的Item的位置等信息。 1234// 获取可视区域内最后一个Item的idmListView.getLastVisiblePosition();// 获取可视区域内第一个Item的idmListView.getFirstVisiblePosition(); 项目地址→ListViewSkill 原文地址ListView常用优化技巧(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>4.ListView使用技巧</category>
      </categories>
      <tags>
        <tag>4.ListView使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[344. Reverse String]]></title>
    <url>%2F2016%2F07%2F22%2F344-reverse-string%2F</url>
    <content type="text"><![CDATA[Total Accepted: 71392Total Submissions: 188974Difficulty: Easy Write a function that takes a string as input and returns the string reversed. Example: Given s = “hello”, return “olleh”. js字符串是引用类型，要转为值类型来处理。 JS:1234567891011121314/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseString = function(s) &#123; var arr = s.split(''); var len = arr.length; for(var i = 0;i &lt; len / 2; i++)&#123; var temp = arr[i]; arr[i] = arr[len - 1 - i]; arr[len - i - 1] = temp; &#125; return arr.join('');&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用EditText的RightDrawable切换密码显示]]></title>
    <url>%2F2016%2F07%2F21%2Fuse-editText-rightDrawable-toggle-password%2F</url>
    <content type="text"><![CDATA[相信大家都见过如下图所示的密码文本输入框，点击右方的图标便可切换为明文显示密码。 在安卓中，我们可以充分利用EditText的RightDrawable来实现这样的效果，同理一键清除也可实现，其效果图如下所示。 下面对其进行简单介绍，首先是布局文件，很简单，就一个ImageView和一个自定义的EditText，代码如下所示。12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginLeft="8dp" android:layout_marginRight="8dp"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginRight="8dp" android:background="@drawable/locked"/&gt; &lt;blankj.edittextpassword.EditTextPassword android:id="@+id/etp_input" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:background="@drawable/input" android:drawableRight="@drawable/eye_grey" android:singleLine="true" android:textColor="#ff7000" android:textCursorDrawable="@null"/&gt; &lt;/LinearLayout&gt; 再是对EditText进行拓展，首先要获取到EditText的RightDrawable，代码如下所示。 12final int DRAWABLE_RIGHT = 2;drawableRight = getCompoundDrawables()[DRAWABLE_RIGHT]; 然后定义它的回调接口和外部访问接口函数，代码如下所示。 123456public interface DrawableRightListener &#123; void onDrawableRightClick();&#125;public void setDrawableRightListener(DrawableRightListener listener) &#123; this.mRightListener = listener;&#125; 在onTouchEvent()中判断是否点击到RightDrawable来设置是否启用回调，在此还需保存光标位置，再点击完之后进行复位，优化用户体验，具体代码如下所示。 1234567891011121314151617@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; if (drawableRight != null &amp;&amp; mRightListener != null &amp;&amp; event.getAction() == MotionEvent.ACTION_UP) &#123; int x = (int) event.getX(); int y = (int) event.getY(); //判断点击是否落在rightDrawable中 if (x &gt; getWidth() - getTotalPaddingRight() &amp;&amp; x &lt; getWidth() &amp;&amp; y &gt; 0 &amp;&amp; y &lt; getHeight()) &#123; //获取点击之前光标的位置 int pos = getSelectionStart(); //设置回调 mRightListener.onDrawableRightClick(); //恢复点击之前光标的位置 this.setSelection(pos); &#125; &#125; return super.onTouchEvent(event);&#125; 最后就是在使用的地方进行定义回调函数的作用了，代码如下所示。 1234567891011121314inputETP.setDrawableRightListener(this);//同样地可以在这可以实现其他的效果，比如一键清空@Overridepublic void onDrawableRightClick() &#123; if (mIsShow) &#123; inputETP.setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.eye_grey, 0) ; inputETP.setInputType(InputType.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD); &#125; else &#123; inputETP.setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.eye_orange, 0) ; inputETP.setInputType(InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD); &#125; mIsShow = !mIsShow ;&#125; 项目地址→EditTextPassword 原文地址利用EditText的RightDrawable切换密码显示 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android</category>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件拦截机制分析(Android群英传)]]></title>
    <url>%2F2016%2F07%2F21%2Fanalyse-event-interception-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 当Android系统捕获到用户的各种输入事件后，如何准确地传递给真正需要这个事件的控件呢？Android给我们提供了一整套完善的事件传递、处理机制，来帮助开发者完成准确的事件分配与处理。 要了解触摸事件的拦截机制，首先要了解什么是触摸事件？顾名思义，触摸事件就是捕获触摸屏幕后产生的事件。当点击一个按钮时，通常就会产生两个或者三个事件——按钮按下，这是事件一；如果不小心滑动一点，这就是事件二；当手抬起，这是事件三。Android为触摸事件封装了一个类——MotionEvent，如果重写onTouchEvent()方法，那就会发现给方法的参数就是这样一个MotionEvent。其实，只要是重写触摸相关的方法，参数一般都含有MotionEvent，可见它的重要性。 在MotionEvent里面封装了不少好东西，比如触摸点的坐标，可以通过event.getX()方法和event.getRawX()方法取出坐标点；再比如获得点击的事件类型，可以通过不同的Action(如MotionEvent.ACTION_DOWN、MotionEvent.ACTION_MOVE)来进行区分，并实现不同的逻辑。 如此看来，触摸事件还是比较简单的，其实就是一个动作类型加坐标而已。但是我们知道，Android的View结构是树形结构，也就是说，View可以放在ViewGroup里面，通过不同的组合来实现不同的样式。那么问题来了，View放在一个ViewGroup里面，这个ViewGroup又放在另一个ViewGroup里面，甚至还有可能继续嵌套，一层层地叠起来。可我们的触摸事件就一个，到底该分给谁呢？同一个事件，子View和父ViewGroup都有可能想要进行处理。因此，这就产生了“事件拦截”这个“霸气”的称呼。 当然，事件拦截可以很复杂，也可以很简单。但是初学者却经常“卡”在这里不知道如何继续进行，所以我们不想通过过多的源代码让大家不知所措。我们通过最直观的Log信息，让大家先有一个大概的了解，知道事件拦截的本质，然后大家在结合源代码学习时，就可以有方向、有目的性去理解了。 首先，请想象一下生活中非常常见的场景：假设你所在的公司，有一个总经理，级别最高；他下面有一个部长，级别次之；最低层，就是干活的你，没有级别。现在董事会交给总经理一项任务，总经理将这项任务布置给了部长，部长又把任务安排给了你。而当你好不容易干完活了，你就把任务交给部长，部长觉得任务完成得不错，于是就签了他的名字交给总经理，总经理看了也觉得不错，就业签了名字交给董事会。这样，一个任务就顺利完成了。如果大家能非常清楚地理解这样一个场景，那么对于事件拦截机制，你就超过了40%的开发者了。下面，我们再来超越剩下的开发者。为了能过方便地了解整个事件的流程，我们设计了这样一个实例，如下图所示。 一个总经理——MyViewGroupA，最外层的ViewGroup（红色）。 一个部长——MyViewGroupB，中间的ViewGroup（绿色）。 一个干活的你——MyView，在最底层（蓝色）。 本实例的整个布局结构如下图所示。 代码非常简单，只是重写了事件拦截和处理的几个方法，并给它加上了一些Log而已。 对于ViewGroup来说，重写了如下所示的三个方法。 123456789101112131415@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d("blankj", "ViewGroupA dispatchTouchEvent" + ev.getAction()); return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.d("blankj", "ViewGroupA onInterceptTouchEvent" + ev.getAction()); return super.onInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.d("blankj", "ViewGroupA onTouchEvent" + event.getAction()); return super.onTouchEvent(event);&#125; 而对于View来说，重写了如下所示的两个方法。 12345678910@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.d("blankj", "View onTouchEvent" + event.getAction()); return super.onTouchEvent(event);&#125;@Overridepublic boolean dispatchTouchEvent(MotionEvent event) &#123; Log.d("blankj", "View dispatchTouchEvent" + event.getAction()); return super.dispatchTouchEvent(event);&#125; 从上面的代码中可以看到，ViewGroup级别比较高，比View多了一个方法——onInterceptTouchEvent()。这个方法看名字就能猜到是事件拦截的核心方法。我们先不修改任何返回值，只是点击一下View，然后看Log会怎样记录我们的操作和程序响应。点击View后的Log如下所示。 D/blankj: ViewGroupA dispatchTouchEvent0D/blankj: ViewGroupA onInterceptTouchEvent0D/blankj: ViewGroupB dispatchTouchEvent0D/blankj: ViewGroupB onInterceptTouchEvent0D/blankj: View dispatchTouchEvent0D/blankj: View onTouchEvent0D/blankj: ViewGroupB onTouchEvent0D/blankj: ViewGroupA onTouchEvent0 可以看见，正常情况下，时间的传递顺序是： 总经理(MyViewGroupA)→部长(MyViewGroupB)→你(View)。事件传递的时候，先执行dispatchTouchEvent()方法，再执行onInterceptTouchEvent()方法。 事件的处理顺序是： 你(View)→部长(MyViewGroupB)→总经理(MyViewGroupA)。事件处理都是执行onTouchEvent()方法。 事件传递的返回值非常容易理解：true，拦截，不继续；false，不拦截，继续流程。 事件处理的返回值也类似：true，处理了，不用审核了；false，给上级处理。 初始情况下，返回值都是false。 这里为了能够方便大家理解事件拦截的过程，在事件传递中，我们只关心onInterceptTouchEvent()，而dispatchTouchEvent()方法虽然是事件分发的第一步，但一般情况下，我们不太会去改写这个方法，所以暂时不管这个方法。可以把上面的整个事件过程整理成如下图所示的一张图。 相信大家只要把MyView想成自己，就能充分理解事件分发、拦截、处理的整个流程了。 下面我们稍微改动一下，假设总经理(MyViewGroupA)发现这个任务太简单了，觉得自己完成就可以了，完全没必要再找下属。因此时间就被总经理(MyViewGroupA)使用onInterceptTouchEvent()方法把事件给拦截了，即让MyViewGroupA的onInterceptTouchEvent()方法返回true，我们再来看一下Log。 D/blankj: ViewGroupA dispatchTouchEvent0D/blankj: ViewGroupA onInterceptTouchEvent0D/blankj: ViewGroupA onTouchEvent0 跟我们设想的一样，总经理(MyViewGroupA)把所有事情都干了，没后面人的事了。同理，我们让部长(MyViewGroupB)也来当一次好人，即让部长(MyViewGroupB)使用onInterceptTouchEvent()方法返回true，把事件拦截下来，Log就会使以下这样。 D/blankj: ViewGroupA dispatchTouchEvent0D/blankj: ViewGroupA onInterceptTouchEvent0D/blankj: ViewGroupB dispatchTouchEvent0D/blankj: ViewGroupB onInterceptTouchEvent0D/blankj: ViewGroupB onTouchEvent0D/blankj: ViewGroupA onTouchEvent0 可以看到，这次部长(MyViewGroupB)当了好人，你(MyView)就不用干活了。 那么这两种情况，也可以整理成类似如上图所示的图。 总经理(MyViewGroupA)拦截事件，如下图所示。 部长(MyViewGroupB)拦截事件，如下图所示。 对事件的分发、拦截，现在大家应该比较清楚了，下面我们再看看事件的处理。先来看看底层人民——你(MyView)。最开始的时候讲了，当你处理完任务后会向上级报告，需要上级的确认，所以你的事件处理返回false。那么你突然有一天受不了老板的压迫了，罢工不干了，那么你的任务就没人做了，也就不用报告上机了，所以就直接返回true。现在再来看看Log，如下所示。 D/blankj: ViewGroupA dispatchTouchEvent0D/blankj: ViewGroupA onInterceptTouchEvent0D/blankj: ViewGroupB dispatchTouchEvent0D/blankj: ViewGroupB onInterceptTouchEvent0D/blankj: View dispatchTouchEvent0D/blankj: View onTouchEvent0 可以看见，事件传递跟以前一样，但是事件处理，到你(MyView)这就结束了，因为你返回true，表示不用向上级汇报了。这时，我们同样来整理下关系图，如下所示。 你(MyView)终于翻身做了主，决定了自己的命运。但是，如果部长(MyViewGroupB)看到了你的报告，觉得太丢人，不敢给经理看，所以他就偷偷地返回true，整个事件也就到此为止了，即部长(MyViewGroupB)将自己的onTouchEvent返回true，Log如下所示。 D/blankj: ViewGroupA dispatchTouchEvent0D/blankj: ViewGroupA onInterceptTouchEvent0D/blankj: ViewGroupB dispatchTouchEvent0D/blankj: ViewGroupB onInterceptTouchEvent0D/blankj: View dispatchTouchEvent0D/blankj: View onTouchEvent0D/blankj: ViewGroupB onTouchEvent0 他们之间的关系图如下图所示。 通过对前面几种情况的分析，相信大家能比较容易地了解事件的分发、拦截、处理事件的流程了。在后面的学习中，结合源码，你会更加深入地理解，为什么流程会是这样的？初学者在学习的时候，最好先对流程有一个大致的认识之后，再去接触源码，这样就不会一头雾水，摸不着头脑，从而丧失学习的兴趣。 项目地址→EventIntercept 原文地址事件拦截机制分析(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义ViewGroup(Android群英传)]]></title>
    <url>%2F2016%2F07%2F20%2Fcustom-viewgroup-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 前面我们分析了如何自定义View，下面我们继续来分析如何创建自定义ViewGroup。ViewGroup存在的目的就是为了对其子View进行管理，为其子View添加显示、响应的规则。因此，自定义ViewGroup通常需要重写onMeasure()方法来对子View进行测量，重写onLayout()方法来确定子View的位置，重写onTouchEvent()方法增加响应事件。下面通过一个实例，来看看如何自定义ViewGroup。 本例准备实现一个类似Android原生控件ScrollView的自定义ViewGroup，自定义ViewGroup可以实现ScrollView所具有的上下滑动功能，但是在滑动的过程中，增加一个黏性的效果，即当一个子View向上滑动大于一定的距离后，松开手指，它将自动活动到开始的位置，相信大家在很多App应用中都看见过这样的效果。 首先让自定义ViewGroup能够实现类似ScrollView的功能。 当然，在ViewGroup能够滚动之前，需要先放置好它的子View。使用遍历的方式来通知子View对自身进行测量，代码如下所示。 123456789@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int count = getChildCount(); for (int i = 0; i &lt; count; ++i) &#123; View childView = getChildAt(i); measureChild(childView, widthMeasureSpec, heightMeasureSpec); &#125;&#125; 接下来，就要对子View进行放置位置的设定。让每个子View都显示完整的一屏，这样在滑动的时候，可以比较好地实现后面的效果。在放置子View前，需要确定整个ViewGroup的高度。在本例中，由于让每个子View占一屏的高度，因此整个ViewGroup的高度即子View的个数乘以屏幕的高度，我们通过如下代码来确定整个ViewGroup的高度。 1234// 设置ViewGroup的高度MarginLayoutParams mlp = (MarginLayoutParams) getLayoutParams();mlp.height = mScreenHeight * childCount;setLayoutParams(mlp); 在获取了整个ViewGroup的高度之后，就可以通过遍历来设定每个子View需要放置的位置了，直接通过调用子View的layout()方法，并将具体的位置作为参数传递进去即可，代码如下所示。 1234567891011121314@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); // 设置ViewGroup的高度 MarginLayoutParams mlp = (MarginLayoutParams) getLayoutParams(); mlp.height = mScreenHeight * childCount; setLayoutParams(mlp); for (int i = 0; i &lt; childCount; ++i) &#123; View child = getChildAt(i); if (child.getVisibility() != View.GONE) &#123; child.layout(l, i * mScreenHeight, r, (i + 1) * mScreenHeight); &#125; &#125;&#125; 在代码中主要是去修改每个子View的top和bottom这两个属性，让它们能依次排列下来。 通过上面的步骤，就可以将子View放置到ViewGroup中了。但此时的ViewGroup还不能响应任何触控事件，自然也不能滑动，因此我们需要重写onTouchEvent()方法，为ViewGroup添加响应事件。在ViewGroup中添加滑动事件，通常可以使用scrollBy()方法来辅助滑动。在onTouchEvent()的ACTION_MOVE事件中，只要使用scrollBy(0,dy)方法，让手指滑动的时候让ViewGroup中的所有子View也跟着滚动dy即可，计算dy的方法有很多，如下代码就提供了一种思路。 1234567891011121314case MotionEvent.ACTION_DOWN: mLastY = y; break;case MotionEvent.ACTION_MOVE: if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; int dy = mLastY - y; if (getScrollY() &lt; 0 || getScrollY() &gt; getHeight() - mScreenHeight) &#123; dy = 0; &#125; scrollBy(0, dy); mLastY = y; break; 按如上方法操作就可以实现类似ScrollView的滚动效果了。当然，系统的原生ScrollView有更大的功能，比如滑动的惯性效果等，这些功能可以在后面慢慢添加，这也是一个控件的迭代过程。 最后，我们来实现这个自定义ViewGroup的黏性效果。要实现手指离开后ViewGroup的黏性效果，我们很自然地想到onTouchEvent()的ACTION_UP事件和Scroller类。在ACTION_UP事件中判断手指滑动的距离，如果超过一定距离，则使用Scroller类来平滑移动到下一个子View；如果小于一定距离，则回滚到原来的位置，代码如下所示。 123456789101112131415161718192021222324252627282930case MotionEvent.ACTION_DOWN: // 记录触摸起点 mStart = getScrollY(); break;case MotionEvent.ACTION_UP: // 记录触摸终点 mEnd = getScrollY(); int dScrollY = mEnd - mStart; if (dScrollY &gt; 0) &#123; if (dScrollY &lt; mScreenHeight / 3) &#123; mScroller.startScroll( 0, getScrollY(), 0, -dScrollY); &#125; else &#123; mScroller.startScroll( 0, getScrollY(), 0, mScreenHeight - dScrollY); &#125; &#125; else &#123; if (-dScrollY &lt; mScreenHeight / 3) &#123; mScroller.startScroll( 0, getScrollY(), 0, -dScrollY); &#125; else &#123; mScroller.startScroll( 0, getScrollY(), 0, -mScreenHeight - dScrollY); &#125; &#125; break; 通过以上操作，我们就能在onTouchEvent()中实现滚动的逻辑和“黏性”的逻辑，整个onTouchEvent()的代码如下所示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 记录触摸起点 mStart = getScrollY(); mLastY = y; break; case MotionEvent.ACTION_MOVE: if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; int dy = mLastY - y; if (getScrollY() &lt; 0 || getScrollY() &gt; getHeight() - mScreenHeight) &#123; dy = 0; &#125; scrollBy(0, dy); mLastY = y; break; case MotionEvent.ACTION_UP: // 记录触摸终点 mEnd = getScrollY(); int dScrollY = mEnd - mStart; if (dScrollY &gt; 0) &#123; if (dScrollY &lt; mScreenHeight / 3) &#123; mScroller.startScroll( 0, getScrollY(), 0, -dScrollY); &#125; else &#123; mScroller.startScroll( 0, getScrollY(), 0, mScreenHeight - dScrollY); &#125; &#125; else &#123; if (-dScrollY &lt; mScreenHeight / 3) &#123; mScroller.startScroll( 0, getScrollY(), 0, -dScrollY); &#125; else &#123; mScroller.startScroll( 0, getScrollY(), 0, -mScreenHeight - dScrollY); &#125; &#125; break; &#125; postInvalidate(); return true;&#125; 当然，最后不要忘记加上computeScroll()的代码，如下所示。 12345678@Overridepublic void computeScroll() &#123; super.computeScroll(); if(mScroller.computeScrollOffset())&#123; scrollTo(0,mScroller.getCurrY()); postInvalidate(); &#125;&#125; 程序运行效果如下图所示。 项目地址→CustomViewGroup 原文地址自定义ViewGroup(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View(三)(Android群英传)]]></title>
    <url>%2F2016%2F07%2F20%2Fcustom-view3-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 上一篇自定义View(二)(Android群英传)中说的是创建复合控件，这篇介绍第三种自定义View方法，重写View来实现全新的控件。 重写View来实现全新的控件 当Android系统原生的控件无法满足我们的需求时，我们就可以完全创建一个新的自定义View来实现需要的功能。创建一个自定义View，难点在于绘制控件和实现交互，这也是评价一个自定义View优劣的标准之一。通常需要继承View类，并重写它的onDraw()、onMeasure()等方法来实现绘制逻辑，同时通过重写onTouchEvent()等触控事件来实现交互逻辑。当然，我们还可以像实现组合控件方式那样，通过引入自定义属性，丰富自定义View的可定制性。 下面就通过几个实例，让大家了解如何创建一个自定义View，不过为了让程序尽可能简单，我们就不去自定义属性值了。 弧线展示图 在PPT的很多模板中，都有如下图所示的这样一张比例图。 这个比例图可以非常清楚地展示一个项目所占的比例，简介明了。因此，实现这样一个自定义View用在我们的程序中，可以让整个程序实现比较清晰地数据展示效果。那么该如何创建一个这样的自定义View呢？很明显，这个自定义View其实分为三个部分，分别是中间的圆形、中间显示的文字和外圈的弧线。既然有了这样的思路，只要在onDraw()方法中一个个去绘制就可以了。这里为了简单，我们把View的绘制长度直接设置为屏幕的宽度。首先，在初始化的时候，设置好绘制三种图形的参数。圆的代码如下所示。 12mCircleXY = length / 2;mRadius = (float) (length * 0.5 / 2); 绘制弧线，需要指定其椭圆的外接矩形，代码如下所示。 12345mArcRectF = new RectF( (float) (length * 0.1), (float) (length * 0.1), (float) (length * 0.9), (float) (length * 0.9)); 绘制文字，只需要设置好文字的起始绘制位置即可。 接下来，我们就可以在onDraw()方法中进行绘制了，代码如下所示。 123456// 绘制圆canvas.drawCircle(mCircleXY, mCircleXY, mRadius, mCirclePaint);// 绘制弧线canvas.drawArc(mArcRectF, 270, mSweepAngle, false, mArcPaint);// 绘制文字canvas.drawText(mShowText, 0, mShowText.length(), mCircleXY, mCircleXY + mShowTextSize / 4, mTextPaint); 相信这些图形如果单独让你去绘制，应该是非常容易的事情，只是这里进行了一下组合，就创建了一个新的View。其实，不论是多么复杂的图形、控件，它都是由这些最基本的图形绘制出来的，关键就在于你如何去分解、设计这些图形，当你脑海中有了一幅设计图之后，剩下的事情就只是对坐标的计算了。 当然，对于这个简单的View，有一些方法可以让调用者来设置不同的状态值，代码如下所示。 12345678public void setSweepValue(float sweepValue) &#123; if (sweepValue != 0) &#123; mSweepValue = sweepValue; &#125; else &#123; mSweepValue = 25; &#125; this.invalidate();&#125; 例如，当用户不指定具体的比例值时，可以默认设置为25，而调用者可以通过如下代码来设置相应的比例值。 12CircleProgressView circle = (CircleProgressView) findViewById(R.id.circle);circle.setSweepValue(70); 音频条形图 以下这个问题来源于群里一位开发者的问题，他想实现类似在PC上某些音乐播放器上根据音频音量大小显示音频条形图，如下图所示。 如果要实现一个如下图所示的静态音频条，相信大家可以很快找到思路，也就是绘制一个个矩形，每个矩形之间稍微偏移一点距离即可。 如下代码就展示了一种计算坐标的方法。 1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); for (int i = 0; i &lt; mRectCount; ++i) &#123; canvas.drawRect(mRectWidth * i + offset, currentHeight, mRectWidth * (i + 1), mRectHeight, mPaint); &#125;&#125; 如上代码中，我们通过循环创建这些小的矩形，其中currnetHeight就是每个小矩形的高，通过横坐标的不断偏移，就绘制出了这些静态的小矩形。下面我们再让这些小矩形的高度进行随机变化，通过Math.random()方法来随机改变这些高度值，并赋值给currentHeight，代码如下所示。 12mRandom = Math.random();float currentHeight = (float) (mRectHeight * mRandom); 这样，我们就完成了静态效果的绘制，那么如何实现动态效果呢？其实非常简单，只要在onDraw()方法中再去调用invalidete()方法通知View进行重绘就可以了。不过，在这里不需要每次一绘制完新的矩形就通知View进行重绘，这样会因为刷新速度太快反而影响效果。因此，我们可以使用如下代码进行View的延迟重绘，代码如下所示。 1postInvalidateDelayed(300); 这样每隔300ms通知View进行重绘，就可以得到一个比较好的视觉效果了。最后，为了让自定义View更加逼真，可以在绘制小矩形的时候，给绘制的Paint对象增加一个LinearGradient渐变效果，这样不同高度的矩形就会有不同颜色的渐变效果，更加能够模拟音频条形图的风格，代码如下所示。 123456789101112@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getWidth(); mRectHeight = getHeight(); mRectWidth = mWidth / mRectCount; mLinearGradient = new LinearGradient(0, 0, mRectWidth, mRectHeight, Color.YELLOW, Color.GREEN, Shader.TileMode.CLAMP); mPaint.setShader(mLinearGradient);&#125; 从这个例子中，我们可以知道，在创建自定义View的时候，需要一步步来，从一个基本的效果开始，慢慢地增加功能，绘制更复杂的效果。不论是多么复杂的自定义View，它一定是慢慢迭代起来的功能，所以不要觉得自定义View有多难。千里之行始于足下，只要开始做，慢慢地就能越来越熟练。 项目地址→RewriteView 原文地址自定义View(三)(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View(二)(Android群英传)]]></title>
    <url>%2F2016%2F07%2F17%2Fcustom-view2-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 上一篇自定义View(一)(Android群英传)中说的是对现有控件进行拓展，这篇介绍第二种自定义View方法，创建复合控件。 创建复合控件 创建复合控件可以很好地创建出具有重用功能的控件集合。这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，从而组合成新的复合控件。通过这种方式创建的控件，我们一般会给它指定一些可配置的属性，让它具有更强的拓展性。下面就以一个TopBar为示例，讲解如何创建复合控件。 我们知道为了应用程序风格的统一，很多应用程序都有一些共通的UI界面，比如下图中所示的TopBar这样一个标题栏。 通常情况下，这些界面都会被抽象出来，形成一个共通的UI组件。所有需要添加标题栏的界面都会引用这样一个TopBar，而不是每个界面都在布局文件中写这样一个TopBar。同时，设计者还可以给TopBar增加响应的接口，让调用者能够更加灵活地控制TopBar，这样不仅可以提高界面的复用率，更能在需要修改UI时，做到快速修改，而不需要对每个页面的标题栏都进行修改。 下面我们就来看看该如何创建一个这样的UI模板。首先，模板应该具有通用性与可定制性。也就是说，我们需要给调用者以丰富的接口，让他们可以更改模板中的文字、颜色、行为等信息，而不是所有的模板都一样，那样就失去了模板的意义。 定义属性 为一个View提供可自定义的属性非常简单，只需要在res资源目录的values目录下创建一个attrs.xml的属性定义文件，并在该文件中通过如下代码定义相应的属性即可。 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;declare-styleable name="TopBar"&gt; &lt;attr name="_title" format="string" /&gt; &lt;attr name="_titleTextSize" format="dimension" /&gt; &lt;attr name="_titleTextColor" format="color" /&gt; &lt;attr name="leftTextColor" format="color" /&gt; &lt;attr name="leftBackground" format="reference|color" /&gt; &lt;attr name="leftText" format="string" /&gt; &lt;attr name="rightTextColor" format="color" /&gt; &lt;attr name="rightBackground" format="reference|color" /&gt; &lt;attr name="rightText" format="string" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 我们在代码中通过标签声明了使用自定义属性，并通过name属性来确定引用的名称。最后，通过标签来声明具体的自定义属性，比如在这里定义了标题文字的字体、大小、颜色，左边按钮的文字颜色、背景、字体，右边按钮的文字颜色、背景、字体等属性，并通过format属性来指定属性的类型。这里需要注意的就是，有些属性可以是颜色属性，也可以是引用属性。比如按钮的背景，可以把它指定为具体的颜色，也可以把它指定为一张图片，所以使用“|”来分隔不同的属性——“reference|color”。 在确定好属性后，就可以创建一个自定义控件—-TopBar，并让它继承自ViewGroup，从而组合一些需要的控件。这里为了简单，我们继承RelativeLayout。在构造方法中，通过如下所示代码来获取XML布局文件中自定义的那些属性，即与我们使用系统提供的那些属性一样。 1TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.TopBar); 系统提供了TypedArray这样的数据结构来获取自定义属性集，后面引用的styleable的TopBar，就是我们在XML中通过所指定的name名。接下来，通过TypedArray对象的getString()、getColor()等方法，就可以获取这些定义的属性值，代码如下所示。 1234567891011121314// 通过这个方法，将你在attrs.xml中定义的declare-styleable的所有属性值存储到TypedArray中TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.TopBar);// 从TypedArray中取出对应的值来为要设置的属性赋值mLeftTextColor = ta.getColor(R.styleable.TopBar_leftTextColor, 0);mLeftBackground = ta.getDrawable(R.styleable.TopBar_leftBackground);mLeftText = ta.getString(R.styleable.TopBar_leftText);mRightTextColor = ta.getColor(R.styleable.TopBar_rightTextColor, 0);mRightBackground = ta.getDrawable(R.styleable.TopBar_rightBackground);mRightText = ta.getString(R.styleable.TopBar_rightText);mTitleTextSize = ta.getDimension(R.styleable.TopBar__titleTextSize, 10);mTitleTextColor = ta.getColor(R.styleable.TopBar__titleTextColor, 0);mTitle = ta.getString(R.styleable.TopBar__title);// 获取完TypedArray的值后，一般要调用recycle方法来避免重新创建时的错误ta.recycle(); 这里需要注意的是，当获取完所有的属性值后，需要调用TypedArray的recycle方法来完成资源的回收。 组合控件 接下来，我们就可以开始组合控件了。UI模板TopBar实际上由三个控件组成，即左边的点击按钮mLeftButton，右边的点击按钮mRightButton和中间的标题栏mTitleView。通过动态添加控件的方式，使用addView()方法将这三个控件加入到定义的TopBar模板中，并给它们设置我们前面所获取到的具体的属性值，比如标题的文字颜色、大小等，代码如下所示。 12345678910111213141516171819202122232425262728// 为创建的组件元素赋值// 值就来源于我们在引用的xml文件中给对应属性的赋值mLeftButton.setTextColor(mLeftTextColor);mLeftButton.setBackground(mLeftBackground);mLeftButton.setText(mLeftText); mRightButton.setTextColor(mRightTextColor);mRightButton.setBackground(mRightBackground);mRightButton.setText(mRightText); mTitleView.setText(mTitle);mTitleView.setTextColor(mTitleTextColor);mTitleView.setTextSize(mTitleTextSize);mTitleView.setGravity(Gravity.CENTER); // 为组件元素设置相应的布局元素mLeftLayoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);mLeftLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_LEFT, TRUE);// 添加到ViewGroupaddView(mLeftButton, mLeftLayoutParams); mRightLayoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);mRightLayoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, TRUE);addView(mRightButton, mRightLayoutParams); mTitleLayoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);mTitleLayoutParams.addRule(RelativeLayout.CENTER_IN_PARENT, TRUE);addView(mTitleView, mTitleLayoutParams); 定义接口 在UI模板类中定义一个左右按钮点击的接口，并创建两个方法，分别用于左边按钮的点击和右边按钮的点击，代码如下所示。 12345678910// 接口对象，实现回调机制，在回调方法中// 通过映射的接口对象调用接口中的方法// 而不用去考虑如何实现，具体的实现由调用者去创建public interface topbarClickListener &#123; // 左按钮点击事件 void leftClick(); // 右按钮点击事件 void rightClick();&#125; 暴露接口给调用者 在模板方法中，为左、右按钮增加点击事件，但不去实现具体的逻辑，而是调用接口中相应的点击方法，代码如下所示。 1234567891011121314151617181920// 按钮的点击事件，不需要具体的实现，// 只需调用接口的方法，回调的时候，会有具体的实现mRightButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.rightClick(); &#125;&#125;);mLeftButton.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.leftClick(); &#125;&#125;); // 暴露一个方法给调用者来注册接口回调// 通过接口来获得回调者对接口方法的实现public void setOnTopbarClickListener(topbarClickListener mListener) &#123; this.mListener = mListener;&#125; 实现接口回调 在调用者的代码中，调用者需要实现这样一个接口，并完成接口中的方法，确定具体的实现逻辑，并使用第二步中暴露的方法，将接口的对象传递进去，从而完成回调。通常情况下，可以使用匿名内部类的形式来实现接口中的方法，代码如下所示。 1234567891011121314mTopBar.setOnTopbarClickListener(new MyTopBar.topbarClickListener() &#123; @Override public void leftClick() &#123; Toast.makeText(MainActivity.this, "left", Toast.LENGTH_SHORT) .show(); &#125; @Override public void rightClick() &#123; Toast.makeText(MainActivity.this, "right", Toast.LENGTH_SHORT) .show(); &#125;&#125;); 这里为了简单演示，只显示两个Toast来区分不同的按钮点击事件。除了通过接口回调的方式来实现动态的控制UI模板，同样可以使用公共方法来动态地修改UI模板中的UI，这样就进一步提高了模板的可定制性，代码如下所示。 123456789101112131415161718192021/*** 设置按钮的显示与否 通过id区分按钮，flag区分是否显示** @param id id* @param flag 是否显示*/public void setButtonVisable(int id, boolean flag) &#123; if (flag) &#123; if (id == 0) &#123; mLeftButton.setVisibility(View.VISIBLE); &#125; else &#123; mRightButton.setVisibility(View.VISIBLE); &#125; &#125; else &#123; if (id == 0) &#123; mLeftButton.setVisibility(View.GONE); &#125; else &#123; mRightButton.setVisibility(View.GONE); &#125; &#125;&#125; 通过如上所示代码，当调用者通过TopBar对象调用这个方法后，根据参数，调用者就可以了动态地控制按钮的显示，代码如下所示。 123// 控制topbar上组件的状态mTopBar.setButtonVisable(0, true);mTopBar.setButtonVisable(1, false); 引用UI模板 最后一步，自然是在需要使用的地方引用UI模板，在引用前，需要指定引用第三方控件的名字空间。在布局文件中，可以看到如下一行代码。 1xmlns:android="http://schemas.android.com/apk/res/android" 这行代码就是在指定引用的名字空间xmlns，即xml namespace。这里指定了名字空间为“android”，因此在接下来使用系统属性的时候，才可以使用“android:”来引用Android的系统属性。同样地，如果要使用自定义的属性，那么就需要创建自己的名字空间，在Android Studio中，第三方的控件都使用如下代码来引入名字空间。 1xmlns:custom="http://schemas.android.com/apk/res-auto" 这里我们将引入的第三方控件的名字空间取为custom，之后再XML文件中使用自定义的属性时，就可以通过这个名字空间来引用，代码如下所示。 12345678910111213&lt;cmj.com.delsys.MyTopBar android:id="@+id/topBar" android:layout_width="match_parent" android:layout_height="40dp" custom:_title="自定义标题" custom:_titleTextColor="#123412" custom:_titleTextSize="10sp" custom:leftBackground="@color/colorPrimary" custom:leftText="Back" custom:leftTextColor="#ffffff" custom:rightBackground="@color/colorPrimary" custom:rightText="More" custom:rightTextColor="#ffffff"/&gt; 使用自定义的View与系统原生的View最大的区别就是在申明控件时，需要指定完整的包名，而在引用自定义的属性时，需要使用自定义的xmlns名字。 再更进一步，如果将这个UI模板写到一个布局文件中，代码如下所示。 123456789101112131415&lt;cmj.com.delsys.MyTopBar android:id="@+id/topBar" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:custom="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="40dp" custom:_title="自定义标题" custom:_titleTextColor="#123412" custom:_titleTextSize="10sp" custom:leftBackground="@color/colorPrimary" custom:leftText="Back" custom:leftTextColor="#ffffff" custom:rightBackground="@color/colorPrimary" custom:rightText="More" custom:rightTextColor="#ffffff"/&gt; 通过如上所示的代码，我们就可以在其他的布局文件中，直接通过标签来引用这个UI模板View，代码如下所示。 1&lt;include layout="@layout/widget_topbar"/&gt; 这样就更加满足了我们的模板需求。 运行程序后，显示效果如下图所示。 当调用公共方法setButtonVisable()来控制左右两个按钮的显示和隐藏的时候，效果显示如下图所示。 项目地址→MyTopBar 原文地址自定义View(二)(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava笔记]]></title>
    <url>%2F2016%2F07%2F12%2Frxjava-note%2F</url>
    <content type="text"><![CDATA[分享一篇入门RxJava很好的一篇文章给 Android 开发者的 RxJava 详解，以下精髓摘自其中。 RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。 基本实现 RxJava 的基本实现主要有以下三点： 创建 Observer可以是 Observer ，也可以是 Subscriber 。 创建 Observablecreate(): 是 RxJava 最基本的创造事件序列的方法。just(T...): 将传入的参数依次发送出来。from(T[]) / from(Iterable&lt;? extends T&gt;): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 SubscribeObservable.subscribe(Subscriber/Observer) 线程控制 在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 Schedulers.immediate() : 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler 。 Schedulers.newThread() : 总是启用新线程，并在新线程执行操作。 Schedulers.io() : I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation() : 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 Schedulers.trampoline() :在当前线程中的工作放入队列中排队，并依次操作。 AndroidSchedulers.mainThread() : 它指定的操作将在 Android 主线程运行。 有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 文字叙述总归难理解，上代码： 123456789Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.d(tag, "number:" + number); &#125; &#125;); 上面这段代码中，由于 subscribeOn(Schedulers.io()) 的指定，被创建的事件的内容 1、2、3、4 将会在 IO 线程发出；而由于 observeOn(AndroidScheculers.mainThread()) 的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。 当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用，当使用多个 observeOn() 时候， observeOn() 指定的是它之后的操作所在的线程。 如果对准备工作的线程有要求，onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。 变换 所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 map(): 事件对象的一对一的转化。 flatMap(): 返回的是个 Observable 对象。]]></content>
      <categories>
        <category>Android</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>第三方库</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio混淆模板及常用第三方混淆(看了都说好)]]></title>
    <url>%2F2016%2F06%2F28%2Fandroid-proguard-templet%2F</url>
    <content type="text"><![CDATA[现可使用 FreeProGuard 库来助你快速混淆！现可使用 FreeProGuard 库来助你快速混淆！现可使用 FreeProGuard 库来助你快速混淆！ 首先要在build.gradle中开启混淆，也就是 minifyEnabled true ，我用的build.gradle具体如下所示： 123456789101112131415161718192021222324252627282930313233def releaseTime() &#123; return new Date().format("yyyy.MM.dd", TimeZone.getTimeZone("UTC"))&#125;android &#123; .... buildTypes &#123; release &#123; // 混淆 minifyEnabled true // Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true // 前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; // 输出apk名称为appname-1.0-beta1-xxxx-xx-xx.apk def fileName = "app-$&#123;defaultConfig.versionName&#125;-beta1-$&#123;releaseTime()&#125;.apk" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125; ....&#125; 上面注释中写到proguard-android.txt文件，这是系统默认的混淆文件，具体在../sdk/tools/proguard/目录下，其中包含了android最基本的混淆，一般不需要改动，我们需要配置的是项目中app下的proguard-rules.pro文件，在此提供一份混淆模板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165############################################### 对于一些基本指令的添加############################################### 代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5 # 混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames # 指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses # 这句话能够使我们的项目混淆后产生映射文件# 包含有类名-&gt;混淆后类名的映射关系-verbose # 指定不去忽略非公共库的类成员-dontskipnonpubliclibraryclassmembers # 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify # 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses # 避免混淆泛型-keepattributes Signature # 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable # 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/* ############################################### Android开发中一些需要保留的公共部分############################################## # 保留我们使用的四大组件，自定义的Application等等这些类不被混淆# 因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService # 保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125; # 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.** # 保留R下面的资源-keep class **.R$* &#123;*;&#125; # 保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; # 保留在Activity中的方法参数是view的方法，# 这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125; # 保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125; # 保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125; # 保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125; # 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125; # 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event); void *(**On*Listener);&#125; # webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125; # 移除Log类打印各个等级日志的代码，打正式包的时候可以做为禁log使用，这里可以作为禁止log打印的功能使用# 记得proguard-android.txt中一定不要加-dontoptimize才起作用# 另外的一种实现方案是通过BuildConfig.DEBUG的变量来控制#-assumenosideeffects class android.util.Log &#123;# public static int v(...);# public static int i(...);# public static int w(...);# public static int d(...);# public static int e(...);#&#125; ############################################### 项目中特殊处理部分############################################## #-----------处理反射类--------------- #-----------处理js交互--------------- #-----------处理实体类---------------# 在开发的时候我们可以将所有的实体类放在一个包内，这样我们写一次混淆就行了。#-keep public class com.ljd.example.entity.** &#123;# public void set*(***);# public *** get*();# public *** is*();#&#125; #-----------处理第三方依赖库--------- 下面介绍常用第三方混淆配置（已按字母排序，不定期更新）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275# AndroidEventBus-keep class org.simple.** &#123; *; &#125;-keep interface org.simple.** &#123; *; &#125;-keepclassmembers class * &#123; @org.simple.eventbus.Subscriber &lt;methods&gt;;&#125;# 百度地图（jar包换成自己的版本，记得签名要匹配）-libraryjars libs/baidumapapi_v2_1_3.jar-keep class com.baidu.** &#123;*;&#125;-keep class vi.com.** &#123;*;&#125;-keep class com.sinovoice.** &#123;*;&#125;-keep class pvi.com.** &#123;*;&#125;-dontwarn com.baidu.**-dontwarn vi.com.**-dontwarn pvi.com.**# Bugly-dontwarn com.tencent.bugly.**-keep class com.tencent.bugly.** &#123;*;&#125;# ButterKnife-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125; -keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;# EventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Facebook-keep class com.facebook.** &#123;*;&#125;-keep interface com.facebook.** &#123;*;&#125;-keep enum com.facebook.** &#123;*;&#125;# FastJson-dontwarn com.alibaba.fastjson.**-keep class com.alibaba.fastjson.** &#123; *; &#125;-keepattributes Signature-keepattributes *Annotation*# Fresco-keep class com.facebook.fresco.** &#123;*;&#125;-keep interface com.facebook.fresco.** &#123;*;&#125;-keep enum com.facebook.fresco.** &#123;*;&#125;# 高德相关依赖# 集合包:3D地图3.3.2 导航1.8.0 定位2.5.0-dontwarn com.amap.api.**-dontwarn com.autonavi.**-keep class com.amap.api.**&#123;*;&#125;-keep class com.autonavi.**&#123;*;&#125;# 地图服务-dontwarn com.amap.api.services.**-keep class com.map.api.services.** &#123;*;&#125;# 3D地图-dontwarn com.amap.api.mapcore.**-dontwarn com.amap.api.maps.**-dontwarn com.autonavi.amap.mapcore.**-keep class com.amap.api.mapcore.**&#123;*;&#125;-keep class com.amap.api.maps.**&#123;*;&#125;-keep class com.autonavi.amap.mapcore.**&#123;*;&#125;# 定位-dontwarn com.amap.api.location.**-dontwarn com.aps.**-keep class com.amap.api.location.**&#123;*;&#125;-keep class com.aps.**&#123;*;&#125;# 导航-dontwarn com.amap.api.navi.**-dontwarn com.autonavi.**-keep class com.amap.api.navi.** &#123;*;&#125;-keep class com.autonavi.** &#123;*;&#125;# Glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;# Gson-keepattributes Signature-keepattributes *Annotation*-keep class sun.misc.Unsafe &#123; *; &#125;-keep class com.google.gson.stream.** &#123; *; &#125;# 使用Gson时需要配置Gson的解析对象及变量都不混淆。不然Gson会找不到变量。# 将下面替换成自己的实体类-keep class com.example.bean.** &#123; *; &#125;# Jackson-dontwarn org.codehaus.jackson.**-dontwarn com.fasterxml.jackson.databind.**-keep class org.codehaus.jackson.** &#123; *;&#125;-keep class com.fasterxml.jackson.** &#123; *; &#125;# 极光推送-dontoptimize-dontpreverify-dontwarn cn.jpush.**-keep class cn.jpush.** &#123; *; &#125;# OkHttp-keep class com.squareup.okhttp.** &#123; *; &#125;-keep interface com.squareup.okhttp.** &#123; *; &#125;-dontwarn com.squareup.okhttp.**# OkHttp3-dontwarn com.squareup.okhttp3.**-keep class com.squareup.okhttp3.** &#123; *;&#125;-dontwarn okio.**# Okio-dontwarn com.squareup.** -dontwarn okio.** -keep public class org.codehaus.* &#123; *; &#125; -keep public class java.nio.* &#123; *; &#125;# OrmLite-keepattributes *DatabaseField* -keepattributes *DatabaseTable* -keepattributes *SerializedName* -keep class com.j256.**-keepclassmembers class com.j256.** &#123; *; &#125;-keep enum com.j256.**-keepclassmembers enum com.j256.** &#123; *; &#125;-keep interface com.j256.**-keepclassmembers interface com.j256.** &#123; *; &#125;# Realm-keep class io.realm.annotations.RealmModule-keep @io.realm.annotations.RealmModule class *-keep class io.realm.internal.Keep-keep @io.realm.internal.Keep class * &#123; *; &#125;-dontwarn javax.**-dontwarn io.realm.**# Retrofit-dontwarn retrofit2.**-keep class retrofit2.** &#123; *; &#125;-keepattributes Signature-keepattributes Exceptions# Retrolambda-dontwarn java.lang.invoke.*# RxJava RxAndroid-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;# Universal-Image-Loader-v1.9.5-libraryjars libs/universal-image-loader-1.9.5-SNAPSHOT-with-sources.jar-dontwarn com.nostra13.universalimageloader.**-keep class com.nostra13.universalimageloader.** &#123; *; &#125;# 微信支付-dontwarn com.tencent.mm.**-dontwarn com.tencent.wxop.stat.**-keep class com.tencent.mm.** &#123;*;&#125;-keep class com.tencent.wxop.stat.**&#123;*;&#125;# 信鸽-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep class com.tencent.android.tpush.** &#123;* ;&#125;-keep class com.tencent.mid.** &#123;* ;&#125;-keepattributes *Annotation*# 新浪微博-keep class com.sina.weibo.sdk.* &#123; *; &#125; -keep class android.support.v4.* &#123; *; &#125; -keep class com.tencent.* &#123; *; &#125; -keep class com.baidu.* &#123; *; &#125; -keep class lombok.ast.ecj.* &#123; *; &#125; -dontwarn android.support.v4.** -dontwarn com.tencent.**s -dontwarn com.baidu.** # 讯飞语音-dontwarn com.iflytek.**-keep class com.iflytek.** &#123;*;&#125;# xUtils3.0-keepattributes Signature,Annotation-keep public class org.xutils.** &#123;public protected *;&#125;-keep public interface org.xutils.** &#123;public protected *;&#125;-keepclassmembers class * extends org.xutils.** &#123;public protected *;&#125;-keepclassmembers @org.xutils.db.annotation.* class * &#123;;&#125;-keepclassmembers @org.xutils.http.annotation. class * &#123;*;&#125;-keepclassmembers class * &#123;@org.xutils.view.annotation.Event ;&#125;# 银联-dontwarn com.unionpay.**-keep class com.unionpay.** &#123; *; &#125;# 友盟统计分析-keepclassmembers class * &#123; public &lt;init&gt;(org.json.JSONObject); &#125;-keepclassmembers enum com.umeng.analytics.** &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 友盟自动更新-keepclassmembers class * &#123; public &lt;init&gt;(org.json.JSONObject); &#125;-keep public class cn.irains.parking.cloud.pub.R$*&#123; public static final int *; &#125;-keep public class * extends com.umeng.**-keep class com.umeng.** &#123; *; &#125;# 支付宝钱包-dontwarn com.alipay.**-dontwarn HttpUtils.HttpFetcher-dontwarn com.ta.utdid2.**-dontwarn com.ut.device.**-keep class com.alipay.android.app.IAlixPay&#123;*;&#125;-keep class com.alipay.android.app.IAlixPay$Stub&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback$Stub&#123;*;&#125;-keep class com.alipay.sdk.app.PayTask&#123; public *;&#125;-keep class com.alipay.sdk.app.AuthTask&#123; public *;&#125;-keep class com.alipay.mobilesecuritysdk.*-keep class com.ut.* 原文地址Android Studio混淆模板及常用第三方混淆(看了都说好) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决WP Markdown Editor和Crayon Syntax Highlighter一起使用代码块无故多一行]]></title>
    <url>%2F2016%2F06%2F17%2Fsolve-wp-markdown-editor-crayon-syntax-highlighter-one-more-line-bug%2F</url>
    <content type="text"><![CDATA[当用WP Markdown Editor写完文章发布后，如果存在代码块的话，在前台由Crayon Syntax Highlighter渲染出来会存在如下图问题。 也就是代码块无故多一行出来，影响美观，由审查元素可以看到多的是一个转义的空格&nbsp; 处理了大半天，终于解决了，是目前来说最好的解决办法了，方法如下： 在主题的footer.php最后加上如下JS代码即可，代码一目了然是在做什么。123456789101112&lt;script&gt;var nodes = document.querySelectorAll('.crayon-pre'); for (var i = 0; i &lt; nodes.length; i++) &#123; var lastnode = nodes[i].lastChild; if (lastnode.innerHTML == ' ') &#123; nodes[i].removeChild(lastnode) var parent = nodes[i].parentNode.parentNode.parentNode.firstChild.childNodes[1].childNodes[1]; var parentLastNode = parent.lastChild; parent.removeChild(parentLastNode); &#125;&#125;&lt;/script&gt; 再清一下缓存去前台探探路，如下图所示。 大功告成。 原文地址解决WP Markdown Editor和Crayon Syntax Highlighter一起使用代码块无故多一行 我的自媒体博客blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Blog</category>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正方教务系统自动评教]]></title>
    <url>%2F2016%2F06%2F15%2Fauto-teaching-evaluation%2F</url>
    <content type="text"><![CDATA[期末到了，又到了评教的时刻，是时候展示曾经学的JS功底了，这里以推荐谷歌浏览器去评教，首先到进入到评教页面，点击老师后弹出新的页面，如下图所示： 打开浏览器控制台（Ctrl + Shift + C），粘贴下方的JS代码在控制台中，点击回车即可，具体情况如下图所示： 12345678910111213function autoPJXT_YONIIIIII_ZJCM() &#123; for(var j = 0; j &lt; 13; ++j) &#123; var sel = document.getElementsByTagName('select')[j]; for (var i = 0; i &lt; sel.length; i++) &#123; if (sel[i].value == "86-101") &#123; sel[i].selected = true; document.getElementsByTagName('input')[j+1].value=100.9; &#125; &#125; document.getElementById("txt_pjxx").value='老师备课充分，授课重点突出。'; &#125; document.getElementById("Button1").click();&#125;autoPJXT_YONIIIIII_ZJCM(); 关闭控制台后，返回到页面中，可以发现结果都已自动写好，并提交完毕，turn to next one 是不是省事多了哈。]]></content>
      <categories>
        <category>JS</category>
        <category>奇淫技巧</category>
      </categories>
      <tags>
        <tag>奇淫技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View(一)(Android群英传)]]></title>
    <url>%2F2016%2F05%2F29%2Fcustom-view1-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 Android给我们提供了丰富的组件库来创建丰富的UI效果，同时也提供了非常方便的拓展方法。通过继承Android的系统组件，我们可以非常方便地拓展现有功能，在系统组件的基础上创建新的功能，甚至可以直接自定义一个控件，实现Android系统控件所没有的功能。自定义控件作为Android中一个非常重要的功能，一直以来都被初学者认为是代表高手的象征。其实，自定义View并没有想象中的那么难，与其说是在自定义一个View，不如说是在设计一个图形，只有站在一个设计者的角度上，才可以更好地创建自定义View。我们不能机械地记忆所有绘图的API，而是要让这些API为你所用，结合现实中绘图的方法，甚至是PhotoShop的技巧，才能设计出更好的自定义View。 适当地使用自定义View，可以丰富应用程序的体验效果，但滥用自定义View则会带来适得其反的效果。一个让用户觉得熟悉得控件，才是一个好的控件。如果一味追求炫酷的效果而创建自定义View，则会让用户觉得华而不实。而且，在系统原生控件可以实现功能的基础上，系统也提供了主题、图片资源、各种风格来创建丰富的UI。这些控件都是经过了Android一代代版本迭代后的产物。即使这样，在如今的版本中，依然存在不少Bug，更不要提我们自定义的View了。特别是现在Android ROM的多样性，导致Android的适配变得越来越复杂，很难保证自定义View在其他手机上也能达到你想要的效果。 当然，了解Android系统自定义View的过程，可以帮助我们了解系统的绘图机智。同时，在适当的情况下也可以通过自定义View来帮助我们创建更佳灵活的布局。 在自定义View时，我们通常会去重写onDraw()方法来挥着View的显示内容。如果该View还需要使用wrap_content属性，那么还必须写onMeasure()方法。另外，通过自定义attrs属性，还可以设置新的属性配置值。 在View中通常有以下一些比较重要的回调方法。 onFinishInflate()：从XML加载组件后回调。 onSizeChanged()：组件大小改变时回调。 onMeasure()：回调该方法来进行测量。 onLayout()：回调该方法来确定显示的位置。 onTouchEvent()：监听到触摸事件时回调。 当然，创建自定义View的时候，并不需要重写所有的方法，只需要重写特定条件的回调方法即可。这也是Android控件架构灵活性的体现。 通常情况下，有以下三种方法来实现自定义的控件。 对现有控件进行拓展 通过组合来实现新的控件 重写View来实现全新的控件 对现有控件进行拓展 这是一个非常重要的自定义View方法，它可以在原生控件的基础上进行拓展，增加新的功能、修改显示的UI等。一般来说，我们可以再原生控件的基础上进行拓展，增加新的功能、修改显示的UI等。一般来说，我们可以在onDraw()方法中对原生控件行为进行拓展。 下面以一个TextView为例，来看看如何使用拓展原生控件的方法创建新的控件。比如想让一个TextView的背景更佳丰富，给其多绘制几层背景，如下图所示。 我们先来分析一下如何实现这个效果，原生的TextView使用onDraw()方法绘制要显示的文字。当继承了系统的TextView之后，如果不重写其onDraw()方法，则不会修改TextView的任何效果。可以认为在自定义的TextView中调用TextView类的onDraw()方法来绘制显示的文字，代码如下所示。 1234@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas);&#125; 程序调用super.onDraw(canvas)方法来实现原生控件的功能，但是在动用super.onDraw()方法之前和之后，我们都可以实现自己的逻辑，分别在系统绘制文字前后，完成自己的操作，即如下所示。 123456@Overrideprotected void onDraw(Canvas canvas) &#123; //在调父类方法前，实现自己的逻辑，对TextView来说即是在绘制文本内容前 super.onDraw(canvas); //在调父类方法后，实现自己的逻辑，对TextView来说即是在绘制文本内容后&#125; 以上就是通过改变控件的绘制行为创建自定义View的思路。有了上面的分析，我们就可以很轻松地实现上图所示的自定义TextView了。我们在构造方法中完成必要对象的初始化工作，如初始化画笔等，代码如下所示。 123456mPaint1 = new Paint();mPaint1.setColor(Color.BLUE);mPaint1.setStyle(Paint.Style.FILL);mPaint2 = new Paint();mPaint2.setColor(Color.YELLOW);mPaint2.setStyle(Paint.Style.FILL); 而代码中最重要的部分则是在onDraw()方法中，为了改变原生的绘制行为，在系统调用super.onDraw(canvas)方法前，也就是在绘制文字之前，绘制两个不同大小的矩形，形成一个重叠效果，再让系统调用super.onDraw(canvas)方法，执行绘制文字的工作。这样，我们就通过改变控件绘制行为，创建了一个新的控件，代码如下所示。 12345678910111213141516171819202122//绘制外层矩形canvas.drawRect( 0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint1);//绘制内层矩形canvas.drawRect( 10, 10, getMeasuredWidth() - 10, getMeasuredHeight() - 10, mPaint2);canvas.save();//绘制文字前平移10像素canvas.translate(10,0);//父类完成的方法，即绘制文本super.onDraw(canvas);canvas.restore(); 下面再来看一个稍微复杂一点的TextView。在前面一个实例中，我们直接使用了Canvas对象来进行图像的绘制，然后利用Android的绘图机制，可以绘制出更复杂丰富的图像。比如可以利用LinearGradient Shader 和Matrix来实现一个动态的文字闪动效果，程序运行效果如下图所示。 要想实现这个效果，可以充分利用Android中Paint对象的Shader渲染器。通过设置一个不断变化的LinearGradient，并使用带有该属性的Paint对象来绘制要显示的文字。首先，在onSizeChanged()方法中进行一些对象的初始化工作，并根据View的宽度设置一个LinearGradient渐变渲染器，代码如下所示。 123456789101112131415161718192021222324@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (mViewWidth == 0) &#123; mViewWidth = getMeasuredWidth(); if (mViewWidth &gt; 0) &#123; mPaint = getPaint(); mLinearGradient = new LinearGradient( 0, 0, mViewWidth, 0, new int[]&#123; Color.BLUE, 0xffffff, Color.BLUE &#125;, null, Shader.TileMode.CLAMP); mPaint.setShader(mLinearGradient); mGradientMatrix = new Matrix(); &#125; &#125;&#125; 其中最关键的就是使用getPaint()方法获取当前绘制TextView的Paint对象，并给这个Paint对象设置原生TextView没有的LinearGradient属性。最后，在onDraw()方法中，通过矩形的方式来不断平移渐变效果，从而在绘制文字时，产生动态的闪动效果，代码如下所示。 12345678910111213@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mGradientMatrix != null) &#123; mTranslate += mViewWidth / 5; if (mTranslate &gt; 2 * mViewWidth) &#123; mTranslate = -mViewWidth; &#125; mGradientMatrix.setTranslate(mTranslate, 0); mLinearGradient.setLocalMatrix(mGradientMatrix); postInvalidateDelayed(100); &#125;&#125; 原文地址自定义View(一)(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewGroup的测量与绘制(Android群英传)]]></title>
    <url>%2F2016%2F05%2F28%2Fmeasure-draw-viewGroup-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 ViewGroup的测量 之前分析中说了，ViewGroup会去管理其子View，其中一个管理项目就是负责子View的显示大小。当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以便获得所有子View的大小，从而来决定自己的大小。而在其他模式下则会通过具体的指定值来设置自身的大小。 ViewGroup在测量时通过遍历所有子View，从而调用子View的Measure方法来获得每一个子View的测量结果，前面所说的对View的测量，就是在这里进行的。 当子View测量完毕后，就需要将子View放到合适的位置，这个过程就是View的Layout过程，同样是使用遍历来调用子View的Layout方法，并制定其具体显示的位置，从而来决定其布局位置。 在自定义ViewGroup时，通常会去重写onLayout()方法来控制其子View显示位置的逻辑。同样，如果需要支持wrap_content属性，那么它还需要重写onMeasure()方法，这点与View是相同的。 ViewGroup的绘制 ViewGroup通常情况下不需要绘制，因为它本身就没有需要绘制的东西，如果不是指定了ViewGroup的背景颜色，那么ViewGroup的onDraw()方法都不会被调用。但是，ViewGroup会调用dispatchDraw()方法来绘制其子View，其过程同样是通过遍历所有子View，并调用子View的绘制方法来完成绘制工作。 原文地址ViewGroup的测量与绘制(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的绘制(Android群英传)]]></title>
    <url>%2F2016%2F05%2F20%2Fdraw-view-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 当测量好了一个View之后，我们就可以简单地重写onDraw()方法，并在Canvas对象上来绘制所需要的图形。首先我们来了解一下利用系统2D绘图API所必须要使用到的Canvas对象。 要想在Android的界面中绘制相应的图像，就必须在Canvas上进行绘制。Canvas就像是一个画板，使用Paint就可以在上面作画了。通常需要通过继承View并重写它的onDraw()方法来完成绘图。 那什么是Canvas呢？一般情况下，可以使用重写View类中的onDraw()方法来绘图，onDraw()中有一个参数，就是Canvas canvas对象。使用这个Canvas对象就可以进行绘图了，而在其他地方，通常需要使用代码创建一个Canvas对象，代码如下所示。 1Canvas canvas = new Canvas(bitmap); 当创建一个Canvas对象时，为什么要传进去一个bitmap对象呢？如果不传进入一个bitmap对象，IDE编译虽然不会报错，但是一般我们不会这样做。这是因为传进去的bitmap与通过这个bitmap创建的Canvas画布是紧紧联系在一起的，这个过程我们称之为装载画布。这个bitmap用来存储所有绘制在Canvas上的像素信息。所以当你通过这种方式创建了Canvas对象后，后面调用所有的Canvas.drawXXX方法都发生在这个bitmap上。如果在View类的onQraw()方法中，通过下面这段代码，我们可以了解到canvas与bitmap直接的关系。首先在onDraw方法中绘制两个bitmap，代码如下所示。 12canvas.drawBiimap(bitmap1, 0, 0, null);canvas.drawBitmap(bitmap2, 0, 0, null); 而对于bitmap2，我们将它装载到另一个Canvas对象中，代码如下所示。 1Canvas mCanvas=new Canvas(bitmap2); 在其他地方使用Canvas对象的绘图方法在装载bitmap2的Canvas对象上进行绘图，代码如下所示。 1mCanvas.drawXXX 通过mCanvas将绘制效果作用在了bitmap2上，再刷新View的时候，就会发现通过onDraw()方法画出来的bitmap2已经发生变化，这就是因为bitmap2承载了在mCanvas上所进行的绘图操作。虽然我们也使用了Canvas的绘制API，但其实并没有将图形直接绘制在onDraw()方法指定的那块画布上，而是通过改变bitmap，然后让View重绘，从而显示改变之后的bitmap。这一过程对初学者来说可能非常难以理解，但是却非常重要，这对后续进行深入地学习和提升绘图技巧非常有帮助。 在理解了Canvas对象后，我们就可以调用Canvas所提供的绘图方法，来绘制自己想要的图形了。不管是多么复杂、精美的控件，它都可以被拆分成一个个小的图形单元，我们要做的正是找到这些小的绘图单元并将它们绘制出来。 原文地址View的绘制(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的测量(Android群英传)]]></title>
    <url>%2F2016%2F05%2F20%2Fmeasure-view-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 Android系统在绘制View之前也必须对View进行测量，即告诉系统该画一个多大的View。这个过程在onMeasure()方法中进行。 Android系统给我们提供了一个牛逼的类—-MeasureSpec类，我们可通过它来测量View。MeasureSpec是一个32位的值，其中高两位为测量的模式，低30位为测量的大小，在计算中使用位运算当然是提高运行速率了。 测量模式为以下三种。 EXACTLY 即精确模式，当我们将控件的layout_width或layout_height属性设定为具体值时，比如android:layout_width=”100dp”，或者指定为match_parent属性时（占据父View的大小），系统使用的是EXACTLY模式。 AT_MOST 即最大模式，当控件的layout_width或layout_height属性设定为wrap_content时，控件大小一般随着控件的子控件或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。 UNSPECIFIED 这个属性比较奇怪—-它不指定其大小测量模式，View想多大就多大，通常在自定义View时才会使用。 View类默认的onMeasure()方法只支持EXACTLY模式，所以如果在自定义控件的时候不重写onMeasure()方法的话，就只能使用EXACTLY模式。控件可以响应你指定的具体宽高值或者是match_parent属性。而如果要让自定义View支持wrap_content属性，那就必须重写onMeasure()方法来指定wrap_content时的大小。 通过MeasureSpec这一个类，我们就获取了View的测量模式和View想要绘制的大小。有了这些信息，我们就可以控制View最后显示的大小。 下面来看一个简单的实例演示如何进行View的测量。首先要重写onMeasure()方法，该方法如下所示。 1234@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; 在IDE中按住Ctrl+鼠标左键点击onMeasure查看源代码，可以发现系统最终会调用setMeasuredDimension(int measuredWidth, int measuredHeight)方法将测量后的宽高值设置进去，从而完成测量工作。所以在重写onMeasure()方法后，最重要最的工作就是把测量后的宽高值作为参数传给setMeasuredDimension()方法。 通过上面的分析，重写的onMeasure()方法代码如下所示。 1234@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));&#125; 在onMeasure()方法中，我们调用自定义的measureWidth()方法和measureHeight()方法分别对宽高进行重定义，参数则是宽和高的MeasureSpec对象，MeasureSpec对象根据前面的介绍可以知道它包含了测量的模式和测量值的大小。 下面我们就以measureWidth()方法为例，讲解如何自定义测量值。 第一步，从MeasureSpec对象中提取出具体的测量模式和大小，代码如下所示。 12int specMode = MeasureSpec.getMode(widthMeasureSpec);int specSize = MeasureSpec.getSize(widthMeasureSpec); 接下来通过判断测量的模式，给出不同的测量值。当specMode为EXACTLY时，直接使用指定的specSize即可；当specMode为其他两种模式时，需要给它一个默认的大小。特别地，如果指定wrap_content属性，即AT_MOST模式，则需要提取出我们指定的大小与specSize中最小的一个来作为最后的测量值，measureWidth()方法的代码如下。这段代码基本可以作为模板代码。 1234567891011121314private int measureWidth(int widthMeasureSpec) &#123; int result = 0; int specMode = MeasureSpec.getMode(widthMeasureSpec); int specSize = MeasureSpec.getSize(widthMeasureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize; &#125; else &#123; result = 200; if (specMode == MeasureSpec.AT_MOST) &#123; result = Math.min(result, specSize); &#125; &#125; return result;&#125; measureHeight()与measureWidth()方法基本一致，不再给出代码，通过这两个方法，我们就完成了对宽高值得自定义。最后可以在程序中验证以上分析。 在布局文件中首先指定确定的宽高值400px，程序效果如下图所示。 当指定宽高属性为match_parent时，运行效果如下图所示。 当指定宽高属性为wrap_content时，如果不写onMeasure()方法，那么系统就不知道该使用默认多大尺寸。因此它就会默认填充整个父布局，所以重写onMeasure()方法的目的就是为了能够给View一个wrap_content属性下的默认大小，其运行效果如下图所示。 可以发现，当指定wrap_content属性时，View就会获得一个默认值200px，而不是再填充父布局了。 通过这个实例，相信大家对View的测量不再陌生了，它并不是什么高深莫测的东西，它的整个过程与我们在生活中精确绘图是一样的。 原文地址View的测量(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android控件架构(Android群英传)]]></title>
    <url>%2F2016%2F05%2F19%2Fandroid-widget-struct-hero%2F</url>
    <content type="text"><![CDATA[内容是博主照着书敲出来的，博主码字挺辛苦的，转载请注明出处，后序内容陆续会码出。 控件大致被分为两类，ViewGroup控件和View控件。ViewGroup可以包含多个View并管理它们。通过ViewGroup，整个界面上的控件形成一个树形结构，也就是我们常说的控件树，上层控件负责下层子控件的测量与绘制，并传递交互事件。通常在Activity中使用findViewById()方法，就是在控件树中以树的深度优先遍历来查找对应元素。在每棵控件树的顶部，都有一个ViewParent对象，这就是整棵树的控制核心，所有的交互管理事件都由它统一调度和分配，从而可以对整个视图进行整体控制。View视图树如下图所示。 通常情况下，在Activity中使用setContentView()方法来设置一个布局，在调用该方法后，布局内容才真正显示出来。下面来看一下Android界面的架构图，如下图所示。 每个Activity都包含一个Window对象，在Android中Window对象通常由PhoneWindow来实现。PhoneWindow将一个DecorView设置为整个应用窗口的根View。DecorView作为窗口界面的顶层视图，封装了一些窗口操作的通用方法。可以说，DecorView将要显示的具体内容呈现在了PhoneWindow上，这里面的所有View的监听事件都通过WindowManagerService来进行接收，并通过Activity对象来回调相应的onClickListener。在显示上，他将屏幕分为两部分，一个是TitleView，另一个是ContentView。看到这里，大家一定看见了一个非常熟悉得布局—-ContentView。它是一个ID为content的FrameLayout，activity_main.xml就是设置在这样一个Framelayout里。通过以上过程，我们可以建立起这样一个标准视图树，如下图所示。 上图所示的视图树的第二层装在了一个LinearLayout作为ViewGroup，这一层的布局结构会根据对应的参数设置不同的布局，如最常用的布局—-上面显示TitleBar，下面是Content这样的布局，也就是图3.3中所设置的布局。而如果用户通过设置requestWindowFeature(Window.FEATURE_NO_TITLE)来设置显示全屏，视图树中的布局就只有Content了，这就解释了为什么调用requestWindowFeature()方法一定要在setContentView()方法之前才能生效的原因。不过这里要注意的是，由于每个Android版本对UI的修改都比较多，上图只是比较粗略地显示了视图树的结构。 而在代码中，当程序在onCreat()方法中调用setContentView()方法后，ActivityManagerService会回调onResume()方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。 原文地址Android控件架构(Android群英传) 我的自媒体博客Blankj小站，欢迎来逛逛。]]></content>
      <categories>
        <category>Android群英传</category>
        <category>3.Android控件架构与自定义控件详解</category>
      </categories>
      <tags>
        <tag>3.Android控件架构与自定义控件详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Last ACM]]></title>
    <url>%2F2016%2F04%2F23%2Fthe-last-acm%2F</url>
    <content type="text"><![CDATA[大学最后一次的ACM，之前两次的一无所获也总算应了那句话，所有的事情到最后都会是好的，如果不是，说明还没到最后。在小伙伴们的不懈奋斗下和我突发其来的灵感和曾经的经验，终于水出了五道，从中也吸取了一定要细心细心再细心的教训，虽然只是铜奖，但也为我们学校破了这两年零蛋的魔咒，以后的就交给学弟学妹们了。当然我还是会继续喜欢Algorithms，还是会去刷像Leetcode这样好的OJ平台，当下的话继续深入学习安卓，搭建自己的框架，逛逛Github这个相用恨晚的平台。]]></content>
      <categories>
        <category>Life</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的会写单例吗]]></title>
    <url>%2F2016%2F04%2F21%2Freally-use-singleton%2F</url>
    <content type="text"><![CDATA[提到单例模式，相信都不会陌生，今天对其进行总结。 以下是单例模式的特点： 单例类只能有一个实例。 单例类必须自己自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 种类的话不好说有几类，因为要考虑到是否在多线程下运行，下面来介绍主要的几类： 懒汉类123456789101112131415//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton single = null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 懒汉么，所以在多线程下会失效，所以下面介绍三种懒汉的升级版来适应多线程 在getinstance前加上synchronized（同步），但这导致的是每次getInstance都会去同步，消耗资源。 1234567891011121314public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton single = null; // 静态工厂方法 public static synchronized Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 双重检查锁，它是在以上做的修改，判断两次空，所以只有在第一次调用的时候会同步，避免了每次同步资源的消耗，注意 volatile 关键字。 123456789101112131415161718public class Singleton &#123; private Singleton() &#123; &#125; private volatile static Singleton singleton = null; // 声明成 volatile //静态工厂方法 public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 内部静态类，这种我觉得是最好的，既实现了线程安全，也避免了同步带来的性能影响。 123456789101112public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 饿汉类饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。 123456789101112//饿汉式单例类.在类初始化时，已经自行实例化public class Singleton &#123; private Singleton() &#123; &#125; private static final Singleton single = new Singleton(); //静态工厂方法 public static Singleton getInstance() &#123; return single; &#125;&#125; 这种也是我比较喜欢的，因为简单易懂，但当实现了Serializable接口后，反序列化时单例会被破坏，实现Serializable接口需要重写readResolve，才能保证其反序列化依旧是单例： 123private Object readResolve() throws ObjectStreamException &#123; return single; &#125; 枚举类123456public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。 以上就是常用的单例模式，一般的情况下，我会使用饿汉式，只有在要明确实现lazy loading效果时才会使用内部静态类，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的。]]></content>
      <categories>
        <category>Android</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带正则校验的EditText]]></title>
    <url>%2F2016%2F04%2F12%2FeditText-reg%2F</url>
    <content type="text"><![CDATA[这是好久之前写的了，现在整理下文章那就写一下吧，直接上演示Demo，如下所示，伸手党们可直接跳到最后去下载源码。 原理很简单，实现TextWatcher接口中的afterTextChanged()函数，根据正则表达式返回的结果来动态加载rightDrawable，至于校验成功或者失败的drawable用户在初始化的时候可以自定义，下面给出源码参考，其实现了常用的手机、座机、邮箱、url、汉字、用户名的校验，如果你觉得还不满足的话，最后还提供了用户自定义正则的校验，这样总满意了吧，下面给出其代码供参考。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import android.content.Context;import android.graphics.drawable.Drawable;import android.text.Editable;import android.text.TextWatcher;import android.util.AttributeSet;import android.widget.EditText;/** * Created by cmj on 2016/4/11. */public class AutoCheckEditText extends EditText implements TextWatcher &#123; //手机校验类型 public static final int TYPE_OF_MOBILE = 0xb0; //座机校验类型 public static final int TYPE_OF_TEL = 0xb1; //邮箱校验类型 public static final int TYPE_OF_EMAIL = 0xb2; //url校验类型 public static final int TYPE_OF_URL = 0xb3; //汉字校验类型 public static final int TYPE_OF_CHZ = 0xb4; //用户名校验类型 public static final int TYPE_OF_USERNAME = 0xb5; //用户自定义 public static final int TYPE_OF_USER_DEFINE = 0xbb; private int type; private Drawable successDrawable; private Drawable unsuccessDrawable; private String userRegx; public AutoCheckEditText(Context context) &#123; super(context); &#125; public AutoCheckEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public AutoCheckEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; /** * @param typ 要校验的类型 * @param success 匹配成功时的图标 * @param unsuccess 匹配失败时的图标 */ public void creatCheck(int typ, Drawable success, Drawable unsuccess) &#123; type = typ; successDrawable = success; successDrawable.setBounds(0, 0, successDrawable.getMinimumWidth(), successDrawable.getMinimumHeight()); unsuccessDrawable = unsuccess; unsuccessDrawable.setBounds(0, 0, unsuccessDrawable.getMinimumWidth(), unsuccessDrawable.getMinimumHeight()); this.addTextChangedListener(this); &#125; /** * @param typ 要校验的类型 * @param success 匹配成功时的图标 * @param unsuccess 匹配失败时的图标 */ public void creatCheck(int typ, Drawable success, Drawable unsuccess, String userRegex) &#123; creatCheck(typ, success, unsuccess); this.userRegx = userRegex; &#125; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; System.out.println("a"); &#125; @Override public void afterTextChanged(Editable s) &#123; if (s != null &amp;&amp; s.length() &gt; 0) &#123; boolean isMatch; if (type == TYPE_OF_MOBILE) &#123; isMatch = Check.isMobile(s.toString()); &#125; else if (type == TYPE_OF_TEL) &#123; isMatch = Check.isTel(s.toString()); &#125; else if (type == TYPE_OF_EMAIL) &#123; isMatch = Check.isEmail(s.toString()); &#125; else if (type == TYPE_OF_URL) &#123; isMatch = Check.isURL(s.toString()); &#125; else if (type == TYPE_OF_CHZ) &#123; isMatch = Check.isChz(s.toString()); &#125; else if (type == TYPE_OF_USERNAME) &#123; isMatch = Check.isUsername(s.toString()); &#125; else if (type == TYPE_OF_USER_DEFINE) &#123; isMatch = Check.isMatch(userRegx, s.toString()); &#125; else &#123; return; &#125; if (isMatch) &#123; setCompoundDrawables(null, null, successDrawable, null); &#125; else &#123; setCompoundDrawables(null, null, unsuccessDrawable, null); &#125; &#125; else &#123; setCompoundDrawables(null, null, null, null); &#125; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; System.out.println(); &#125;&#125; 最后献上源码地址：AutoCheckEditTextDemo，欢迎大家star和fork。]]></content>
      <categories>
        <category>Android</category>
        <category>自定义View</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的简单使用]]></title>
    <url>%2F2016%2F03%2F24%2Fgit-simple-use%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit//初始化一个Git仓库$ git init //添加文件到Git仓库，分两步：$ git add readme.txt$ git commit -m &quot;...&quot;//查看仓库当前的状态$ git status//查看difference$ git diff readme.txt //查看历史记录$ git log//信息太多可用如下$ git log --pretty=oneline//用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^//当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。//回退到上一个版本$ git reset --hard HEAD^//查看命令历史$ git reflog//回退到id是1234..的版本$ git reset --hard 1234..//回到最近一次git commit或git add时的状态$ git checkout -- readme.txt//把暂存区的修改撤销掉（unstage），重新放回工作区$ git reset HEAD readme.txt//删除一个文件$ git rm test.txt//关联一个远程库$ git remote add origin http://192.168.0.62:82/cmj/learnGit.git//推送master分支的所有内容，远程的话commit之后，最后还需要push到远程库，远程库才会发生修改$ git push -u origin master//推送最新修改$ git push origin master//用http协议克隆一个仓库$ git clone http://192.168.0.62:82/cmj/learnGit.git//我们创建dev分支，然后切换到dev分支$ git checkout -b dev//等同于以下两句&#123;//创建分支$ git branch dev//切换分支到dev$ git checkout dev&#125;//查看当前分支，前面带*的就是当前分支$ git branch//分支某合并到当前分支$ git merge dev//删除分支$ git branch -d dev]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidEventBus笔记]]></title>
    <url>%2F2016%2F03%2F22%2FandroidEventBus-note%2F</url>
    <content type="text"><![CDATA[EventBus最直接的好处就是解耦，但因为内部实现是反射，小项目无所谓，大项目的话性能不是很好。 本次要介绍的是AndroidEventBus，而不是greenrobot的EventBus，其使用注解，使用方便，但效率比不上EventBus。订阅函数支持tag(类似广播接收器的Action)使得事件的投递更加准确，能适应更多使用场景。其github项目地址为：androideventbus下面介绍其用法。首先在build.gradle中加入依赖 123dependencies &#123; compile 'org.simple:androideventbus:1.0.5.1'// 可以在官网查看最新版本&#125; 在Android中我们可以在onCreate方法中调用EventBus的register(Object subscriber) 注册订阅者，具体如下： 1234567891011121314151617@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tryBtn = (Button) findViewById(R.id.btn_main_try); showTV = (TextView) findViewById(R.id.tv_main_show); tryBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(getApplicationContext(), SecondActivity.class); startActivity(intent); &#125; &#125;); //注册EventBus EventBus.getDefault().register(this);&#125; 注册者中通过Subscriber注解来标识事件接收对象中的接收方法。 123456@Subscriber(tag = "my_tag", mode = ThreadMode.MAIN)public void onEvent(FirstEvent event) &#123; String msg = "onEvent收到了消息：" + event.getMsg(); showTV.setText(msg); Toast.makeText(this, msg, Toast.LENGTH_LONG).show();&#125; tag可用来区分post过来的消息标识，根据tag值可处理不同的消息。 mode有三种。 ThreadMode.MAIN:执行在UI线程。 ThreadMode.POST:post函数在哪个线程执行,该函数就执行在哪个线程。 ThreadMode.ASYNC:执行在一个独立的线程。 调用EventBus的unregister(Object subscriber) 方法，取消注册的订阅者： 123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); //注销EventBus EventBus.getDefault().unregister(this);&#125; 以上三步一般都写在同一个类中。 下面介绍怎么把消息传过来，很简单，只需在其他需要调用的地方post(Object event) 即可，消息便会进入队列。 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); firstEventBtn = (Button) findViewById(R.id.btn_second_first_event); firstEventBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //发送消息 EventBus.getDefault().post(new FirstEvent("FirstEvent btn clicked"), "my_tag"); &#125; &#125;);&#125; 需要强调的是：post的参数一定要是对象（引用类型），int、byte、long都是不可以的，实在需要就得转换为Integer、Byte和Long类型。 FirstEvent类 123456789public class FirstEvent &#123; private String mMsg; public FirstEvent(String msg) &#123; mMsg = msg; &#125; public String getMsg()&#123; return mMsg; &#125;&#125; 好了，就是这么简单。]]></content>
      <categories>
        <category>Android</category>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>第三方库</tag>
        <tag>AndroidEventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[English Game]]></title>
    <url>%2F2016%2F03%2F07%2Fenglish-game%2F</url>
    <content type="text"><![CDATA[题目描述 This English game is a simple English words connection game. The rules are as follows: there are N English words in a dictionary, and every word has its own weight v. There is a weight if the corresponding word is used. Now there is a target string X. You have to pick some words in the dictionary, and then connect them to form X. At the same time, the sum weight of the words you picked must be the biggest. 输入要求 There are several test cases. For each test, N (1&lt;=n&lt;=1000) and X (the length of x is not bigger than 10000) are given at first. Then N rows follow. Each row contains a word wi (the length is not bigger than 30) and the weight of it. Every word is composed of lowercases. No two words in the dictionary are the same. 输出要求 For each test case, output the biggest sum weight, if you could not form the string X, output -1. 假如输入 1 aaaa a 2 3 aaa a 2 aa 5 aaa 6 4 abc a 1 bc 2 ab 4 c 1 3 abcd ab 10 bc 20 cd 30 3 abcd cd 100 abc 1000 bcd 10000 应当输出 8 7 5 40 -1 Java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.BufferedInputStream;import java.util.Scanner;public class Main &#123; // 字典树dp static class Node &#123; int w; boolean end; Node[] next = new Node[26]; &#125; static int[] dp; static String str; static Node root; static int len; public static void main(String[] args) &#123; Scanner scanner = new Scanner(new BufferedInputStream(System.in)); while (scanner.hasNext()) &#123; root = new Node(); int n = scanner.nextInt(); str = " "; str += scanner.next(); len = str.length(); dp = new int[len]; for (int i = 0; i &lt; n; ++i) &#123; String word = scanner.next(); int w = scanner.nextInt(); insertNode(word, w); &#125; solve(0); for (int i = 1; i &lt; len - 1; ++i) &#123; if (dp[i] != 0) solve(i); &#125; System.out.println(dp[len - 1] == 0 ? -1 : dp[len - 1]); &#125; &#125; static void insertNode(String word, int w) &#123; int wlen = word.length(); Node tmp = root; for (int i = 0; i &lt; wlen; ++i) &#123; int x = word.charAt(i) - 'a'; if (tmp.next[x] == null) &#123; tmp.next[x] = new Node(); &#125; tmp = tmp.next[x]; &#125; tmp.end = true; tmp.w = w; &#125; static void solve(int i) &#123; Node cur = root; for (int j = i + 1; j &lt; len; ++j) &#123; int x = str.charAt(j) - 'a'; if (cur.next[x] != null) &#123; if (cur.next[x].end) &#123; dp[j] = Math.max(dp[j], dp[i] + cur.next[x].w); &#125; cur = cur.next[x]; &#125; else &#123; break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dinner]]></title>
    <url>%2F2016%2F03%2F07%2Fdinner%2F</url>
    <content type="text"><![CDATA[题目描述 Little A is one member of ACM team. He had just won the gold in World Final. To celebrate, he decided to invite all to have one meal. As bowl, knife and other tableware is not enough in the kitchen, Little A goes to take backup tableware in warehouse. There are many boxes in warehouse, one box contains only one thing, and each box is marked by the name of things inside it. For example, if “basketball” is written on the box, which means the box contains only basketball. With these marks, Little A wants to find out the tableware easily. So, the problem for you is to help him, find out all the tableware from all boxes in the warehouse. (The tableware only contains: bowl, knife, fork and chopsticks.) 输入要求 There are many test cases. Each case contains one line, and one integer N at the first, N indicates that there are N boxes in the warehouse. Then N strings follow, each string is one name written on the box. 输出要求 For each test of the input, output all the name of tableware. 假如输入 3 basketball fork chopsticks 2 bowl letter 应当输出 fork chopsticks bowl 提示 The tableware only contains: bowl, knife, fork and chopsticks. Java: 12345678910111213141516171819202122232425262728293031323334import java.io.BufferedInputStream;import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(new BufferedInputStream(System.in)); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add("bowl"); set.add("knife"); set.add("fork"); set.add("chopsticks"); while (scanner.hasNext()) &#123; int n = scanner.nextInt(); int i = 0; for (; i &lt; n; ++i) &#123; String tmp = scanner.next(); if (set.contains(tmp)) &#123; System.out.print(tmp); ++i; break; &#125; &#125; for (; i &lt; n; ++i) &#123; String tmp = scanner.next(); if (set.contains(tmp)) &#123; System.out.print(" " + tmp); &#125; &#125; System.out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[125. Valid Palindrome]]></title>
    <url>%2F2016%2F03%2F03%2F125-valid-palindrome%2F</url>
    <content type="text"><![CDATA[Total Accepted: 91860Total Submissions: 392114Difficulty: Easy Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, &quot;A man, a plan, a canal: Panama&quot; is a palindrome. &quot;race a car&quot; is not a palindrome. Note:Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. Java: 123456789101112131415161718192021222324252627public class Solution &#123; public boolean isPalindrome(String s) &#123; if ("".equals(s)) return true; for (int i = 0, j = s.length() - 1; i &lt; j; ++i, --j) &#123; char ci = s.charAt(i); while (i &lt; j &amp;&amp; !(ci &gt;= 'a' &amp;&amp; ci &lt;= 'z' || ci &gt;= 'A' &amp;&amp; ci &lt;= 'Z' || ci &gt;= '0' &amp;&amp; ci &lt;= '9')) ci = s.charAt(++i); char cj = s.charAt(j); while (i &lt; j &amp;&amp; !(cj &gt;= 'a' &amp;&amp; cj &lt;= 'z' || cj &gt;= 'A' &amp;&amp; cj &lt;= 'Z' || cj &gt;= '0' &amp;&amp; cj &lt;= '9')) cj = s.charAt(--j); if (i &lt; j) &#123; if (ci &gt;= 'A' &amp;&amp; ci &lt;= 'Z') ci += 32; if (cj &gt;= 'A' &amp;&amp; cj &lt;= 'Z') cj += 32; if (ci != cj) return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[204. Count Primes]]></title>
    <url>%2F2016%2F03%2F03%2F204-count-primes%2F</url>
    <content type="text"><![CDATA[Total Accepted: 54299Total Submissions: 230350Difficulty: Easy Description:Count the number of prime numbers less than a non-negative number, _n_. Credits:Special thanks to @mithmatt for adding this problem and creating all test cases. Hint: Let’s start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than _n_. The runtime complexity of isPrime function would be O(_n_) and hence counting the total prime numbers up to _n_ would be O(_n_2). Could we do better? As we know the number must not be divisible by any number &gt; _n_ / 2, we can immediately cut the total iterations half by dividing only up to _n_ / 2. Could we still do better? Let’s write down all of 12’s factors: 12342 × 6 = 123 × 4 = 124 × 3 = 126 × 2 = 12 As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to √_n_ because, if _n_ is divisible by some number _p_, then _n_ = _p_ × _q_ and since _p_ ≤ _q_, we could derive that _p_ ≤ √_n_. Our total runtime has now improved to O(_n_1.5), which is slightly better. Is there a faster approach? 1234567891011121314151617public int countPrimes(int n) &#123; int count = 0; for (int i = 1; i &lt; n; i++) &#123; if (isPrime(i)) count++; &#125; return count;&#125;private boolean isPrime(int num) &#123; if (num &lt;= 1) return false; // Loop&apos;s ending condition is i * i &lt;= num instead of i &lt;= sqrt(num) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i &lt;= num; i++) &#123; if (num % i == 0) return false; &#125; return true;&#125; The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to _n_. But don’t let that name scare you, I promise that the concept is surprisingly simple.Sieve of Eratosthenes: algorithm steps for primes below 121. “Sieve of Eratosthenes Animation” by SKopp is licensed under CC BY 2.0. We start off with a table of _n_ numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well? 4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off? In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is _p_, we can always mark off multiples of _p_ starting at _p_2, then in increments of _p_: _p_2 + _p_, _p_2 + 2_p_, … Now what should be the terminating loop condition? It is easy to say that the terminating loop condition is _p_ &lt; _n_, which is certainly correct but not efficient. Do you still remember Hint #3? Yes, the terminating loop condition can be _p_ &lt; √_n_, as all non-primes ≥ √_n_ must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime. The Sieve of Eratosthenes uses an extra O(_n_) memory and its runtime complexity is O(_n_ log log _n_). For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia. public int countPrimes(int n) { boolean[] isPrime = new boolean[n]; for (int i = 2; i < n; i++) { isPrime[i] = true; } // Loop's ending condition is i * i < n instead of i < sqrt(n) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i < n; i++) { if (!isPrime[i]) continue; for (int j = i * i; j < n; j += i) { isPrime[j] = false; } } int count = 0; for (int i = 2; i < n; i++) { if (isPrime[i]) count++; } return count; } Java: 12345678910111213141516171819public class Solution &#123; public int countPrimes(int n) &#123; if (n &lt; 3) return 0; int count = n / 2; boolean[] isPrime = new boolean[n]; for (int i = 3; i * i &lt; n; i += 2) &#123; if (isPrime[i]) continue; for (int j = i * i; j &lt; n; j += 2 * i) &#123; if (!isPrime[j]) &#123; --count; isPrime[j] = true; &#125; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7. Reverse Integer]]></title>
    <url>%2F2016%2F03%2F02%2F7-reverse-integer%2F</url>
    <content type="text"><![CDATA[Total Accepted: 125501Total Submissions: 532378Difficulty: Easy Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 click to show spoilers. Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Java: 12345678public class Solution &#123; public int reverse(int x) &#123; long res = 0; for (; x != 0; x /= 10) res = res * 10 + x % 10; return res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE ? 0: (int) res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[303. Range Sum Query - Immutable]]></title>
    <url>%2F2016%2F03%2F02%2F303-range-sum-query-immutable%2F</url>
    <content type="text"><![CDATA[Total Accepted: 20875Total Submissions: 85065Difficulty: Easy Given an integer array nums, find the sum of the elements between indices _i_ and _j_ (_i_ ≤ _j_), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -> 1 sumRange(2, 5) -> -1 sumRange(0, 5) -> -3 Note: You may assume that the array does not change. There are many calls to sumRange function. Java: 1234567891011121314public class NumArray &#123; private static int[] sum; public NumArray(int[] nums) &#123; for (int i = 1; i &lt; nums.length; ++i) nums[i] += nums[i - 1]; this.sum = nums; &#125; public int sumRange(int i, int j) &#123; return sum[j] - (i == 0 ? 0 : sum[i - 1]); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[67. Add Binary]]></title>
    <url>%2F2016%2F03%2F02%2F67-add-binary%2F</url>
    <content type="text"><![CDATA[Total Accepted: 75848Total Submissions: 283546Difficulty: Easy Given two binary strings, return their sum (also a binary string). For example,a = &quot;11&quot; b = &quot;1&quot; Return &quot;100&quot;. Java: 123456789101112131415public class Solution &#123; public String addBinary(String a, String b) &#123; StringBuilder sb = new StringBuilder(); int carry = 0, i = a.length(), j = b.length(); while (i &gt; 0 || j &gt; 0 || carry == 1) &#123; if (i &gt; 0) carry += a.charAt(--i) - '0'; if (j &gt; 0) carry += b.charAt(--j) - '0'; sb.append((char) ((carry % 2) + '0')); carry &gt;&gt;&gt;= 1; &#125; return sb.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[234. Palindrome Linked List]]></title>
    <url>%2F2016%2F03%2F02%2F234-palindrome-linked-list%2F</url>
    <content type="text"><![CDATA[Total Accepted: 39482Total Submissions: 145556Difficulty: Easy Given a singly linked list, determine if it is a palindrome. Follow up:Could you do it in O(n) time and O(1) space? Java: 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isPalindrome(ListNode head) &#123; int len = 0; ListNode p = head, tmp, newHead = null; while (p != null) &#123; p = p.next; ++len; &#125; p = head; int halfLen = len &gt;&gt;&gt; 1; for (int i = 0; i &lt; halfLen; ++i) &#123; tmp = p.next; p.next = newHead; newHead = p; p = tmp; &#125; if (len % 2 == 1) &#123; p = p.next; &#125; for (int i = 0; i &lt; halfLen; ++i) &#123; if (newHead.val != p.val) return false; newHead = newHead.next; p = p.next; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[257. Binary Tree Paths]]></title>
    <url>%2F2016%2F03%2F02%2F257-binary-tree-paths%2F</url>
    <content type="text"><![CDATA[Total Accepted: 36923Total Submissions: 135278Difficulty: Easy Given a binary tree, return all root-to-leaf paths. For example, given the following binary tree: 1 / \ 2 3 \ 5 All root-to-leaf paths are: ["1->2->5", "1->3"] Java: 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void help(List&lt;String&gt; list, TreeNode node, StringBuilder sb) &#123; if (node == null) return; int len=sb.length(); sb.append(node.val); if (node.left == null &amp;&amp; node.right == null) &#123; list.add(sb.toString()); sb.setLength(len); return; &#125; sb.append("-&gt;"); help(list, node.left, sb); help(list, node.right, sb); sb.setLength(len); &#125; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); help(res, root, new StringBuilder()); return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14. Longest Common Prefix]]></title>
    <url>%2F2016%2F03%2F01%2F14-longest-common-prefix%2F</url>
    <content type="text"><![CDATA[Total Accepted: 88409Total Submissions: 321579Difficulty: Easy Write a function to find the longest common prefix string amongst an array of strings. Java: 123456789101112131415public class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; int len = strs.length; if (len == 0) return ""; int minlen = 0x7fffffff; for (int i = 0; i &lt; len; ++i) minlen = Math.min(minlen, strs[i].length()); for (int j = 0; j &lt; minlen; ++j) for (int i = 1; i &lt; len; ++i) if (strs[0].charAt(j) != strs[i].charAt(j)) return strs[0].substring(0, j); return strs[0].substring(0, minlen); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[203. Remove Linked List Elements]]></title>
    <url>%2F2016%2F03%2F01%2F203-remove-linked-list-elements%2F</url>
    <content type="text"><![CDATA[Total Accepted: 53495Total Submissions: 191288Difficulty: Easy Remove all elements from a linked list of integers that have value val. ExampleGiven: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 Credits:Special thanks to @mithmatt for adding this problem and creating all test cases. Java: 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; while (head != null &amp;&amp; head.val == val) head = head.next; if (head == null) return null; ListNode p = head; while (p.next != null) &#123; if (p.next.val == val) &#123; p.next = p.next.next; &#125; else &#123; p = p.next; &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[38. Count and Say]]></title>
    <url>%2F2016%2F02%2F29%2F38-count-and-say%2F</url>
    <content type="text"><![CDATA[Total Accepted: 72708Total Submissions: 258534Difficulty: Easy The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, ... 1 is read off as &quot;one 1&quot; or 11. 11 is read off as &quot;two 1s&quot; or 21. 21 is read off as &quot;one 2, then one 1&quot; or 1211. Given an integer _n_, generate the _n_th sequence. Note: The sequence of integers will be represented as a string. Java: 12345678910111213141516171819202122public class Solution &#123; public String countAndSay(int n) &#123; String res = "1"; StringBuilder sb; for (int i = 2; i &lt;= n; ++i) &#123; sb = new StringBuilder(); int len = res.length(); int times = 1; for (int j = 1; j &lt; len; ++j) &#123; if (res.charAt(j - 1) == res.charAt(j)) &#123; ++times; &#125; else &#123; sb.append("" + times + res.charAt(j - 1)); times = 1; &#125; &#125; sb.append("" + times + res.charAt(len - 1)); res = sb.toString(); &#125; return res; &#125;&#125; 当然我采用了打表法beats 100% Java submition 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public String countAndSay(int n) &#123; String[] res = new String[] &#123; "1", "11", "21", "1211", "111221", "312211", "13112221", "1113213211", "31131211131221", "13211311123113112211", "11131221133112132113212221", "3113112221232112111312211312113211", "1321132132111213122112311311222113111221131221", "11131221131211131231121113112221121321132132211331222113112211", "311311222113111231131112132112311321322112111312211312111322212311322113212221", "", "", "", "", "11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211", "", "", "", "", "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221", "", "", "", "", "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211" &#125;; return res[n - 1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[290. Word Pattern]]></title>
    <url>%2F2016%2F02%2F29%2F290-word-pattern%2F</url>
    <content type="text"><![CDATA[Total Accepted: 27238Total Submissions: 96500Difficulty: Easy Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Examples: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot; should return true. pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot; should return false. pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot; should return false. pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot; should return false. Notes:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. Java: 1234567891011121314151617181920212223public class Solution &#123; public boolean wordPattern(String pattern, String str) &#123; int len = pattern.length(); String[] strs = str.split(" "); int size = strs.length; if (len != size) return false; String[] map = new String[26]; HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; len; ++i) &#123; int idx = pattern.charAt(i) - 'a'; String s = strs[i]; if (map[idx] == null) &#123; if (set.contains(s)) return false; map[idx] = s; set.add(s); &#125; else if (!map[idx].equals(s)) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20. Valid Parentheses]]></title>
    <url>%2F2016%2F02%2F29%2F20-valid-parentheses%2F</url>
    <content type="text"><![CDATA[Total Accepted: 95596Total Submissions: 332615Difficulty: Easy Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. The brackets must close in the correct order, &quot;()&quot; and &quot;()[]{}&quot; are all valid but &quot;(]&quot; and &quot;([)]&quot; are not. Java: 1234567891011121314151617181920212223public class Solution &#123; public boolean isValid(String s) &#123; int len = s.length(); char[] stack = new char[len + 1]; int top = 1; for (int i = 0; i &lt; len; ++i) &#123; char c = s.charAt(i); if (c == '(' || c == '[' || c == '&#123;') stack[top++] = c; else if (c == ')' &amp;&amp; stack[top - 1] != '(') return false; else if (c == ']' &amp;&amp; stack[top - 1] != '[') return false; else if (c == '&#125;' &amp;&amp; stack[top - 1] != '&#123;') return false; else --top; &#125; if (top == 1) return true; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[205. Isomorphic Strings]]></title>
    <url>%2F2016%2F02%2F29%2F205-isomorphic-strings%2F</url>
    <content type="text"><![CDATA[Total Accepted: 47679Total Submissions: 165936Difficulty: Easy Given two strings _s_ and _t_, determine if they are isomorphic. Two strings are isomorphic if the characters in _s_ can be replaced to get _t_. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. For example,Given &quot;egg&quot;, &quot;add&quot;, return true. Given &quot;foo&quot;, &quot;bar&quot;, return false. Given &quot;paper&quot;, &quot;title&quot;, return true. Note:You may assume both _s_ and _t_ have the same length. Java: 12345678910111213141516171819public class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; int[] times1 = new int[128], times2 = new int[128]; int len = s.length(); for (int i = 0, smax = 0, tmax = 0; i &lt; len; ++i) &#123; char sc = s.charAt(i); char tc = t.charAt(i); if (times1[sc] == 0) &#123; times1[sc] = ++smax; &#125; if (times2[tc] == 0) &#123; times2[tc] = ++tmax; &#125; if (times1[sc] != times2[tc]) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[299. Bulls and Cows]]></title>
    <url>%2F2016%2F02%2F28%2F299-bulls-and-cows%2F</url>
    <content type="text"><![CDATA[Total Accepted: 20108Total Submissions: 70200Difficulty: Easy You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. For example: Secret number: "1807" Friend's guess: "7810" Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.) Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return &quot;1A3B&quot;. Please note that both secret number and friend&#39;s guess may contain duplicate digits, for example: Secret number: "1123" Friend's guess: "0111" In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return &quot;1A1B&quot;. You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal. Java: 1234567891011121314151617181920public class Solution &#123; public String getHint(String secret, String guess) &#123; int len = secret.length(); int[] secretarr = new int[10]; int[] guessarr = new int[10]; int bull = 0, cow = 0; for (int i = 0; i &lt; len; ++i) &#123; if (secret.charAt(i) == guess.charAt(i)) &#123; ++bull; &#125; else &#123; ++secretarr[secret.charAt(i) - '0']; ++guessarr[guess.charAt(i) - '0']; &#125; &#125; for (int i = 0; i &lt; 10; ++i) &#123; cow += Math.min(secretarr[i], guessarr[i]); &#125; return "" + bull + "A" + cow + "B"; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2F2016%2F02%2F27%2F19-remove-nth-node-from-end-of-list%2F</url>
    <content type="text"><![CDATA[Total Accepted: 96063Total Submissions: 333812Difficulty: Easy Given a linked list, remove the _n_th node from the end of list and return its head. For example, Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note:Given _n_ will always be valid.Try to do this in one pass. Java: 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = head, after = head; while (n-- != 0) &#123; after = after.next; &#125; if (after != null) &#123; while (after.next != null) &#123; pre = pre.next; after = after.next; &#125; pre.next = pre.next.next; &#125; else &#123; return head.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[58. Length of Last Word]]></title>
    <url>%2F2016%2F02%2F27%2F58-length-of-last-word%2F</url>
    <content type="text"><![CDATA[Total Accepted: 83878Total Submissions: 291685Difficulty: Easy Given a string _s_ consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example,Given _s_ = &quot;Hello World&quot;, return 5. Java: 12345678910public class Solution &#123; public int lengthOfLastWord(String s) &#123; s = s.trim(); if (s.equals("")) return 0; int res = 0; for (int i = s.length() - 1; i &gt; -1 &amp;&amp; s.charAt(i) != ' '; ++res, --i); return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[190. Reverse Bits]]></title>
    <url>%2F2016%2F02%2F27%2F190-reverse-bits%2F</url>
    <content type="text"><![CDATA[Total Accepted: 54042Total Submissions: 185450Difficulty: Easy Reverse bits of a given 32 bits unsigned integer. For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000). Follow up:If this function is called many times, how would you optimize it? Related problem: Reverse Integer Java: 1234567891011121314public class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; int res = 0; for (int i = 0; i &lt; 32; ++i) &#123; res &lt;&lt;= 1; if(n != 0)&#123; res += n % 2; n &gt;&gt;&gt;= 1; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[219. Contains Duplicate II]]></title>
    <url>%2F2016%2F02%2F26%2F219-contains-duplicate-ii%2F</url>
    <content type="text"><![CDATA[Total Accepted: 46925Total Submissions: 160698Difficulty: Easy Given an array of integers and an integer _k_, find out whether there are two distinct indices _i_ and _j_ in the array such that nums[i] = nums[j] and the difference between _i_ and _j_ is at most _k_. Java: 123456789101112131415161718192021222324252627282930public class Solution &#123; public class MyArr &#123; int data; int index; &#125; class mycmp implements Comparator&lt;MyArr&gt; &#123; @Override public int compare(MyArr o1, MyArr o2) &#123; return o1.data - o2.data; &#125; &#125; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; int len = nums.length; MyArr[] myArrs = new MyArr[len]; for (int i = 0; i &lt; len; ++i) &#123; myArrs[i] = new MyArr(); myArrs[i].data = nums[i]; myArrs[i].index = i; &#125; Arrays.sort(myArrs, 0, len, new mycmp()); for (int i = 0; i &lt; len - 1; i++) &#123; if (myArrs[i].data == myArrs[i + 1].data &amp;&amp; Math.abs((myArrs[i].index - myArrs[i + 1].index)) &lt;= k) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[28. Implement strStr()]]></title>
    <url>%2F2016%2F02%2F25%2F28-implement-strstr%2F</url>
    <content type="text"><![CDATA[Total Accepted: 93775Total Submissions: 386039Difficulty: Easy Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Java: 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int strStr(String haystack, String needle) &#123; int len1 = haystack.length(); int len2 = needle.length(); if (len2 == 0) return 0; int[] next = new int[len2]; char[] substr = needle.toCharArray(); char[] str = haystack.toCharArray(); getNext(substr, next); int i = 0, j = 0; while (i &lt; len1 &amp;&amp; j &lt; len2) &#123; if (j == -1 || str[i] == substr[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; if (len2 == j) return i - j; return -1; &#125; private void getNext(char str[], int next[]) &#123; int i = 0, j = -1; next[0] = -1; int len = str.length; while (i &lt; len - 1) &#123; if (j == -1 || str[i] == str[j]) &#123; ++i; ++j; if (str[i] == str[j]) next[i] = next[j]; else next[i] = j; &#125; else j = next[j]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[223. Rectangle Area]]></title>
    <url>%2F2016%2F02%2F21%2F223-rectangle-area%2F</url>
    <content type="text"><![CDATA[Total Accepted: 30441Total Submissions: 104452Difficulty: Easy Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Assume that the total area is never beyond the maximum possible value of int. Java: 12345678public class Solution &#123; public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int r = (C - A) * (D - B) + (G - E) * (H - F); if (!(A &gt;= G || B &gt;= H || C &lt;= E || D &lt;= F)) r -= (Math.min(C, G) - Math.max(A, E)) * (Math.min(D, H) - Math.max(B, F)); return r; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[88. Merge Sorted Array]]></title>
    <url>%2F2016%2F02%2F21%2F88-merge-sorted-array%2F</url>
    <content type="text"><![CDATA[Total Accepted: 88608Total Submissions: 297379Difficulty: Easy Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to _m_ + _n_) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are _m_ and _n_ respectively. Java: 123456789public class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int k = m-- + n-- - 1; while (m &gt;= 0 &amp;&amp; n &gt;= 0) nums1[k--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--]; while (n &gt;= 0) nums1[k--] = nums2[n--]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[160. Intersection of Two Linked Lists]]></title>
    <url>%2F2016%2F02%2F18%2F160-intersection-of-two-linked-lists%2F</url>
    <content type="text"><![CDATA[Total Accepted: 62565Total Submissions: 208321Difficulty: Easy Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. Credits:Special thanks to @stellari for adding this problem and creating all test cases. Java: 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null)return null; ListNode a=headA; ListNode b=headB; while(a!=b)&#123; a=a==null?headB:a.next; b=b==null?headA:b.next; &#125; return a; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[111. Minimum Depth of Binary Tree]]></title>
    <url>%2F2016%2F02%2F18%2F111-minimum-depth-of-binary-tree%2F</url>
    <content type="text"><![CDATA[Total Accepted: 93588Total Submissions: 309967Difficulty: Easy Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Java: 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null)return 0; Queue&lt;TreeNode&gt; comeIn=new LinkedList&lt;TreeNode&gt;(); int res=0; comeIn.offer(root); while(!comeIn.isEmpty())&#123; int size=comeIn.size(); res++; for(int i = 0;i &lt; size; ++ i)&#123; TreeNode tmp=comeIn.poll(); if(tmp.left == null &amp;&amp; tmp.right == null) return res; if(tmp.left != null) comeIn.offer(tmp.left); if(tmp.right != null) comeIn.offer(tmp.right); &#125; &#125; return 520; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[225. Implement Stack using Queues]]></title>
    <url>%2F2016%2F02%2F18%2F225-implement-stack-using-queues%2F</url>
    <content type="text"><![CDATA[Total Accepted: 31239Total Submissions: 102745Difficulty: Easy Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). Java: 1234567891011121314151617181920212223class MyStack &#123; private Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); // Push element x onto stack. public void push(int x) &#123; queue.add(x); &#125; // Removes the element on top of the stack. public void pop() &#123; queue.removeLast(); &#125; // Get the top element. public int top() &#123; return queue.getLast(); &#125; // Return whether the stack is empty. public boolean empty() &#123; return queue.size()==0; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9. Palindrome Number]]></title>
    <url>%2F2016%2F02%2F17%2F9-palindrome-number%2F</url>
    <content type="text"><![CDATA[Total Accepted: 106331Total Submissions: 345763Difficulty: Easy Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. Java: 12345678910111213public class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int y = 0, x1 = 1; while (x / x1 != 0) &#123; y = y * 10 + x % 10; x /= 10; x1 *= 10; &#125; return y &lt; 10 * x ? y == x : y / 10 == x; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[112. Path Sum]]></title>
    <url>%2F2016%2F02%2F17%2F112-path-sum%2F</url>
    <content type="text"><![CDATA[Total Accepted: 90381Total Submissions: 293367Difficulty: Easy Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. Java: 12345678910111213141516171819/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return (root.val == sum); return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[119. Pascal's Triangle II]]></title>
    <url>%2F2016%2F02%2F17%2F119-pascals-triangle-ii%2F</url>
    <content type="text"><![CDATA[Total Accepted: 66540Total Submissions: 211819Difficulty: Easy Given an index _k_, return the _k_th row of the Pascal’s triangle. For example, given _k_ = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only _O_(_k_) extra space? Java: 1234567891011public class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; Integer[] arr = new Integer[rowIndex + 1]; int end = (rowIndex + 2) &gt;&gt; 1; arr[0] = arr[rowIndex] = 1; long j = rowIndex; for (int i = 1; i &lt; end; ++i, --j) arr[i] = arr[rowIndex - i] = (int) (j * arr[i - 1] / i); return Arrays.asList(arr); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[102. Binary Tree Level Order Traversal]]></title>
    <url>%2F2016%2F02%2F17%2F102-binary-tree-level-order-traversal%2F</url>
    <content type="text"><![CDATA[Total Accepted: 89586Total Submissions: 282417Difficulty: Easy Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree {3,9,20,#,#,15,7}, 3 / \ 9 20 / \ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] confused what&quot;{1,#,2,3}&quot; means? &gt; read more on how binary tree is serialized on OJ. Java: 宽搜:1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.offer(root); while (!q.isEmpty()) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); int size = q.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode t = q.poll(); if (t.left != null) q.offer(t.left); if (t.right != null) q.offer(t.right); tmp.add(t.val); &#125; res.add(tmp); &#125; return res; &#125;&#125; 深搜:123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); dfs(res,root,0); return res; &#125; public void dfs(List&lt;List&lt;Integer&gt;&gt; list,TreeNode node,int deep)&#123; if(node==null)return; if(list.size()==deep) list.add(new ArrayList&lt;Integer&gt;()); list.get(deep).add(node.val); dfs(list, node.left, deep+1); dfs(list, node.right, deep+1); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[172. Factorial Trailing Zeroes]]></title>
    <url>%2F2016%2F02%2F17%2F172-factorial-trailing-zeroes%2F</url>
    <content type="text"><![CDATA[Total Accepted: 50404Total Submissions: 158693Difficulty: Easy Given an integer _n_, return the number of trailing zeroes in _n_!. Note: Your solution should be in logarithmic time complexity. Credits:Special thanks to @ts for adding this problem and creating all test cases. Java 1234567891011public class Solution &#123; public int trailingZeroes(int n) &#123; int res = 0; while(n &gt; 4) &#123; res += n / 5; n /= 5; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[118. Pascal's Triangle]]></title>
    <url>%2F2016%2F02%2F17%2F118-pascals-triangle%2F</url>
    <content type="text"><![CDATA[Total Accepted: 73821Total Submissions: 227589Difficulty: Easy Given numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5, Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] Java: 1234567891011121314151617public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; row, pre = null; for (int i = 0; i &lt; numRows; ++i) &#123; row = new ArrayList&lt;Integer&gt;(); for (int j = 0; j &lt;= i; ++j) if (j == 0 || j == i) row.add(1); else row.add(pre.get(j - 1) + pre.get(j)); pre = row; res.add(row); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[66. Plus One]]></title>
    <url>%2F2016%2F02%2F17%2F66-plus-one%2F</url>
    <content type="text"><![CDATA[Total Accepted: 86284Total Submissions: 264435Difficulty: Easy Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. Java: 1234567891011121314151617public class Solution &#123; public int[] plusOne(int[] digits) &#123; int i = digits.length - 1; if (digits[i] &lt; 9) digits[i]++; else &#123; for (; i &gt;= 0 &amp;&amp; digits[i] == 9; --i) digits[i] = 0; if (digits[0] == 0) &#123; digits = new int[digits.length + 1]; digits[0] = 1; &#125; else digits[i]++; &#125; return digits; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[278. First Bad Version]]></title>
    <url>%2F2016%2F02%2F16%2F278-first-bad-version%2F</url>
    <content type="text"><![CDATA[Total Accepted: 31954Total Submissions: 146259Difficulty: Easy You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Java: 1234567891011121314/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int l=1,r=n; while(l&lt;r)&#123; int mid=l+((r-l)&gt;&gt;1); if (!isBadVersion(mid)) l = mid + 1; else r = mid; &#125; return l; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[155. Min Stack]]></title>
    <url>%2F2016%2F02%2F16%2F155-min-stack%2F</url>
    <content type="text"><![CDATA[Total Accepted: 61492Total Submissions: 286112Difficulty: Easy Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Java: 1234567891011121314151617181920212223242526272829class MinStack &#123; Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); int min=Integer.MAX_VALUE; public void push(int x) &#123; if(x&lt;=min)&#123; //save the last min element stack.push(min); min=x; &#125; stack.push(x); &#125; public void pop() &#123; if(min==stack.pop())&#123; min=stack.peek(); stack.pop(); &#125; if(stack.empty()) min=Integer.MAX_VALUE; &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[168. Excel Sheet Column Title]]></title>
    <url>%2F2016%2F02%2F16%2F168-excel-sheet-column-title%2F</url>
    <content type="text"><![CDATA[Total Accepted: 51862Total Submissions: 249733Difficulty: Easy Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 1 -> A 2 -> B 3 -> C ... 26 -> Z 27 -> AA 28 -> AB Java: 12345678910public class Solution &#123; public String convertToTitle(int n) &#123; StringBuilder sb = new StringBuilder(); while(n!=0)&#123; sb.insert(0,(char)('A' + --n % 26)); n/=26; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[189. Rotate Array]]></title>
    <url>%2F2016%2F02%2F16%2F189-rotate-array%2F</url>
    <content type="text"><![CDATA[Total Accepted: 61150Total Submissions: 300206Difficulty: Easy Rotate an array of _n_ elements to the right by _k_ steps. For example, with _n_ = 7 and _k_ = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note:Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Java: 12345678910111213141516public class Solution &#123; public void reverse(int[] nums,int l,int r)&#123; while(l&lt;r)&#123; int temp=nums[l]; nums[l++]=nums[--r]; nums[r]=temp; &#125; &#125; public void rotate(int[] nums, int k) &#123; int n=nums.length; k=k%n; reverse(nums, 0 ,n-k); reverse(nums, n-k,n ); reverse(nums, 0 ,n ); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[165. Compare Version Numbers]]></title>
    <url>%2F2016%2F02%2F16%2F165-compare-version-numbers%2F</url>
    <content type="text"><![CDATA[Total Accepted: 45172Total Submissions: 268283Difficulty: Easy Compare two version numbers version1 and version2.If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. Here is an example of version numbers ordering: 0.1 < 1.1 < 1.2 < 13.37 Java: 12345678910111213141516public class Solution &#123; public int compareVersion(String version1, String version2) &#123; int len1=version1.length(),len2=version2.length(),i1=-1,i2=-1; while(i1&lt;len1||i2&lt;len2)&#123; ++i1;++i2; int v1=0,v2=0; while(i1&lt;len1&amp;&amp;version1.charAt(i1)!='.') v1=v1*10+version1.charAt(i1++)-'0'; while(i2&lt;len2&amp;&amp;version2.charAt(i2)!='.') v2=v2*10+version2.charAt(i2++)-'0'; if(v1!=v2) return v1&gt;v2?1:-1; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8. String to Integer (atoi)]]></title>
    <url>%2F2016%2F02%2F16%2F8-string-to-integer-atoi%2F</url>
    <content type="text"><![CDATA[Total Accepted: 87527Total Submissions: 658165Difficulty: Easy Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10):The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. spoilers alert… click to show requirements for atoi. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 因为没有看到红字部分，都是一直提交来查看错误，哈哈哈，所以略坑 Java: 1234567891011121314151617181920public class Solution &#123; public int myAtoi(String str) &#123; if(str.isEmpty()) return 0; str=str.trim(); int i=0,ans=0,sign=1,len=str.length(); if(str.charAt(i)=='-'||str.charAt(i)=='+') sign=str.charAt(i++)=='+'?1:-1; for(;i&lt;len;++i)&#123; int tmp=str.charAt(i)-'0'; if(tmp&lt;0||tmp&gt;9) break; if(ans&gt;Integer.MAX_VALUE/10||ans==Integer.MAX_VALUE/10&amp;&amp;Integer.MAX_VALUE %10 &lt; tmp) return sign==1?Integer.MAX_VALUE:Integer.MIN_VALUE; else ans=ans*10+tmp; &#125; return sign*ans; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26. Remove Duplicates from Sorted Array]]></title>
    <url>%2F2016%2F02%2F16%2F26-remove-duplicates-from-sorted-array%2F</url>
    <content type="text"><![CDATA[Total Accepted: 112046Total Submissions: 342076Difficulty: Easy Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 1 respectively. It doesn’t matter what you leave beyond the new length. Java: 123456789101112131415public class Solution &#123; public int removeDuplicates(int[] nums) &#123; int dupes = 0; int len=nums.length; for (int i = 1; i &lt; len; i++) &#123; if (nums[i] == nums[i - 1]) dupes++; nums[i - dupes] = nums[i]; &#125; return len - dupes; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[27. Remove Element]]></title>
    <url>%2F2016%2F02%2F16%2F27-remove-element%2F</url>
    <content type="text"><![CDATA[Total Accepted: 101318Total Submissions: 307664Difficulty: Easy Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Java: 12345678910public class Solution &#123; public int removeElement(int[] nums, int val) &#123; int len=nums.length; int res=0; for(int i=0;i&lt;len;++i) if(nums[i]!=val) nums[res++]=nums[i]; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[107. Binary Tree Level Order Traversal II]]></title>
    <url>%2F2016%2F02%2F16%2F107-binary-tree-level-order-traversal-ii%2F</url>
    <content type="text"><![CDATA[Total Accepted: 70095Total Submissions: 211952Difficulty: Easy Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree {3,9,20,#,#,15,7}, 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] confused what &quot;{1,#,2,3}&quot; means? &gt; read more on how binary tree is serialized on OJ. Java: 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res=new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root==null) return res; Queue&lt;TreeNode&gt; q =new LinkedList&lt;TreeNode&gt;(); q.offer(root); while(!q.isEmpty())&#123; int size=q.size(); List&lt;Integer&gt; tmp=new LinkedList&lt;Integer&gt;(); for(int i=0;i&lt;size;++i)&#123; TreeNode temp=q.poll(); if(temp.left!=null) q.offer(temp.left); if(temp.right!=null) q.offer(temp.right); tmp.add(temp.val); &#125; res.add(0, tmp); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[198. House Robber]]></title>
    <url>%2F2016%2F02%2F14%2F198-house-robber%2F</url>
    <content type="text"><![CDATA[Total Accepted: 54030Total Submissions: 163275Difficulty: Easy You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 典型的动态规划，dp[i]代表前i个数中可取最大值dp[i]=Math.max(dp[i-1],nums[i]+dp[i-2]); Java: 123456789101112131415161718public class Solution &#123; public int rob(int[] nums) &#123; int n=nums.length; if(n==0) return 0; if(n==1) return nums[0]; if(n==2) return Math.max(nums[0],nums[1]); int[] dp= new int[n]; dp[0]=nums[0]; dp[1]=Math.max(nums[0],nums[1]); for(int i=2;i&lt;n;++i)&#123; dp[i]=Math.max(dp[i-1],nums[i]+dp[i-2]); &#125; return dp[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[101. Symmetric Tree]]></title>
    <url>%2F2016%2F02%2F13%2F101-symmetric-tree%2F</url>
    <content type="text"><![CDATA[Total Accepted: 93600Total Submissions: 281557Difficulty: Easy Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following is not: 1 / \ 2 2 \ \ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. confused what &quot;{1,#,2,3}&quot; means? &gt; read more on how binary tree is serialized on OJ. Java: 递归:1234567891011121314151617181920212223 * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) return true; return isSymmetric(root.left ,root.right); &#125; public boolean isSymmetric(TreeNode node1 , TreeNode node2)&#123; if(node1 == null &amp;&amp; node2 == null) return true; if(node1 == null || node2 == null) return false; return node1.val == node2.val &amp;&amp;isSymmetric(node1.left, node2.right) &amp;&amp; isSymmetric(node1.right,node2.left); &#125;&#125; 单队列：123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) return true; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.offer(root.left); q.offer(root.right); while (!q.isEmpty()) &#123; TreeNode l = q.poll(); TreeNode r = q.poll(); if (l == null &amp;&amp; r == null) continue; if (l == null || r == null) return false; if(l.val!=r.val) return false; q.offer(l.left); q.offer(r.right); q.offer(l.right); q.offer(r.left); &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[110. Balanced Binary Tree]]></title>
    <url>%2F2016%2F02%2F13%2F110-balanced-binary-tree%2F</url>
    <content type="text"><![CDATA[Total Accepted: 96062Total Submissions: 287739Difficulty: Easy Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Java: 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return check(root)!=-1; &#125; public int check(TreeNode root)&#123; if(root==null) return 0; int lh=check(root.left); if(lh==-1) return -1; int rh=check(root.right); if(rh==-1) return -1; if(Math.abs(lh-rh)&gt;1) return -1; return 1+Math.max(lh, rh); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[232. Implement Queue using Stacks]]></title>
    <url>%2F2016%2F02%2F13%2F232-implement-queue-using-stacks%2F</url>
    <content type="text"><![CDATA[Total Accepted: 33142Total Submissions: 97820Difficulty: Easy Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue. pop() – Removes the element from in front of queue. peek() – Get the front element. empty() – Return whether the queue is empty. Notes: You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. Youmay simulate a stack by using a list or deque (double-ended queue), aslong as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 两个栈来实现队列的效果 Java: 12345678910111213141516171819202122232425262728class MyQueue &#123; Stack&lt;Integer&gt; input = new Stack(); Stack&lt;Integer&gt; output = new Stack(); // Push element x to the back of queue. public void push(int x) &#123; input.push(x); &#125; // Removes the element from in front of queue. public void pop() &#123; peek(); output.pop(); &#125; // Get the front element. public int peek() &#123; if (output.empty()) while (!input.empty()) output.push(input.pop()); return output.peek(); &#125; // Return whether the queue is empty. public boolean empty() &#123; return input.empty() &amp;&amp; output.empty(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2F2016%2F02%2F13%2F21-merge-two-sorted-lists%2F</url>
    <content type="text"><![CDATA[Total Accepted: 107818Total Submissions: 312053Difficulty: Easy Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Java: 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode ans=new ListNode(0); ListNode temp=ans; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;l2.val)&#123; temp.next=l1; l1=l1.next; &#125;else&#123; temp.next=l2; l2=l2.next; &#125; temp=temp.next; &#125; if(l1!=null) temp.next=l1; else temp.next=l2; return ans.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[326. Power of Three]]></title>
    <url>%2F2016%2F02%2F13%2F326-power-of-three%2F</url>
    <content type="text"><![CDATA[Total Accepted: 18416Total Submissions: 52117Difficulty: Easy Given an integer, write a function to determine if it is a power of three. Follow up: Could you do it without using any loop / recursion? Java: 12345public class Solution &#123; public boolean isPowerOfThree(int n) &#123; return n==Math.pow(3, (int)Math.round(Math.log10(n)/Math.log10(3))); &#125;&#125; 更好的当然是这个了 12345public class Solution &#123; public boolean isPowerOfThree(int n) &#123; return n&gt;0&amp;&amp;1162261467%n==0; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[202. Happy Number]]></title>
    <url>%2F2016%2F02%2F13%2F202-happy-number%2F</url>
    <content type="text"><![CDATA[Total Accepted: 54163Total Submissions: 152329Difficulty: Easy Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 Credits:Special thanks to @mithmatt and @ts for adding this problem and creating all test cases. Java: 12345678910111213public class Solution &#123; public boolean isHappy(int n) &#123; while(n&gt;6)&#123; int temp=0; while(n!=0)&#123; temp+=(n%10)*(n%10); n/=10; &#125; n=temp; &#125; return n==1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[263. Ugly Number]]></title>
    <url>%2F2016%2F02%2F12%2F263-ugly-number%2F</url>
    <content type="text"><![CDATA[Total Accepted: 41516Total Submissions: 116368Difficulty: Easy Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 注意0不是就好 Java: 123456789public class Solution &#123; public boolean isUgly(int num) &#123; if(num==0) return false; while(num%2==0) num=num&gt;&gt;1; while(num%3==0) num=num/3; while(num%5==0) num=num/5; return num==1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[70. Climbing Stairs]]></title>
    <url>%2F2016%2F02%2F12%2F70-climbing-stairs%2F</url>
    <content type="text"><![CDATA[Total Accepted: 93127Total Submissions: 258282Difficulty: Easy You are climbing a stair case. It takes _n_ steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Java: 123456789public class Solution &#123; public int climbStairs(int n) &#123; int[] ans=new int[n+1]; ans[0]=ans[1]=1; for(int i=2;i&lt;=n;++i) ans[i]=ans[i-1]+ans[i-2]; return ans[n]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[83. Remove Duplicates from Sorted List]]></title>
    <url>%2F2016%2F02%2F12%2F83-remove-duplicates-from-sorted-list%2F</url>
    <content type="text"><![CDATA[Total Accepted: 100371Total Submissions: 278401Difficulty: Easy Given a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. Java: 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null||head.next==null) return head; ListNode curr = head; ListNode itr = head; while(curr.next != null) &#123; while(itr.val == curr.val &amp;&amp; itr.next != null) &#123; itr = itr.next; &#125; if(curr.val != itr.val) &#123; curr.next = itr; curr = curr.next; &#125; else &#123; curr.next = null; &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[191. Number of 1 Bits]]></title>
    <url>%2F2016%2F02%2F10%2F191-number-of-1-bits%2F</url>
    <content type="text"><![CDATA[Total Accepted: 74078Total Submissions: 196833Difficulty: Easy Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. java中需要注意符号位，因为符号位也算1，所以就要用&gt;&gt;&gt;无符号右移 Java: 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int ans=0; while(n!=0)&#123; ans+=(n&amp;1); n&gt;&gt;&gt;=1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13. Roman to Integer]]></title>
    <url>%2F2016%2F02%2F10%2F13-roman-to-integer%2F</url>
    <content type="text"><![CDATA[Total Accepted: 71392Total Submissions: 188974Difficulty: Easy Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Java: 12345678910111213141516171819202122public class Solution &#123; public int romanToInt(String s) &#123; int len=s.length()-1; int[] hash=new int[26]; hash['I'-'A']=1; hash['V'-'A']=5; hash['X'-'A']=10; hash['L'-'A']=50; hash['C'-'A']=100; hash['D'-'A']=500; hash['M'-'A']=1000; int i=0,ans=0; for(;i&lt;len;++i)&#123; if(hash[s.charAt(i)-'A']&lt;hash[s.charAt(i+1)-'A']) ans-=hash[s.charAt(i)-'A']; else ans+=hash[s.charAt(i)-'A']; &#125; return ans+hash[s.charAt(i)-'A']; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2F2016%2F02%2F10%2F206-reverse-linked-list%2F</url>
    <content type="text"><![CDATA[Total Accepted: 81448Total Submissions: 214931Difficulty: Easy Reverse a singly linked list. click to show more hints. Hint: A linked list can be reversed either iteratively or recursively. Could you implement both? 发现java大部分是最快的，难道是easy题目的原因？ Java: 1234567891011121314151617181920/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode re=null,t; while(head!=null)&#123; t=head.next; head.next=re; re=head; head=t; &#125; return re; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[328. Odd Even Linked List]]></title>
    <url>%2F2016%2F02%2F10%2F328-odd-even-linked-list%2F</url>
    <content type="text"><![CDATA[Total Accepted: 12675Total Submissions: 33458Difficulty: Easy Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note:The relative order inside both the even and odd groups should remain as it was in the input.The first node is considered odd, the second node even and so on … C++: 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if(head==NULL) return NULL; ListNode *odd=head,*even=head-&gt;next,*te=even; while(even&amp;&amp;even-&gt;next)&#123; odd-&gt;next=even-&gt;next; odd=odd-&gt;next; even-&gt;next=odd-&gt;next; even=even-&gt;next; &#125; odd-&gt;next=te; return head; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[235. Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2F2016%2F02%2F10%2F235-lowest-common-ancestor-of-a-binary-search-tree%2F</url>
    <content type="text"><![CDATA[Total Accepted: 52403Total Submissions: 137993Difficulty: Easy Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” _______6______ / \ ___2__ ___8__ / \ / \ 0 _4 7 9 / \ 3 5 For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. 二叉搜索树的找到两个节点的最近双亲 C++: 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; while((root-&gt;val-p-&gt;val)*(root-&gt;val-q-&gt;val)&gt;0) root=p-&gt;val&lt;root-&gt;val?root-&gt;left:root-&gt;right; return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[169. Majority Element]]></title>
    <url>%2F2016%2F02%2F10%2F169-majority-element%2F</url>
    <content type="text"><![CDATA[Total Accepted: 92197Total Submissions: 232301Difficulty: Easy Given an array of size _n_, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 还是hash，hash中过半即答案 C++: 12345678class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; h; for(int i=0,n=nums.size();i&lt;n;++i) if(++h[nums[i]]&gt;n/2)return nums[i]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Divide and Conquer</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[171. Excel Sheet Column Number]]></title>
    <url>%2F2016%2F02%2F10%2F171-excel-sheet-column-number%2F</url>
    <content type="text"><![CDATA[Total Accepted: 64100Total Submissions: 159751Difficulty: Easy Related to question Excel Sheet Column Title Given a column title as appear in an Excel sheet, return its corresponding column number. For example: A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 我是把它看成是类似是26进制 C++: 123456789class Solution &#123;public: int titleToNumber(string s) &#123; int ans = 0; for(int i = 0; i &lt; s.length(); ++i) ans = ans * 26 + s[i] - 'A' + 1; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[217. Contains Duplicate]]></title>
    <url>%2F2016%2F02%2F10%2F217-contains-duplicate%2F</url>
    <content type="text"><![CDATA[Total Accepted: 67962Total Submissions: 169476Difficulty: Easy Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. C++: 1234567891011121314class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); unordered_map&lt;int,int&gt; h; for(int i=0;i&lt;n;++i)&#123; if(h.count(nums[i]))&#123; return true; &#125; h[nums[i]]=1; &#125; return false; &#125;&#125;; 看到了使用set的，表示佩服，代码只需一行 1234class Solution &#123; public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; return set&lt;int&gt;(nums.begin(), nums.end()).size() &lt; nums.size(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[242. Valid Anagram]]></title>
    <url>%2F2016%2F02%2F10%2F242-valid-anagram%2F</url>
    <content type="text"><![CDATA[Total Accepted: 58209Total Submissions: 143425Difficulty: Easy Given two strings _s_ and _t_, write a function to determine if _t_ is an anagram of _s_. For example,_s_ = “anagram”, _t_ = “nagaram”, return true._s_ = “rat”, _t_ = “car”, return false. Note:You may assume the string contains only lowercase alphabets. Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? 求两个字符串中字母出现频率是否一致，hash最快了当然 C++: 12345678910111213141516171819class Solution &#123;public: bool isAnagram(string s, string t) &#123; int l1=s.length(); int l2=t.length(); if(l1!=l2) return false; int hash[26]=&#123;0&#125;; for(int i=0;i&lt;l1;++i)&#123; ++hash[s[i]-'a']; --hash[t[i]-'a']; &#125; for(int i=0;i&lt;26;++i)&#123; if(hash[i]) return false; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100. Same Tree]]></title>
    <url>%2F2016%2F02%2F10%2F100-same-tree%2F</url>
    <content type="text"><![CDATA[Total Accepted: 109175Total Submissions: 255839Difficulty: Easy Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 当然我的代码还可以缩短很多，但这样清晰明了 C++: 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(p!=NULL&amp;&amp;q==NULL)&#123; return false; &#125; else if(p==NULL&amp;&amp;q!=NULL)&#123; return false; &#125; else if(p!=NULL&amp;&amp;q!=NULL)&#123; if(p-&gt;val!=q-&gt;val)&#123; return false; &#125; if(!isSameTree(p-&gt;left,q-&gt;left))&#123; return false; &#125; if(!isSameTree(p-&gt;right,q-&gt;right))&#123; return false; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[283. Move Zeroes]]></title>
    <url>%2F2016%2F02%2F10%2F283-move-zeroes%2F</url>
    <content type="text"><![CDATA[Total Accepted: 67030Total Submissions: 139534Difficulty: Easy Given an array nums, write a function to move all 0‘s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums &amp;nbsp;= [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 先把非零的写好，最后都把0写在最后即可 C++: 12345678910111213class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int i=0,n=nums.size(),j=0; for(;i&lt;n;++i)&#123; if(nums[i]!=0)&#123; nums[j++]=nums[i]; &#125; &#125; for(;j&lt;n;j++) nums[j]=0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[226. Invert Binary Tree]]></title>
    <url>%2F2016%2F02%2F10%2F226-invert-binary-tree%2F</url>
    <content type="text"><![CDATA[Total Accepted: 67715Total Submissions: 155630Difficulty: Easy Invert a binary tree. 4 / \ 2 7 / \ / \ 1 3 6 9 to 4 / \ 7 2 / \ / \ 9 6 3 1 一种是用递归，一种是用栈，代码如下 C++: 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; /*递归 if (root == NULL) &#123; return NULL; &#125; TreeNode* left = root-&gt;left; TreeNode* right = root-&gt;right; root-&gt;left = invertTree(right); root-&gt;right = invertTree(left); return root; /* if(root==NULL) return root; queue&lt;TreeNode *&gt;q; q.push(root); while(!q.empty())&#123; auto node=q.front(); q.pop(); auto temp=node-&gt;left; node-&gt;left=node-&gt;right; node-&gt;right=temp; if(node-&gt;left!=NULL) q.push(node-&gt;left); if(node-&gt;right!=NULL) q.push(node-&gt;right); &#125; return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[237. Delete Node in a Linked List]]></title>
    <url>%2F2016%2F02%2F10%2F237-delete-node-in-a-linked-list%2F</url>
    <content type="text"><![CDATA[Total Accepted: 61181Total Submissions: 139905Difficulty: Easy Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. 标准写当然需要delete了，不标准的话就直接*node=node-&gt;next；即可 C++: 12345678910111213141516/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; ListNode *next = node-&gt;next; *node = *next; delete next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
    <url>%2F2016%2F02%2F10%2F104-maximum-depth-of-binary-tree%2F</url>
    <content type="text"><![CDATA[Total Accepted: 120354Total Submissions: 255664Difficulty: Easy Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 一种是递归后序遍历树，返回深度，一种是层次遍历，有几层便是深度。 C++: 123456789101112131415161718192021222324252627282930313233343536373839404142 * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; /* if(root==NULL) return 0; int rd=maxDepth(root-&gt;right); int ld=maxDepth(root-&gt;left); return 1+max(rd,ld); */ if(root == NULL) return 0; int res = 0; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; ++ res; for(int i = 0, n = q.size(); i &lt; n; ++ i) &#123; TreeNode *p = q.front(); q.pop(); if(p -&gt; left != NULL) q.push(p -&gt; left); if(p -&gt; right != NULL) q.push(p -&gt; right); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[258. Add Digits]]></title>
    <url>%2F2016%2F02%2F10%2F258-add-digits%2F</url>
    <content type="text"><![CDATA[Total Accepted: 67030Total Submissions: 139534Difficulty: Easy Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up:Could you do it without any loop/recursion in O(1) runtime? Hint: A naive implementation of the above process is trivial. Could you come up with other methods? O(1)的话自然不能用循环了，答案就是余九之后的结果，但除了0之外9的倍数的话都还是9，所以改动一下减1再余九再加一即可。 C++: 123456class Solution &#123;public: int addDigits(int num) &#123; return (num - 1) % 9 + 1; &#125;&#125;; 有趣的是同样的代码Java比C++和C都跑得快]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[292. Nim Game]]></title>
    <url>%2F2016%2F02%2F10%2F292-nim-game%2F</url>
    <content type="text"><![CDATA[Total Accepted: 43053Total Submissions: 84298Difficulty: Easy You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. Hint: If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner? 谁先抢到4的倍数就是赢家。 C++: 123456class Solution &#123;public: bool canWinNim(int n) &#123; return n%4!=0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Brainteaser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prim&Dijkstra]]></title>
    <url>%2F2016%2F02%2F08%2Fprim-dijkstra%2F</url>
    <content type="text"><![CDATA[先是求最小生成树的Prim算法 首先输入两个整数 n 和 m，表示图中的顶点数和边数。接下来一共 m 行，每行三个整数 a，b，c，表示一条连接 a 和 b 的权重为 c 的带权无向边。程序最终会将最小生成树上所有边权之和输出。 比如输入下面这张图： 对应的输入数据为 5 7 0 1 75 0 2 9 1 2 95 1 3 51 2 3 19 2 4 42 3 4 31 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int INF = 0x3f3f3f3f;struct Edge &#123; int vertex, weight;&#125;;class Graph &#123;private: int n; bool * visited; vector&lt;Edge&gt; * edges;public: int * dist; Graph (int input_n) &#123; n = input_n; edges = new vector&lt;Edge&gt;[n]; dist = new int[n]; visited = new bool[n]; memset(visited, false, n * sizeof(bool)); memset(dist, 0x3f, n * sizeof(int)); &#125; ~Graph() &#123; delete[] dist; delete[] visited; delete[] edges; &#125; void insert(int x, int y, int weight) &#123; edges[x].push_back(Edge&#123;y, weight&#125;); edges[y].push_back(Edge&#123;x, weight&#125;); &#125; int prim(int v) &#123; int total_weight=0; dist[v]=0; for(int i=0;i&lt;n;++i)&#123; int min_dist=INF,min_vertex; for(int j=0;j&lt;n;++j)&#123; if(!visited[j]&amp;&amp;dist[j]&lt;min_dist)&#123; min_dist=dist[j]; min_vertex=j; &#125; &#125; total_weight+=min_dist; visited[min_vertex]=1; for(Edge &amp;j:edges[min_vertex])&#123; if(!visited[j.vertex]&amp;&amp;j.weight&lt;dist[j.vertex])&#123; dist[j.vertex]=j.weight; &#125; &#125; &#125; return total_weight; &#125;&#125;;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Graph g(n); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g.insert(a, b, c); &#125; cout &lt;&lt; g.prim(0) &lt;&lt; endl; return 0;&#125; 再是计算最短路径的Dijkstra算法，Dijkstra 算法和前面的 Prim 算法很相像，都是从一个点开始，每次确定一个点并完成更新，重复操作直至 n 个点都确定为止。 需要注意的是，Dijkstra 不适用于有边权为负数的情况哦，否则会影响算法的正确性。 如果对 Prim 算法的代码还有印象的话，应该可以感觉到，Prim 算法和 Dijkstra 算法极为相似。都会用到一个 visited 数组标记是否已经完成计算，以及一个 dist 数组表示最短路径。不过在 Dijkstra 算法中，dist 存储的就不是到生成树的距离了，而是从源点出发到每个顶点的最短路径。 首先输入两个整数 n 和 m，表示图中的顶点数和边数。接下来一共 m 行，每行三个整数 a，b，c，表示一条连接 a 和 b 的权重为 c 的带权无向边。程序最终会输出从源点出发到所有顶点的最短路径长度。 比如输入下面这张图： 对应的输入数据为 5 8 0 1 10 0 2 5 1 2 3 1 3 1 2 3 9 2 4 2 3 4 6 0 4 8 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int INF = 0x3f3f3f3f;struct Edge &#123; int vertex, weight;&#125;;class Graph &#123;private: int n; vector&lt;Edge&gt; * edges; bool * visited;public: int * dist; Graph (int input_n) &#123; n = input_n; edges = new vector&lt;Edge&gt;[n]; dist = new int[n]; visited = new bool[n]; memset(visited, 0, n); memset(dist, 0x3f, n * sizeof(int)); &#125; ~Graph() &#123; delete[] dist; delete[] edges; delete[] visited; &#125; void insert(int x, int y, int weight) &#123; edges[x].push_back(Edge&#123;y, weight&#125;); edges[y].push_back(Edge&#123;x, weight&#125;); &#125; void dijkstra(int v) &#123; dist[v]=0; for(int i=0;i&lt;n;++i)&#123; int min_dist=INF,min_vertex; for(int j=0;j&lt;n;++j)&#123; if(!visited[j]&amp;&amp;dist[j]&lt;min_dist)&#123; min_dist=dist[j]; min_vertex=j; &#125; &#125; visited[min_vertex]=1; for(Edge &amp;j:edges[min_vertex])&#123; if(min_dist+j.weight&lt;dist[j.vertex])&#123; dist[j.vertex]=min_dist+j.weight; &#125; &#125; &#125; &#125;&#125;;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Graph g(n); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g.insert(a, b, c); &#125; g.dijkstra(0); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; g.dist[i] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的深搜和宽搜C++]]></title>
    <url>%2F2016%2F02%2F07%2Fdfs-bfs%2F</url>
    <content type="text"><![CDATA[第一行输入两个整数 n 和 m，表示顶点数和边数。接下来 m 行，每行输入两个整数 x 和 y，表示一条从 x 连向 y 的无向边。之后输入一个整数 k，表示深度优先搜索的起点。注意顶点是从 0 开始编号的哦。输入完成后会将遍历结果输出。 假如输入 5 6 0 1 1 2 1 3 2 3 0 4 1 4 0 遍历的结果为 0 1 2 3 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;class Graph &#123;private: int n; //!&lt; 顶点数量 vector&lt;int&gt; *edges; //!&lt; 邻接表 bool *visited;public: Graph(int input_n) &#123; n = input_n; edges = new vector&lt;int&gt;[n]; visited=new bool[n]; memset(visited,0,n); &#125; ~Graph() &#123; delete[] edges; delete[] visited; &#125; void insert(int x, int y) &#123; edges[x].push_back(y); edges[y].push_back(x); &#125; void dfs(int vertex) &#123; cout&lt;&lt;vertex&lt;&lt;endl; visited[vertex]=true; for(int adj_vertex:edges[vertex])&#123; if(!visited[adj_vertex])&#123; dfs(adj_vertex); &#125; &#125; &#125;&#125;;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m; Graph g(n); for (int i = 0; i &lt; m; ++i) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; g.insert(x, y); &#125; cin &gt;&gt; k; g.dfs(k); return 0;&#125; 第一行输入两个整数 n 和 m，表示顶点数和边数。接下来 m 行，每行输入两个整数 x 和 y，表示一条从 x 连向 y 的无向边。之后输入一个整数 k，表示广度优先搜索的起点。注意顶点是从 0 开始编号的哦。输入完成后会将遍历结果输出。 假如输入 5 6 0 1 1 2 1 3 2 3 0 4 1 4 0 遍历的结果为 0 1 4 2 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;class Graph &#123;private: int n; bool *visited; vector&lt;int&gt; *edges; public: Graph(int input_n) &#123; n = input_n; edges = new vector&lt;int&gt;[n]; visited = new bool[n]; memset(visited, 0, n); &#125; ~Graph() &#123; delete[] edges; delete[] visited; &#125; void insert(int x, int y) &#123; edges[x].push_back(y); edges[y].push_back(x); &#125; void bfs(int start_vertex) &#123; queue&lt;int&gt; bfs_queue; bfs_queue.push(start_vertex); visited[start_vertex]=true; while(!bfs_queue.empty())&#123; int vertex=bfs_queue.front(); cout&lt;&lt;vertex&lt;&lt;endl; bfs_queue.pop(); for(int adj_vertex:edges[vertex])&#123; if(!visited[adj_vertex])&#123; visited[adj_vertex]=true; bfs_queue.push(adj_vertex); &#125; &#125; &#125; &#125;&#125;;int main() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m; Graph g(n); for (int i = 0; i &lt; m; ++i) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; g.insert(x, y); &#125; cin &gt;&gt; k; g.bfs(k); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>深搜</tag>
        <tag>广搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跳跃游戏]]></title>
    <url>%2F2016%2F02%2F06%2Fjump-game%2F</url>
    <content type="text"><![CDATA[给定一个非负整数数组，假定你的初始位置为数组第一个下标。 数组中的每个元素代表你在那个位置能够跳跃的最大长度。 你的目标是到达最后一个下标，并且使用最少的跳跃次数。 例如： A = [2,3,1,1,4], 到达最后一个下标的最少跳跃次数为2.（先跳跃1步，从下标0到1,然后跳跃3步，到达最后一个下标。一共两次） 格式： 第一行输入一个正整数n，接下来的一行，输入数组A[n]。 最后输出最少的跳跃次数。 样例1输入：5 3 1 1 1 1 输出：2 思路：dp[i]代表跳跃到第i个数最少的步数 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a[1000],dp[1000]; cin&gt;&gt;n; for(int i=0;i&lt;n;++i) &#123; cin&gt;&gt;a[i]; &#125; const int inf=0x7fffffff; fill(dp,dp+n,inf); dp[0]=0; for(int i=0;i&lt;n-1;++i) &#123; for(int j=1;j&lt;=a[i];++j) &#123; dp[i+j]=min(dp[i]+1,dp[i+j]); &#125; &#125; cout&lt;&lt;dp[n-1]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求数组的最长递减子序列]]></title>
    <url>%2F2016%2F02%2F05%2Fdp-de%2F</url>
    <content type="text"><![CDATA[给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。 输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。 输出为一行，最长递减子序列的结果，数字间用空格分隔（测试case中只会有一个最长递减子序列）。 样例1输入：8 9 4 3 2 5 4 3 2 输出：9 5 4 3 2 思路：求最长递减序列，我的做法是把输入数据反向，然后求用我会做的求最长递增序列，当然我用的求法不是O（n^2）的，那样我觉得会超时，所以我用的O（nlogn）的。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int g[30010],num[30010],d[30010];int main()&#123; int n; scanf("%d",&amp;n); int inf=0x7fffffff; fill(g,g+n,inf); for(int i=0;i&lt;n;++i)&#123; scanf("%d",&amp;num[n-1-i]); &#125; //核心代码begin for(int i=0;i&lt;n;++i)&#123; int j=lower_bound(g,g+n,num[i])-g; g[j]=num[i]; d[i]=j+1; &#125; //end int s=*max_element(d,d+n); for(int i=n-1;i&gt;=0;--i) &#123; if(s==d[i]) &#123; if(s!=1) printf("%d ",num[i]); else printf("%d\n",num[i]); --s; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2016%2F02%2F05%2Fheap-sort%2F</url>
    <content type="text"><![CDATA[堆实际上是一颗二叉树，对于大根堆来说，它的特点就是父节点的值大于所有子节点的值。 C++的STL中priority_queue已经帮我们实现好了堆的数据结构，接下来我们一起学习并实践如何实现一个堆并用堆进行排序。 priority_queue是STL的queue这个头文件中定义的数据结构，因此需要额外引用它，即#include &lt;queue&gt;。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;priority_queue&lt;int&gt; myHeap;int main() &#123; int n = 5, num[5] = &#123;1, 3, 2, 5, 4&#125;; // 在下面的循环内读入元素并插入堆 for (int i = 0; i &lt; n; ++i) &#123; myHeap.push(num[i]); &#125; // 在下面的循环内从大到小输出元素并将元素依次从堆顶弹出 for (int i = 0; i &lt; n; ++i) &#123; printf("%d\n",myHeap.top()); myHeap.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冗余关系]]></title>
    <url>%2F2016%2F02%2F05%2Fredundant%2F</url>
    <content type="text"><![CDATA[蒜头最近在沉迷小说，尤其是人物关系复杂的言情小说。它看到的人物关系描述得很的麻烦的时候觉得非常蒜疼，尤其是人物关系里有冗余的时候。什么是冗余关系呢？ 这篇小说里有n句描述人物关系的句子，描述了n个人的关系。 每条句子的定义是这样的： XY 它的意思是：X认识Y，Y也认识X 我们认为小说中的人物关系是具有传递性的，假如A认识B，B认识C，则A也认识C。 冗余关系的定义：就是即使没有这条人物关系，原来的人物之间的所有关系也照样成立。 比如： 小说中已经提到了A认识B，B也认识C。在此之后再讲A认识C就是一个冗余的关系。 小蒜头想求出一共有多少条冗余关系，你能帮帮它吗？也许并查集能帮上忙哦。 输入格式：第一行两个整数，表示句子数量n(1&lt;=n&lt;=1000)，表示人数m(1&lt;=m&lt;=1000)。 接下来n行，每行两个数，表示一组人物关系。 输出格式：一个整数，表示冗余关系的数目。 样例1输入：3 3 1 2 1 3 2 3 输出：1 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;int fa[2000];// 还记得之前阅读课里讲的并查集算法// father函数返回的是节点x的祖先节点int father(int x) &#123; if (fa[x] != x) fa[x] = father(fa[x]); return fa[x];&#125;// 合并两个节点所在集合，同时判断两个点之前是否在一个集合里// 函数返回true则之前两个点不在一个集合中bool join(int x, int y) &#123; int fx = father(x), fy = father(y); if (fx != fy) &#123; fa[fx] = fy; return true; &#125; else &#123; return false; &#125;&#125;// 初始化一个n个点的并查集void init(int n) &#123; for (int i = 1; i &lt;= n; ++i) fa[i] = i;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); init(m); int f,c,ans=0; for(int i=0;i&lt;n;++i)&#123; scanf("%d%d",&amp;f,&amp;c); if(!join(c,f))&#123; ++ans; &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2016%2F02%2F05%2Funion-find-sets%2F</url>
    <content type="text"><![CDATA[并查集是一个多棵树的数据结构(森林)，每个节点记录一个father[i]表示它的父节点。并查集可以解决集合的合并和查询操作。 并查集的初始化代码如下： 1234void make_set() &#123; for (int i = 0; i &lt; n; ++i) father[i] = i;&#125; 此时每个节点都属于不同的集合。查询操作的代码如下： 123int get_father(int v) &#123; return father[v] != v ? get_father(father[v]) : v;&#125; 上面代码的意思就是，如果当前节点不是这棵树的根节点，那么就不断回溯到根节点。 接下来是合并操作： 1234void merge(int x, int y) &#123; int root_x = find(x), root_y = find(y); if (root_x != root_y) father[root_x] = root_y;&#125; 下图是合并操作的图解： 并查集的一个优化叫做【路径压缩】，是在并查集执行查询时对经过的点进行【扁平化】的方法。优化后的代码如下： 1234int get_father(int v) &#123; if (father[v] != v) father[v] = get_father(father[v]); return father[v];&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LIS（最长上升子序列）]]></title>
    <url>%2F2016%2F02%2F04%2Flis%2F</url>
    <content type="text"><![CDATA[最长上升子序列 (Longest Increasing Subsequence, 常简称为 LIS) 是动态规划解决的一个经典问题。 我们先讲一下子序列是什么。一个数组的子序列就是从里面选出一些元素，并将他们保持原有的先后顺序排列。比如[1, 2, 3, 4, 5]的子序列有[1, 3, 5]、[3, 4]，而[1, 5, 3]则不是这个数组的子序列。 这里多介绍一下，还有一个容易与子序列混淆的概念：子串。子串是指从一个数组中选出连续的一个或多个元素，并且保持他们原有的顺序。子串一定是子序列，比如前面的子序列[3, 4]就是子串，但[1, 3, 5]不是子串，因为这三个元素在原数组中并不是连续的。 一句话总结他们的区别，就是子序列可以不连续，而子串必须连续。 上升子序列是指子序列Ai中满足 A1 &lt; A2 &lt; … &lt; An，也就是后面的元素一定比前面的元素大，比如(1, 3, 5)是上升子序列，(1, 3, 3)和(1, 4, 3)都不是。现在来跟我一起解决最长上升子序列的问题吧！(o・・o)/ 输入格式：第一行一个整数n(1 ≤ n ≤ 100)，表示序列的长度。 第二行 n 个整数，表示序列中的每个元素。 输出格式：输出只有一行，为最长上升子序列的长度。 样例输入：5 1 5 2 3 4 样例输出：4 还记得上一道数塔问题我们怎么解决的么？我们首先要把问题拆分成很多子问题。对于这道题来说，我们分解为这样的N个子问题：求解最后一个元素为原数组中第 i (1 ≤ i ≤ n)个元素的最长上升子序列的长度。 如果我们把N个问题都计算出来了，那么最终结果就从所有子问题中选出一个最大值是不是就可以啦？好了，我们开始写代码吧。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n, dp[101], num[101], result = 0;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;num[i]); &#125; // begin: 在下面实现动态规划的核心代码 for (int i = 1; i &lt;= n; ++i) &#123; dp[i]=1; for(int j=1;j&lt;i;++j)&#123; if(num[j]&lt;num[i])&#123; dp[i]=max(dp[j]+1,dp[i]); &#125; &#125; result=max(result,dp[i]); &#125; // end. printf("%d\n", result); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动归之数塔]]></title>
    <url>%2F2016%2F02%2F04%2Fshu-ta%2F</url>
    <content type="text"><![CDATA[上面这张图是一个数塔问题的例子。每次从顶部元素，就是上图中的9出发，每次可以走到下面相邻的两个节点，比如从9往下相邻的是12和15，6往下相邻的是18和9。找到一条从顶部到底部的路径，使得路径上的数值和最大。 一个直观的贪心策略是每次向下走都选择较大的那一个，得到的一个解是9+15+8+9+10=51，然而我们发现最优的解是9+12+10+18+10=59，也就是说这道题并不适合贪心策略。 接下来我们把问题分解，假如知道从顶点到每个点的最优解的话，最终答案也就能够得出了。假设第i行第j个元素为止的最优解为f[i][j]，可以想到f[i][j]只和f[i-1][j]和f[i-1]j-1有关。也就是说第i行的解只会跟第i-1行的一个或两个元素有关。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100;// 下面这个函数实现的是更新最大值，o赋值为o和x的最大值template &lt;class T&gt;void updateMax(T&amp; o, const T&amp; x) &#123; o = (o &gt; x) ? o : x;&#125;// f数组为动态规划的状态数组// num数组为读入的数塔// n为读入的数塔高度int f[N][N], num[N][N], n;int main() &#123; // 读入n和数塔数组num scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; scanf("%d", &amp;num[i][j]); &#125; &#125; // step 1 begin: 在这里实现动态规划算法逻辑 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; updateMax(f[i][j],max(f[i-1][j],f[i-1][j-1])+num[i][j]); &#125; &#125; // step 1 end. // 定义最终结果变量result，因为是计算最大值，所以初始化为0 int result = 0; for (int i = 1; i &lt;= n; ++i) &#123; // step 2 begin: 在这里实现更新最终结果的逻辑 updateMax(result,f[n][i]); // step 2 end. &#125; // 输出最终最大权值和result printf("%d\n", result); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QuickSort（快速排序）]]></title>
    <url>%2F2016%2F02%2F04%2Fquick-sort%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;void quick_sort(int dat[], int l, int r) &#123; // 首先请填写下面三个变量的初值 int i = l, j =r , mid = dat[r]; do &#123; while (dat[i] &lt; mid) ++i; while (dat[j] &gt; mid) --j; if (i &lt;= j) &#123; swap(dat[i], dat[j]); ++i; --j; &#125; &#125; while (i &lt; j); // 接下来请填写第一个递归调用的参数，仔细回顾一下刚刚讲的快速排序算法的思想哈。 if (l &lt; j) quick_sort(dat,l,j); // 接下来请填写第二个递归调用的参数。 if (i &lt; r) quick_sort(dat,i,r);&#125;int main() &#123; int dat[10] = &#123;1, 4, 3, 2, 5, 3, 2, 5, 10, 9&#125;; quick_sort(dat, 0, 9); for (int i = 0; i &lt; 10; ++i) printf("%d ", dat[i]); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表操作]]></title>
    <url>%2F2016%2F02%2F04%2Flinklist%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt;using namespace std;class Node &#123;public: int data; Node* next; Node(int _data) &#123; data = _data; next = NULL; &#125;&#125;;class LinkList &#123;private: Node* head;public: LinkList() &#123; head = NULL; &#125; void insert(Node *node, int index) &#123; if (head == NULL) &#123; head = node; return; &#125; if (index == 0) &#123; node-&gt;next = head; head = node; return; &#125; Node *current_node = head; int count = 0; while (current_node-&gt;next != NULL &amp;&amp; count &lt; index - 1) &#123; current_node = current_node-&gt;next; count++; &#125; if (count == index - 1) &#123; node-&gt;next = current_node-&gt;next; current_node-&gt;next = node; &#125; &#125; void output() &#123; if (head == NULL) &#123; return; &#125; Node *current_node = head; while (current_node != NULL) &#123; cout &lt;&lt; current_node-&gt;data &lt;&lt; " "; current_node = current_node-&gt;next; &#125; cout &lt;&lt; endl; &#125; void delete_node(int index) &#123; if (head == NULL) &#123; return; &#125; Node *current_node = head; int count = 0; if (index == 0) &#123; head = head-&gt;next; delete current_node; return; &#125; while (current_node-&gt;next != NULL &amp;&amp; count &lt; index -1) &#123; current_node = current_node-&gt;next; count++; &#125; if (count == index - 1 &amp;&amp; current_node-&gt;next != NULL) &#123; Node *delete_node = current_node-&gt;next; current_node-&gt;next = delete_node-&gt;next; delete delete_node; &#125; &#125; void reverse()&#123; if(head==NULL)&#123; return; &#125; Node *next_node,*current_node; current_node=head-&gt;next; head-&gt;next=NULL; while(current_node!=NULL)&#123; next_node=current_node-&gt;next; current_node-&gt;next=head; head=current_node; current_node=next_node; &#125; &#125;&#125;;int main() &#123; LinkList linklist; for (int i = 1; i &lt;= 10; i++) &#123; Node *node = new Node(i); linklist.insert(node, i - 1); &#125; linklist.output(); linklist.delete_node(3); linklist.output(); linklist.reverse(); linklist.output(); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1007. Maximum Subsequence Sum (25)]]></title>
    <url>%2F2015%2F08%2F28%2Fpat1007%2F</url>
    <content type="text"><![CDATA[Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification:Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space. Output Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input:10 -10 1 2 3 4 -5 -23 3 7 -21 Sample Output:10 1 4 思路：题意是求序列中最大子序列和，并要标记第一个最大子序列的开始元素和结束元素，遍历序列，若当前子序列和大于最大值，就更新开始元素和结束元素和最大值，若当前子序列小于零就将子序列和置零并将记录临时开始元素为下一个，算法复杂度为O（n）。 Code： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,i,arr[10010]; cin&gt;&gt;n; int flag=0,st=1,ed=n,max=-1,sum=0,tpst=1; for(i=1;i&lt;=n;++i) &#123; cin&gt;&gt;arr[i]; if(arr[i]&gt;=0) flag=1; &#125; if(flag==0) cout&lt;&lt;0&lt;&lt;" "&lt;&lt;arr[st]&lt;&lt;" "&lt;&lt;arr[ed]&lt;&lt;endl; else &#123; for(i=1;i&lt;=n;++i) &#123; sum+=arr[i]; if(sum&gt;max) &#123; max=sum; st=tpst; ed=i; &#125; if(sum&lt;0) &#123; sum=0; tpst=i+1; &#125; &#125; cout&lt;&lt;max&lt;&lt;" "&lt;&lt;arr[st]&lt;&lt;" "&lt;&lt;arr[ed]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1006. Sign In and Sign Out (25)]]></title>
    <url>%2F2015%2F08%2F19%2Fpat1006%2F</url>
    <content type="text"><![CDATA[At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification:Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters. Output Specification:For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input:3 CS301111 15:30:28 17:00:10 SC3021234 08:00:00 11:25:25 CS301133 21:45:00 21:58:40 Sample Output:SC3021234 CS301133 思路：题意是算出最早签到的人和最晚签离的人，所以只要把时间化成与00:00:00的差值即可，换算成秒，求出最小和最大即可。 Code： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,i; scanf("%d",&amp;n); char fir[16],last[16],temp[16]; int s,f,m; int min=99999,max=-1; for(i=0;i&lt;n;i++) &#123; scanf("%s %d:%d:%d",temp,&amp;s,&amp;f,&amp;m); int ti=3600*s+60*f+m; if(ti&lt;min) &#123; min=ti; strcpy(fir,temp); &#125; scanf("%d:%d:%d",&amp;s,&amp;f,&amp;m); ti=3600*s+60*f+m; if(ti&gt;max) &#123; max=ti; strcpy(last,temp); &#125; &#125; printf("%s %s\n",fir,last); return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1005. Spell It Right (20)]]></title>
    <url>%2F2015%2F08%2F19%2Fpat1005%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. Input Specification:Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100). Output Specification:For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input:12345 Sample Output:one five 思路：给你一个数，求每位相加之后的和，这个和每位用英文数字表示，简单的模拟，用了栈，注意0这个结果就满分了。 Code： 12345678910111213141516171819202122232425262728using namespace std;const int N=102;char dig[][10]=&#123;"zero","one","two","three","four","five","six","seven","eight","nine"&#125;;int main()&#123; char num[N]; gets(num); int len=strlen(num); int sum=0; for(int i=0;i&lt;len;i++) sum+=num[i]-'0'; char stack[10][10]; int top=-1; if(sum==0) cout&lt;&lt;dig[0]; else &#123; while(sum) &#123; strcpy(stack[++top],dig[sum%10]); sum/=10; &#125; cout&lt;&lt;stack[top--]; while(top!=-1) cout&lt;&lt;" "&lt;&lt;stack[top--]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1004. Counting Leaves (30)]]></title>
    <url>%2F2015%2F08%2F19%2Fpat1004%2F</url>
    <content type="text"><![CDATA[A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. InputEach input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format: ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01. OutputFor each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line. Sample Input2 1 01 1 02 Sample Output0 1 思路：题目是给你一棵树，让你求每层的叶子数，当然是用深搜解决。 Code： 123456789101112131415161718192021222324252627282930313233using namespace std;const int N=102;vector&lt;int&gt;son[N];int leaf[N],maxdeep;void dfs(int k,int deep)&#123; maxdeep=max(maxdeep,deep); if(son[k].size()==0) leaf[deep]++; else for(vector&lt;int&gt;::iterator it=son[k].begin();it!=son[k].end();it++) dfs(*it,deep+1);&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; while(m--) &#123; int id,k,chd; cin&gt;&gt;id&gt;&gt;k; while(k--) &#123; cin&gt;&gt;chd; son[id].push_back(chd); &#125; &#125; dfs(1,0); cout&lt;&lt;leaf[0]; for(int i=1;i&lt;=maxdeep;++i) cout&lt;&lt;' '&lt;&lt;leaf[i]; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003. Emergency (25)]]></title>
    <url>%2F2015%2F08%2F09%2Fpat1003%2F</url>
    <content type="text"><![CDATA[As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. InputEach input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. OutputFor each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input5 6 0 2 1 2 1 5 3 0 1 1 0 2 2 0 3 1 1 2 1 2 4 1 3 4 1 Sample Output2 4 思路：题目意思是给你一个带权的无向图，求起点到终点最短路有几条，并求最大权值，采用深搜就可以解决，记得剪枝方可过全部测试数据。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using namespace std;#define max 510#define INF 0x7ffffffftypedef struct&#123; int vex[max]; int edge[max][max]; int n,e;&#125;MGraph;MGraph g;int cnt,maxteam,mindis,visit[max];void dfs(int p,int end,int dist,int te)&#123; if(p==end) &#123; if(dist&lt;mindis) &#123; mindis=dist; cnt=1; maxteam=te; &#125; else if(dist==mindis) &#123; ++cnt; if(maxteam&lt;te) maxteam=te; &#125; return; &#125; if(dist&gt;mindis) return; for(int i=0;i&lt;g.n;++i) &#123; if(visit[i]==0&amp;&amp;g.edge[p][i]!=INF) &#123; visit[i]=1; dfs(i,end,dist+g.edge[p][i],te+g.vex[i]); visit[i]=0; &#125; &#125;&#125;int main()&#123; int st,ed,i,j,c1,c2,l; mindis=INF; cin&gt;&gt;g.n&gt;&gt;g.e&gt;&gt;st&gt;&gt;ed; for(i=0;i&lt;g.n;++i) &#123; cin&gt;&gt;g.vex[i]; visit[i]=0; for(j=0;j&lt;g.n;++j) g.edge[i][j]=INF; &#125; for(i=0;i&lt;g.e;++i) &#123; cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;l; g.edge[c2][c1]=g.edge[c1][c2]=l; &#125; dfs(st,ed,0,g.vex[st]); cout&lt;&lt;cnt&lt;&lt;" "&lt;&lt;maxteam&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1002. A+B for Polynomials (25)]]></title>
    <url>%2F2015%2F08%2F09%2Fpat1002%2F</url>
    <content type="text"><![CDATA[This time, you are supposed to find A+B where A and B are two polynomials. InputEach input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. OutputFor each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output3 2 1.5 1 2.9 0 3.2 思路：题意是根据输入的两个多项式相加后，输出相加后多项式的项数和结果，注意两个多项式相加后系数为0的情况。 Code： 1234567891011121314151617181920212223242526272829303132333435363738using namespace std;int main()&#123; int i; float pol[1100]; for(i=0;i&lt;1100;++i) pol[i]=0.0; int k,temp1; float temp2; cin&gt;&gt;k; for(i=0;i&lt;k;++i) &#123; cin&gt;&gt;temp1; cin&gt;&gt;pol[temp1]; &#125; int cnt=k; cin&gt;&gt;k; for(i=0;i&lt;k;++i) &#123; cin&gt;&gt;temp1&gt;&gt;temp2; if(pol[temp1]==0.0) &#123; ++cnt; pol[temp1]=temp2; &#125; else pol[temp1]+=temp2; if(pol[temp1]==0.0)//如果相加后系数为0，总个数减一 --cnt; &#125; cout&lt;&lt;cnt; for(i=1099;i&gt;=0;--i) &#123; if(pol[i]!=0.0) printf(" %d %.1f",i,pol[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001. A+B Format (20)]]></title>
    <url>%2F2015%2F08%2F09%2Fpat1001%2F</url>
    <content type="text"><![CDATA[Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). InputEach input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. OutputFor each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input-1000000 9 Sample Output-999,991 思路：题目意思是两数相加后的结果每三位加一个逗号，我的做法是把取余的每位都保存在字符栈中，每取三位加一个逗号，最后出栈即可，区分下正数负数和零的情况即可。 Code： 1234567891011121314151617181920212223242526272829303132333435using namespace std;int main()&#123; char sta[20]; int top=-1; int a,b,sum; cin&gt;&gt;a&gt;&gt;b; sum=a+b; int flag=0; if(sum!=0) &#123; if(sum&lt;0) &#123; sum=-sum; cout&lt;&lt;'-'; &#125; while(sum) &#123; if(flag%3==0) &#123; sta[++top]=','; flag=0; &#125; ++flag; sta[++top]='0'+sum%10; sum/=10; &#125; while(top!=0) cout&lt;&lt;sta[top--]; --top; cout&lt;&lt;endl; &#125; else cout&lt;&lt;0&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>OJ</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图的邻接矩阵表示]]></title>
    <url>%2F2015%2F07%2F27%2Fdijkstra-algorithm%2F</url>
    <content type="text"><![CDATA[给出邻接矩阵描述的图，顶点数&lt;26，求 1、边数 2、无向图各顶点度数 3、求两个顶点最短路径 输入要求第一行一个数N，表示邻接矩阵的行数。 N*N的邻接矩阵，第一行第一列为顶点A。 求最短路径的两个顶点，用大写字母表示。 输出要求第一行输出边的个数。 接下来N行输出各顶点度数。 最后输出给定两点间最短距离。 假如输入4 0 25 40 100 25 0 45 -1 40 45 0 80 100 -1 80 0 B D 应当输出5 3 2 3 2 125 提示-1表示没有路径 用的是这几天学的迪杰斯特拉算法 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;#define max 60#define INF 0x7ffftypedef struct&#123; int no; int arcnum;&#125;VertexType;typedef struct&#123; VertexType vex[max]; int edge[max][max]; int n,e;&#125;MGraph;int dist[max],path[max];void Dijkstra(MGraph g,int v)&#123; int visit[max]; int min,i,j,u; for(i=0;i&lt;g.n;++i) &#123; dist[i]=g.edge[v][i]; visit[i]=0; if(g.edge[v][i]&lt;INF) path[i]=v; else path[i]=-1; &#125; visit[v]=1; path[v]=-1; for(i=0;i&lt;g.n;++i) &#123; min=INF; for(j=0;j&lt;g.n;++j) &#123; if(visit[j]==0&amp;&amp;dist[j]&lt;min) &#123; u=j; min=dist[j]; &#125; &#125; visit[u]=1; for(j=0;j&lt;g.n;++j) &#123; if(visit[j]==0&amp;&amp;dist[u]+g.edge[u][j]&lt;dist[j]) &#123; dist[j]=dist[u]+g.edge[u][j]; path[j]=u; &#125; &#125; &#125;&#125;int main()&#123; int i,j; MGraph g; char begin,end; g.e=0; cin&gt;&gt;g.n; for(i=0;i&lt;g.n;++i) &#123; g.vex[i].no=i; g.vex[i].arcnum=0; for(j=0;j&lt;g.n;++j) &#123; cin&gt;&gt;g.edge[i][j]; if(g.edge[i][j]!=0&amp;&amp;g.edge[i][j]!=-1) &#123; ++g.e; ++g.vex[i].arcnum; &#125; else g.edge[i][j]=INF;//将自身和没路径的弧设置为无穷 &#125; &#125; cin&gt;&gt;begin&gt;&gt;end; cout&lt;&lt;g.e/2&lt;&lt;endl; for(i=0;i&lt;g.n;++i) cout&lt;&lt;g.vex[i].arcnum&lt;&lt;endl; Dijkstra(g,begin-'A'); cout&lt;&lt;dist[end-'A'];&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种递归遍历二叉树]]></title>
    <url>%2F2015%2F07%2F20%2F3order%2F</url>
    <content type="text"><![CDATA[题目描述给定一颗二叉树，要求输出二叉树的前序遍历、后序遍历、中序遍历二叉树得到的序列。本题假设二叉树的结点数不超过1000。 输入要求输入数据分为多组，第一行是测试数据的组数n，下面的n行分别代表一棵二叉树。每棵二叉树的结点均为正整数，数据为0代表当前结点为空，数据为-1代表二叉树数据输入结束，-1不作处理。二叉树的构造按照层次顺序（即第1层1个整数，第2层2个，第3层4个，第4层有8个……，如果某个结点不存在以0代替） 输出要求输出每棵二叉树的前序遍历、后序遍历、中序遍历二叉树得到的序列。 假如输入2 1 -1 1 2 0 3 4 -1 应当输出1 1 1 1 2 3 4 3 4 2 1 3 2 4 1 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384using namespace std;typedef struct BTree&#123; int data; struct BTree *left; struct BTree *right;&#125;BTree;int arr[1010],n;BTree* CreatBTree(int i)&#123; if(i&gt;=n||arr[i]==0) return NULL; BTree *temp=(BTree *)malloc(sizeof(BTree)); temp-&gt;data=arr[i]; temp-&gt;left=CreatBTree(2*i); temp-&gt;right=CreatBTree(2*i+1); return temp;&#125;void preOrder(BTree *p)&#123; if(p!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;" "; preOrder(p-&gt;left); preOrder(p-&gt;right); &#125;&#125;void inOrder(BTree *p)&#123; if(p!=NULL) &#123; inOrder(p-&gt;left); cout&lt;&lt;p-&gt;data&lt;&lt;" "; inOrder(p-&gt;right); &#125;&#125;void postOrder(BTree *p)&#123; if(p!=NULL) &#123; postOrder(p-&gt;left); postOrder(p-&gt;right); cout&lt;&lt;p-&gt;data&lt;&lt;" "; &#125;&#125;int getDeep(BTree *p)&#123; int LD,RD; if(p==NULL) return 0; LD=getDeep(p-&gt;left); RD=getDeep(p-&gt;right); return 1+max(LD,RD);&#125;void delBTree(BTree *p)&#123; if(p) &#123; delBTree(p-&gt;left); delBTree(p-&gt;right); free(p); &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; n=0; while(cin&gt;&gt;arr[++n]&amp;&amp;arr[n]!=-1); BTree *root=CreatBTree(1); //cout&lt;&lt;getDeep(root); //cout&lt;&lt;ceil(log(i-1.0)/log(2.0));//根据数组长度也可求得树的深度 preOrder(root); cout&lt;&lt;endl; postOrder(root); cout&lt;&lt;endl; inOrder(root); cout&lt;&lt;endl; delBTree(root); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP模式匹配]]></title>
    <url>%2F2015%2F07%2F18%2Fkmp%2F</url>
    <content type="text"><![CDATA[题目描述输入一个主串和一个子串，若匹配成功，则找出匹配的趟数和在子串在主串中的位置，若匹配不成功，则输出0 输入要求输入两个字符串 输出要求输出匹配的趟数和位置 假如输入ababcabcacbab abcac 应当输出3 6 Code： 今天好好地理解了kmp算法，物超所值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;void getnext(char str[],int next[])&#123; int i=0,j=-1; next[0]=-1; int len=strlen(str); while(i&lt;len-1) &#123; if(j==-1||str[i]==str[j]) &#123; ++i; ++j; next[i]=j; &#125; else j=next[j]; &#125;&#125;void kmp(char str[],char substr[],int next[],int &amp;times,int &amp;pos)&#123; int len1=strlen(str); int len2=strlen(substr); int i=0,j=0; times=1; getnext(substr,next); while(i&lt;len1&amp;&amp;j&lt;len2) &#123; if(j==-1||str[i]==substr[j]) &#123; ++i; ++j; &#125; else &#123; j=next[j]; ++times; &#125; &#125; if(len2==j) pos=i-j; else times=0;&#125;int main()&#123; char str[100],substr[100]; gets(str); gets(substr); int next[100]; int pos,times; kmp(str,substr,next,times,pos); if(times) cout&lt;&lt;times&lt;&lt;" "&lt;&lt;pos+1; else cout&lt;&lt;0; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作格子]]></title>
    <url>%2F2015%2F05%2F26%2Fczgz%2F</url>
    <content type="text"><![CDATA[问题描述有n个格子，从左到右放成一排，编号为1-n。 共有m次操作，有3种操作类型： 1.修改一个格子的权值， 2.求连续一段格子权值和， 3.求连续一段格子的最大值。 对于每个2、3操作输出你所求出的结果。 输入格式第一行2个整数n，m。 接下来一行n个整数表示n个格子的初始权值。 接下来m行，每行3个整数p,x,y，p表示操作类型，p=1时表示修改格子x的权值为y，p=2时表示求区间[x,y]内格子权值和，p=3时表示求区间[x,y]内格子最大的权值。 输出格式有若干行，行数等于p=2或3的操作总数。 每行1个整数，对应了每个p=2或3操作的结果。 样例输入4 3 1 2 3 4 2 1 3 1 4 3 3 1 4 样例输出6 3 数据规模与约定对于20%的数据n &lt;= 100，m &lt;= 200。 对于50%的数据n &lt;= 5000，m &lt;= 5000。 对于100%的数据1 &lt;= n &lt;= 100000，m &lt;= 100000，0 &lt;= 格子权值 &lt;= 10000。 花了一天学了线段树，还不是很熟，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;struct Node&#123; int sum,l,r,max;&#125;node[300001];int find_ans(int x,int y,int i,bool ismax)//返回区间[x,y]的最大值或和&#123; if(x==node[i].l&amp;&amp;y==node[i].r) return ismax?node[i].max:node[i].sum; int mid=(node[i].l+node[i].r)/2; if(x&gt;mid) return find_ans(x,y,2*i+1,ismax); else if(y&lt;=mid) return find_ans(x,y,2*i,ismax); else return ismax?max(find_ans(x,mid,2*i,ismax),find_ans(mid+1,y,2*i+1,ismax)):find_ans(x,mid,2*i,ismax)+find_ans(mid+1,y,2*i+1,ismax);&#125;void modify(int i,int x,int data)//将data替换线段树的x位置的值，并更新区间最大值和区间和&#123; if(x==node[i].l&amp;&amp;x==node[i].r) &#123; node[i].sum=data; node[i].max=data; return; &#125; else &#123; int mid=(node[i].l+node[i].r)/2; if(x&gt;mid) modify(2*i+1,x,data); else modify(2*i,x,data); node[i].max=max(node[i*2].max,node[i*2+1].max); node[i].sum=node[i*2].sum+node[i*2+1].sum; &#125;&#125;void insert(int i,int x,int data) //将data插入到线段树的x位置&#123; node[i].sum+=data; node[i].max=max(data,node[i].max); if(node[i].l==node[i].r) return; int mid=(node[i].l+node[i].r)/2; if(x&gt;mid) insert(2*i+1,x,data); else insert(2*i,x,data);&#125;void init(int l,int r,int i)//初始化线段树&#123; node[i].l=l; node[i].r=r; node[i].max=0; node[i].sum=0; if(l!=r) &#123; int mid=(l+r)/2; init(l,mid,2*i); init(mid+1,r,2*i+1); &#125;&#125;void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; int i,n,m,t,x,y; scanf("%d %d",&amp;n,&amp;m); init(1,n,1); for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;t); insert(1,i,t); &#125; while(m--) &#123; scanf("%d %d %d",&amp;t,&amp;x,&amp;y); if(t==1) modify(1,x,y); else cout&lt;&lt;find_ans(x,y,1,t==3)&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对结构体的排序]]></title>
    <url>%2F2015%2F04%2F01%2Fjava-struct-sort%2F</url>
    <content type="text"><![CDATA[题目描述输入若干个学生的信息（学号、姓名、成绩），输入学号为0时结束，用单向链表组织这些学生的信息后，再按成绩由低到高顺序输出。 输入要求每行输入若干个学生的信息（学号、姓名、成绩），学号和成绩为整数，姓名为长度不超过10的字符串。 输入学号为0时结束。 输出要求按成绩由低到高输出所有学生的信息(如果成绩相同，按输入的次序输出)。 假如输入1 zhang 78 2 wang 80 3 Li 75 4 zhao 85 0 应当输出3 Li 75 1 zhang 78 2 wang 80 4 zhao 85 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Arrays;import java.util.Comparator;import java.util.Scanner;class Stu &#123; int index, id, score; String name;&#125;class mycmp implements Comparator&lt;Stu&gt; &#123; public int compare(Stu s1, Stu s2) &#123; if (s1.score != s2.score) return s1.score - s2.score; else return s1.index - s2.index; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); Stu[] s = new Stu[1000]; int temp, i; for (i = 0; i &lt; 1000; i++) &#123; temp = scan.nextInt(); if (temp == 0) break; else &#123; s[i] = new Stu(); s[i].index = i; s[i].id = temp; s[i].name = scan.next(); s[i].score = scan.nextInt(); &#125; &#125; Arrays.sort(s, 0, i, new mycmp()); for (int j = 0; j &lt; i; j++) &#123; System.out.println(s[j].id + " " + s[j].name + " " + s[j].score); &#125; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blocks]]></title>
    <url>%2F2015%2F03%2F24%2Fblocks%2F</url>
    <content type="text"><![CDATA[DescriptionDonald wishes to send a gift to his new nephew, Fooey. Donald is a bit of a traditionalist, so he has chosen to send a set of N classic baby blocks. Each block is a cube, 1 inch by 1 inch by 1 inch. Donald wants to stack the blocks together into a rectangular solid and wrap them all up in brown paper for shipping. How much brown paper does Donald need? InputThe first line of input contains C, the number of test cases. For each case there is an additional line containing N, the number of blocks to be shipped. N does not exceed 1000. OutputYour program should produce one line of output per case, giving the minimal area of paper (in square inches) needed to wrap the blocks when they are stacked together. Sample Input5 9 10 26 27 100 Sample Output30 34 82 54 130 分析：枚举，堆积起来的体积为ijk，则num%（i*j）肯定为整数，然后更新表面积得到最小即可。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std; void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; int t,i,j,m,num,ans,now; cin&gt;&gt;t; while(t--) &#123; ans=999999999; cin&gt;&gt;num; for(i=1;i&lt;=num;i++) &#123; for(j=1;j*i&lt;=num;j++) &#123; if(num%(i*j)!=0) continue; m=num/(i*j); now=i*j+i*m+m*j; if(now&lt;ans) ans=now; &#125; &#125; cout&lt;&lt;ans*2&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hay Points]]></title>
    <url>%2F2015%2F03%2F24%2Fhay-points%2F</url>
    <content type="text"><![CDATA[DescriptionEach employee of a bureaucracy has a job description - a few paragraphs that describe the responsibilities of the job. The employee’s job description, combined with other factors, such as seniority, is used to determine his or her salary. The Hay Point system frees the Human Resources department from having to make an intelligent judgement as to the value of the employee; the job description is merely scanned for words and phrases that indicate responsibility. In particular, job descriptions that indicate control over a large budget or management over a large number of people yield high Hay Point scores. You are to implement a simplified Hay Point system. You will be given a Hay Point dictionary and a number of job descriptions. For each job description you are to compute the salary associated with the job, according to the system. InputThe first line of input contains 2 positive integers: m &lt;= 1000, the number of words in the Hay Point dictionary, and n &lt;= 100, the number of job descriptions. m lines follow; each contains a word (a string of up to 16 lower-case letters) and a dollar value (a real number between 0 and 1,000,000). Following the dictionary are the n job descriptions. Each job description consists of one or more lines of text; for your convenience the text has been converted to lower case and has no characters other than letters, numbers, and spaces. Each job description is terminated by a line containing a period. OutputFor each job description, output the corresponding salary computed as the sum of the Hay Point values for all words that appear in the description. Words that do not appear in the dictionary have a value of 0. Sample Input7 2 administer 100000 spending 200000 manage 50000 responsibility 25000 expertise 100 skill 50 money 75000 the incumbent will administer the spending of kindergarden milk money and exercise responsibility for making change he or she will share responsibility for the task of managing the money with the assistant whose skill and expertise shall ensure the successful spending exercise . this individual must have the skill to perform a heart transplant and expertise in rocket science . Sample Output700150 150 分析：这题如果用映射当然最好不过了，我对STL还不是很熟悉，所以还是用结构体好了，输入的m个单词作为字典，之后输入的n个文本以’.’结尾，如果文本中出现字典中的单词，就加上值，最后输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std; struct dic&#123; char str[17]; int val;&#125;d[1001];void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; char temp[17]; int m,n,i,j,ans; cin&gt;&gt;m&gt;&gt;n; for(i=0;i&lt;m;i++) cin&gt;&gt;d[i].str&gt;&gt;d[i].val; for(j=0;j&lt;n;j++) &#123; ans=0; while(cin&gt;&gt;temp&amp;amp;&amp;amp;temp[0]!=&amp;#39;.&amp;#39;) &#123; for(i=0;i&lt;m;i++) &#123; if(strcmp(temp,d[i].str)==0) &#123; ans+=d[i].val; break; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YY's Minions]]></title>
    <url>%2F2015%2F03%2F22%2Fyys-minions%2F</url>
    <content type="text"><![CDATA[Despite YY’s so much homework, she would like to take some time to play with her minions first. YY lines her minions up to an N*M matrix. Every minion has two statuses: awake or asleep. We use 0(the digit) to represent that it is asleep, and 1 for awake. Also, we define the minions who are around a minion closest in one of the eight directions its neighbors. And every minute every minion will change its status by the following specific rules:If this minion is awake, and the number of its neighbors who are awake is less than 2, this minion will feel lonely and turn to asleep.If this minion is awake, and the number of its neighbors who are awake is more than 3, this minion will turn to asleep for it will feel too crowded.If this minion is awake, and the number of its neighbors who are awake is exactly 2 or 3, this minion will keep being awake and feel very happy.If this minion is asleep, and the number of its neighbors who are awake is exactly 3, this minion will wake up because of the noise.Note that all changes take place at the same time at the beginning of a specific minute.Also, some minions will get bored and leave this silly game. We use ‘X’s to describe them. We suppose that a minion would leave after T minutes. It will leave at the end of the Tth minute. Its status is considered during the change at the beginning of the Tth minute, and should be ignored after that. Of course, one minion will not leave twice! YY is a girl full of curiosity and wants to know every minion’s status after F minutes. But you know she is weak and lazy! Please help this cute girl to solve this problem :) InputThere are multiple test cases. The first line contains the number of test cases Q. 1&lt;=Q&lt;=100.For each case, there are several lines:The first line contains four integers N, M, F, K. K means the number of leaving messages. 1&lt;=N, M&lt;=50, 1&lt;=F&lt;=1000, 1&lt;=K&lt;=N*M.Next N lines are the matrix which shows the initial status of each minion. Each line contains M chars. We guarantee that ‘X’ wouldn’t appear in initial status matrix.And next K lines are the leaving messages. Each line contains three integers Ti, Xi, Yi, They mean the minion who is located in (Xi, Yi) will leave the game at the end of the Tith minutes. 1&lt;=Ti&lt;= F, 1&lt;=Xi&lt;=N, 1&lt;=Yi&lt;=M. OutputFor each case, output N lines as a matrix which shows the status of each minion after F minutes. Sample Input2 3 3 2 1 101 110 001 1 2 2 5 5 6 3 10111 01000 00000 01100 10000 2 3 3 2 4 1 5 1 5 Sample Output010 1X0 010 0000X 11000 00X00 X0000 00000 HintFor case 1: T=0, the game starts 101 110 001 at the beginning of T=1, a change took place 100 101 010 at the end of T=1 (the minion in (2,2) left) 100 1X1 010 at the beginning of T=2, a change took place 010 1X0 010 at the end of T=2 (nothing changed for no minion left at T=2) 010 1X0 010 分析：题目虽然长了点，但很好理解，注意那四个条件即可模拟求得。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int cnt[55][55],lea[55][55];//cnt周围醒着的数量，lea将要离开的时间char sta[55][55];//当前状态int dir[8][2]=&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 1&#125;, &#123;-1, -1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;&#125;;//遍历的八个方向void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; int t,i,j,q,n,m,f,k; cin&gt;&gt;q; while(q--) &#123; memset(sta,0,sizeof(sta)); memset(cnt,0,sizeof(cnt)); memset(lea,0,sizeof(cnt)); cin&gt;&gt;n&gt;&gt;m&gt;&gt;f&gt;&gt;k; getchar();//去除回车 for(i=1;i&lt;=n;i++)//得到初始状态图 &#123; for(j=1;j&lt;=m;j++) sta[i][j]=getchar(); getchar();//去除回车 &#125; while(k--) &#123; int t,x,y; cin&gt;&gt;t&gt;&gt;x&gt;&gt;y; lea[x][y]=t;//x,y处要离开的时间 &#125; for(t=1;t&lt;=f;t++) &#123; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; for(k=0;k&lt;8;k++)//遍历八个方向 &#123; int x=i+dir[k][1]; int y=j+dir[k][0]; if(x&lt;1 || y&lt;1 || x&gt;n || y&gt;m) continue; if(sta[x][y]=='1') ++cnt[i][j]; &#125; &#125; &#125; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; if(cnt[i][j]==3 &amp;&amp; sta[i][j]=='0')//自己睡着，周围醒着的数量恰好为3将醒来 sta[i][j]='1'; else if((cnt[i][j]&lt;2 || cnt[i][j]&gt;3) &amp;&amp; sta[i][j]=='1')//自己醒着，并且如果周围醒着的数量小于2或大于3将入睡 sta[i][j]='0'; //其余状态就不用改变 if(lea[i][j]==t) sta[i][j]='X';//到了t时间离开 cnt[i][j]=0;//重置醒着的数量 &#125; &#125; &#125; for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) putchar(sta[i][j]); puts(""); &#125; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等差数列]]></title>
    <url>%2F2015%2F03%2F22%2Farithmetic-progression%2F</url>
    <content type="text"><![CDATA[题目描述给定n(1&lt;=n&lt;=400)个数,从中找出尽可能多的数使得他们能够组成一个等差数列.求最长的等差数列的长度. 输入要求第一行是一个整数n,接下来一行包括了n个数,每个数的绝对值不超过10000000. 输出要求对于每个输入数据,输出你所找出的最长等差数列的长度 假如输入7 3 8 4 5 6 2 2 应当输出5 分析：枚举法，n^3时间复杂度，另一种方法是dp，dp[j][i]表示以a[j]和a[i]结尾的最长等差数列的长度。枚举最后两个元素，对于每一个a[j]和a[i]，都要找到a[p]，p &lt; j，满足a[p] + a[i] == 2 * a[j]。然后dp[p][j] + 1去更新dp[j][i]。看起来是三层循环，但其实对于同一个i，p的位置是随着j增大而增大的，所以最里面的while循环对于每个i值最多是O(n)的代价。总的代价还是O(n^2)。 枚举代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; int i,j,k,d,n,arr[401],ans=0,sum,la; cin&gt;&gt;n; if (n&lt;=2) cout&lt;&lt;n&lt;&lt;endl; else &#123; for(i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; sort(arr,arr+n); for (i=0;i&lt;n-1;++i) &#123; for (j=i+1;j&lt;n;++j) &#123; d=arr[j]-arr[i]; la=j; sum=2; for (k=j+1;k&lt;n;++k) &#123; if (arr[k]-arr[la]==d) &#123; la=k; ++sum; &#125; else if(arr[k]-arr[la]&gt;d) break; &#125; if (sum&gt;ans) ans=sum; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;&#125; dp代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;#define MAXL 410int dp[MAXL][MAXL];int find_(int a[], int n)&#123; int i, j; for(i = 1; i &lt; n; i++) &#123; int p = 0; for(j = 0; j &lt; i; j++) &#123; dp[j][i] = 2; while(p &lt; j &amp;&amp; a[p] + a[i] &lt; 2 * a[j]) p++; if(p &lt; j &amp;&amp; a[p] + a[i] == 2 * a[j]) dp[j][i] = max(dp[j][i], dp[p][j] + 1); &#125; &#125; int ans = (n &gt; 0); for(i = 1; i &lt; n; i++) for(j = 0; j &lt; i; j++) ans = max(ans, dp[j][i]); return ans;&#125;void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; int i,n,arr[401]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;arr[i]; sort(arr,arr+n); cout&lt;&lt;find_(arr,n);&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maze Problem]]></title>
    <url>%2F2015%2F02%2F12%2Fmaze-problem%2F</url>
    <content type="text"><![CDATA[题目描述Given a maze, find a shortest path from start to goal. 输入要求Input consists serveral test cases. First line of the input contains number of test case T. For each test case the first line contains two integers N , M ( 1 &lt;= N, M &lt;= 100 ). Each of the following N lines contain M characters. Each character means a cell of the map. Here is the definition for chracter. Constraint: For a character in the map: ‘S’ : start cell ‘E’ : goal cell ‘-‘ : empty cell ‘#’ : obstacle cell no two start cell exists. no two goal cell exists. 输出要求For each test case print one line containing shortest path. If there exists no path from start to goal, print -1. 假如输入1 5 5 S-### ----- ##--- E#--- ---## 应当输出9 分析：迷宫最短路径问题，安安分分用bfs宽搜就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;struct point &#123; int x,y;&#125;r[10005];int dis[4][2]=&#123;&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;0,1&#125;&#125;;char map[105][105];int ans[105][105];int m,n,si,sj,ei,ej;void bfs()&#123; int tail=1,head=0,i,x1,y1; r[0].x=si; r[0].y=sj; while(tail != head) &#123; x1=r[head].x; y1=r[head].y; for(i=0; i&lt;4; i++) &#123; x1+=dis[i][0], y1+=dis[i][1]; if(x1&gt;=0&amp;&amp;y1&gt;=0&amp;&amp;x1&lt;n&amp;&amp;y1&lt;m&amp;&amp;map[x1][y1]!='#'&amp;&amp;ans[x1][y1]==-1) &#123; r[tail].x=x1; r[tail].y=y1; ans[x1][y1] = 1 + ans[x1-dis[i][0]][y1-dis[i][1]]; tail++; &#125; x1-=dis[i][0], y1-=dis[i][1]; &#125; head++; if(ans[ei][ej]!=-1) break; &#125;&#125;void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; int t,i,j; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; memset(map,'#',sizeof(map)); memset(ans,-1,sizeof(ans)); for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]=='S') si=i,sj=j,ans[i][j]=0; if(map[i][j]=='E') ei=i,ej=j; &#125; getchar(); &#125; bfs(); if(ans[ei][ej]==-1) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;ans[ei][ej]&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>广搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tri Tiling]]></title>
    <url>%2F2015%2F01%2F26%2Ftri-tiling%2F</url>
    <content type="text"><![CDATA[In how many ways can you tile a 3xn rectangle with 2x1 dominoes? Here is a sample tiling of a 3x12 rectangle. InputInput consists of several test cases followed by a line containing -1. Each test case is a line containing an integer 0 ≤ n ≤ 30. OutputFor each test case, output one integer number giving the number of possible tilings. Sample Input2 8 12 -1 Sample Output3 153 2131 分析：给你一个3n的框框，用21的框框去填满，问一共有多少种不同的方法。首先，n为奇数肯定是0；当n为偶数时，n=2有3种拼法，当全部都由这三种组成的话f[n]=f[n-2]3;当出现上图两个红圈圈的情况时，我们就又有2（f[n-4]+f[n-6]+……f[0])，所以f(n)=3f(n-2)+2f(n-4)+…+2f(0)，可以解出f(n)=4f(n-2)-f(n-4)，其中f(0)=1,f(2)=3; ac代码: #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;string&gt; using namespace std; void solve(); int main() { solve(); return 0; } void solve() { int n,f[31] = {1,0,3}; for (int i = 4;i &lt;= 30;i ++) f[i] = f[i - 2]*4 - f[i - 4]; while (scanf ("%d",&amp;amp;n)&amp;amp;&amp;amp;n != -1) printf ("%d\n",f[n]); }]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tug of War]]></title>
    <url>%2F2015%2F01%2F18%2Ftug-of-war%2F</url>
    <content type="text"><![CDATA[题目描述A tug of war is to be arranged at the local office picnic. For the tug of war, the picnickers must be divided into two teams. Each person must be on one team or the other; the number of people on the two teams must not differ by more than 1; the total weight of the people on each team should be as nearly equal as possible. The first line of input contains n the number of people at the picnic. n lines follow. The first line gives the weight of person 1; the second the weight of person 2; and so on. Each weight is an integer between 1 and 450. There are at most 100 people at the picnic. Your output will be a single line containing 2 numbers: the total weight of the people on one team, and the total weight of the people on the other team. If these numbers differ, give the lesser first. 假如输入3 100 90 200 应当输出190 200 分析：有n个人，要分成2组，每个人有一个体重，要求两组人的总体重尽可能的接近。两个组的人数只差不得超过1.分别输出两个组分好后，人员总体重。总体重小的那个组先输出，中间隔一个空格。典型的01背包动态规划。人数一定，找出最接近中间值的那个数即可。动态转移方程： if(dp[j][k]) dp[j+1][k+wei[i]]=true; dp[j][k]表示从所有人里面选出j个人能拼成k的总体重； 在j个人能拼出的总体重可以等于k时，那么我们加入第i个人，我们的总人数就是j+1了，这时候拼出的总体重就是k+wei[i]了； 在处理的时候，我们必须从后面往前面搜索k。否则，我们本次处理的前面得出的数据变化会影响到后面的处理。 ac源码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;bool dp[55][22550];int wei[102];void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; int t,n,sum,i,j,k; sum=0; cin&gt;&gt;n; for(i=0; i&lt;n; i++) cin&gt;&gt;wei[i],sum+=wei[i]; memset(dp,false,sizeof(dp)); dp[0][0]=true; for(i=0; i&lt;n; i++) for(j=n/2; j&gt;=0; j--) for(k=sum/2-wei[i]; k&gt;=0; k--) if(dp[j][k]) dp[j+1][k+wei[i]]=true; int max; for(i=sum/2; i&gt;=0; i--) &#123; if(dp[n/2][i]) &#123; max=i; break; &#125; &#125; if(n%2!=0) &#123; for(i=sum/2; i&gt;=0; i--) if(dp[n/2+1][i]) &#123; if(i&gt;max) max=i; break; &#125; &#125; cout&lt;&lt;max&lt;&lt;" "&lt;&lt;sum-max&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A sequence of numbers（快速求幂）]]></title>
    <url>%2F2015%2F01%2F12%2Fa-sequence-of-numbers%2F</url>
    <content type="text"><![CDATA[题目描述Xinlv wrote some sequences on the paper a long time ago, they might be arithmetic or geometric sequences. The numbers are not very clear now, and only the first three numbers of each sequence are recognizable. Xinlv wants to know some numbers in these sequences, and he needs your help. 输入要求The first line contains an integer N, indicting that there are N sequences. Each of the following N lines contain four integers. The first three indicating the first three numbers of the sequence, and the last one is K, indicating that we want to know the K-th numbers of the sequence.You can assume 0 &lt; K &lt;= 10^9, and the other three numbers are in the range [0, 2^63). All the numbers of the sequences are integers. And the sequences are non-decreasing. 输出要求Output one line for each test case, that is, the K-th number module (%) 200907. 假如输入2 1 2 3 5 1 2 4 5 应当输出5 16 题目大意很简单，就是给你一个序列的前三项，该序列不是等差就是等比，让你求第K项余200907，求等比时用到快速求幂，不用的话应该会TLE，下面介绍快速求幂： 快速求幂实现代码为 1234567891011int fastpow(int a,int b) &#123; int r=1,base=a; while(b!=0) &#123; if(b&amp;1) r*=base; base*=base; b&gt;&gt;=1; &#125; return r;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include &lt;vector&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include &lt;cstring&gt;#include&lt;ctype.h&gt;#include&lt;math.h&gt;#include &lt;queue&gt;#include&lt;map&gt;using namespace std;int MOD=200907;long long fastpow(long long q,long long n)&#123; long long r=1; while(n) &#123; if(n&amp;amp;1) r=r%MOD*(q%MOD)%MOD; q=q%MOD*(q%MOD)%MOD; n&gt;&gt;=1; &#125; return r;&#125;void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; long long t,a1,a2,a3,n,d,ans,q; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;a3&gt;&gt;n; if(a2*2==a1+a3) &#123; d=a2-a1; ans=(a1+(n-1)*d%MOD)%MOD; &#125; else &#123; q=a2/a1; ans=a1*fastpow(q,n-1)%MOD; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Additive equations]]></title>
    <url>%2F2015%2F01%2F04%2Fadditive-equations%2F</url>
    <content type="text"><![CDATA[题目描述We all understand that an integer set is a collection of distinct integers. Now the question is: given an integer set, can you find all its addtive equations? To explain what an additive equation is, let’s look at the following examples:1+2=3 is an additive equation of the set {1,2,3}, since all the numbers that are summed up in the left-hand-side of the equation, namely 1 and 2, belong to the same set as their sum 3 does. We consider 1+2=3 and 2+1=3 the same equation, and will always output the numbers on the left-hand-side of the equation in ascending order. Therefore in this example, it is claimed that the set {1,2,3} has an unique additive equation 1+2=3.It is not guaranteed that any integer set has its only additive equation. For example, the set {1,2,5} has no addtive equation and the set {1,2,3,5,6} has more than one additive equations such as 1+2=3, 1+2+3=6, etc. When the number of integers in a set gets large, it will eventually become impossible to find all the additive equations from the top of our minds – unless you are John von Neumann maybe. So we need you to program the computer to solve this problem. 输入要求The input data consists of several test cases.The first line of the input will contain an integer N, which is the number of test cases.Each test case will first contain an integer M (1&lt;=M&lt;=30), which is the number of integers in the set, and then is followed by M distinct positive integers in the same line. 输出要求For each test case, you are supposed to output all the additive equations of the set. These equations will be sorted according to their lengths first( i.e, the number of integer being summed), and then the equations with the same length will be sorted according to the numbers from left to right, just like the sample output shows. When there is no such equation, simply output “Can’t find any equations.” in a line. Print a blank line after each test case. 假如输入3 3 1 2 3 3 1 2 5 6 1 2 3 5 4 6 应当输出1+2=3 Can't find any equations. 1+2=3 1+3=4 1+4=5 1+5=6 2+3=5 2+4=6 1+2+3=6 题目意思很简单，就是输入一串长度为M的整数，求这组数据中的等式并输出，等式长度从短到长，且等式中自左向右递增。 思路就是先对这组数据进行排序，然后从2——（M-1）长度的等式进行深搜，深搜注意剪枝，否则会超时，没搜到一个等式就存入表中，最后对表进行排序输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;algorithm&gt;#include &lt;vector&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;ctype.h&gt;#include&lt;cmath&gt;#include &lt;queue&gt;#define MAXN 30000using namespace std;int a[50],flag[50];int N;struct s&#123; int a[50]; int lenth;&#125; str[MAXN];int k=0;void input()&#123; k++; str[k].lenth=0; int t=1; for (int i=1; i&lt;=N; i++) if (flag[i]!=0) str[k].a[t++]=a[i],str[k].lenth++;&#125;void dfs(int i,int sum)&#123; sum+=a[i]; if (sum&gt;a[N]) return ; for (int j=i+1; j&lt;=N; j++) if (sum==a[j]) &#123; flag[j]=1; input(); flag[j]=0; break; &#125; for (int j=i+1; j&lt;N; j++) &#123; flag[j]=1; dfs(j,sum); flag[j]=0; &#125;&#125;bool cmp(struct s a,struct s b)&#123; if(a.lenth!=b.lenth) return a.lenth&lt;b.lenth; for(int i=1; i&lt;=a.lenth; i++) if (a.a[i]!=b.a[i]) return a.a[i]&lt;b.a[i];&#125;void solve();int main()&#123; solve(); return 0;&#125;void solve()&#123; int T; cin&gt;&gt;T; while (T--) &#123; memset(flag,0,sizeof(flag)); memset(a,0,sizeof(a)); k=0; cin&gt;&gt;N; for (int i=1; i&lt;=N; i++) cin&gt;&gt;a[i]; sort(a+1,a+1+N); for (int i=1; i&lt;N-1; i++) &#123; flag[i]=1; dfs(i,0); flag[i]=0; &#125; sort(str+1,str+k+1,cmp); if (k==0) printf("Can't find any equations.\n\n"); else for (int i=1; i&lt;=k; i++) &#123; int j; printf("%d",str[i].a[1]); for (j=2; j&lt;str[i].lenth; j++) printf("+%d",str[i].a[j]); printf("=%d\n",str[i].a[j]); &#125; printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>深搜</tag>
      </tags>
  </entry>
</search>
