# AucFrame 之模块内通信

[「AucFrame 之模块内通信」源码传送门](https://github.com/Blankj/AucFrameTemplate/releases/tag/5)

## 背景
上一节中，我们解决了模块间通讯的问题，那么，模块内的通讯我们使用什么呢？这里，我推荐比 EventBus 更高效的 `BusUtils`，相关地址在这里 **[BusUtils 传送门](https://github.com/Blankj/AndroidUtilCode/tree/master/plugin/bus-gradle-plugin)**。


## 实践
看完了 `BusUtils` 的说明文档，接下来就让我们使用到我们工程中来吧。首先引入 `bus` 的插件，我们往 `Config.depConfig` 中加入如下代码：

```groovy
plugin       : [
        ...
        bus   : new DepConfig("com.blankj:bus-gradle-plugin:2.0"),
],
```

然后我们往 `buildAPP.gradle` 加入 bus 的 plugin，具体如下所示：

```groovy
apply {
    ...
    plugin "com.blankj.bus"
}
```

我们遵循 **[BusUtils](https://github.com/Blankj/AndroidUtilCode/tree/master/plugin/bus-gradle-plugin)** 的规范，在 `pkg` 包下创建一个 `BusConfig` 类用来保存本模块所有的 `tag`，然后在 `Featrue1Activity` 去创建事件和消费事件，具体如下所示：

```java
// BusConifg
public class BusConifg {
    public static final String FEATURE0_SHOW_TOAST = "feature0_show_toast";
}

// Feature0Activity
@BusUtils.Bus(tag = BusConifg.FEATURE0_SHOW_TOAST)
public void showToast(String msg) {
    ToastUtils.showLong(msg);
}

@Override
public void initView(@Nullable Bundle savedInstanceState, @Nullable View contentView) {
    ...
    BusUtils.register(this);
    findViewById(R.id.showBusToast).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            BusUtils.post(BusConifg.FEATURE0_SHOW_TOAST, "show toast.");
        }
    });
}

@Override
protected void onDestroy() {
    super.onDestroy();
    BusUtils.unregister(this);
}
```

这样，我们便完成了模块内事件通信。


## 最后的话

到此，AucFrame 框架已完全介绍完毕，不知大家是否都跟着教程和源码完整地过了一遍，是的话，我觉得带来的收获肯定不少，基于模板工程，你便可以快速在下个工程中使用了，当然，如果你完全实践了该课程并了解了原理，那么也可以试着去优化你现有工程来达到类似 AucFrame 的功能。