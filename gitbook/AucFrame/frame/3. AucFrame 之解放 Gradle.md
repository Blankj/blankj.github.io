# AucFrame 之解放 Gradle

[「AucFrame 之解放 Gradle」源码传送门](https://github.com/Blankj/AucFrameTemplate/releases/tag/3)

## 背景
上一节统一管理 Gradle 中，我们在 `export`、`pkg`、`app` 中的 `build.gradle` 重复做着相似的事情，其实只要架构确定，我们完全可以动态写入，这里，我们就要利用一下 `gradle.addBuildListener` 这个 hook。Gradle 生命周期第一步就是执行 `setting.gradle` 中的内容，我们在此植入该 hook 即可。


## 实践

### 解放 setting.gradle
`setting.gradle` 可以访问到 `buildSrc` 吗，答案是肯定的。

我们在此之前，先写一个日志工具方便我们了解具体生命周期，我这里提供一个实用的 `GLog.groovy`，具体可以在源码中查阅，输出是带边框的哦。

接下来，我们在 `buildSrc` 中创建 `ConfigUtils.groovy` 来做 Gradle 生命周期的 hook，源码如下所示：

```groovy
import org.gradle.BuildListener
import org.gradle.BuildResult
import org.gradle.api.initialization.Settings
import org.gradle.api.invocation.Gradle

class ConfigUtils {

    static addBuildListener(Gradle g) {
        g.addBuildListener(new BuildListener() {
            @Override
            void buildStarted(Gradle gradle) {
                GLog.d("buildStarted")
            }

            @Override
            void settingsEvaluated(Settings settings) {
                GLog.d("settingsEvaluated")
            }

            @Override
            void projectsLoaded(Gradle gradle) {
                GLog.d("projectsLoaded")
            }

            @Override
            void projectsEvaluated(Gradle gradle) {
                GLog.d("projectsEvaluated")
            }

            @Override
            void buildFinished(BuildResult buildResult) {
                GLog.d("buildFinished")
            }
        })
    }
}
```
然后我们在 `setting.gradle` 中写入如下内容：
```groovy
GLog.d("setting.gradle")

ConfigUtils.addBuildListener(gradle)

include ':lib:base', ':lib:common',
        ':feature:feature0:export', ':feature:feature1:export',
        ':feature:feature0:pkg', ':feature:feature1:pkg',
        ':feature:feature0:app', ':feature:feature1:app', ':feature:launcher:app'
```

在根目录下的 `build.gradle`、`buildApp.gradle`、`buildLib.gradle` 在首行分别加入如下内容：
```groovy
GLog.d(project.toString() + " -> root")
GLog.d(project.toString() + " -> app")
GLog.d(project.toString() + " -> lib")
```

然后执行 `./gradlew clean` 命令，输出如下所示：

```txt
setting.gradle
settingsEvaluated
projectsLoaded
root project 'AucFrameTemplate' -> root
project ':lib:base' -> lib
project ':lib:common' -> lib
project ':feature:feature0:app' -> app
project ':feature:feature0:export' -> lib
project ':feature:feature0:pkg' -> lib
project ':feature:feature1:app' -> app
project ':feature:feature1:export' -> lib
project ':feature:feature1:pkg' -> lib
project ':feature:launcher:app' -> app
projectsEvaluated
buildFinished
```

这里我们可以看到其具体生命周期，基于此，我们可以在 `settingsEvaluated` 中做 `setting.gradle` 的任务可以解放 `setting.gradle`，具体如下所示：

```groovy
// setting.gradle
ConfigUtils.addBuildListener(gradle)

// ConfigUtils.groovy
@Override
void settingsEvaluated(Settings settings) {
    GLog.d("settingsEvaluated")
    includeModule(settings)
}

private static includeModule(Settings settings) {
    settings.include ':lib:base', ':lib:common',
            ':feature:feature0:export', ':feature:feature1:export',
            ':feature:feature0:pkg', ':feature:feature1:pkg',
            ':feature:feature0:app', ':feature:feature1:app', ':feature:launcher:app'
}
```

### 解放 build.gradle
我们还要解放 module 中的 `build.gradle`，我们可以利用 `projectsLoaded` 这个 hook，在其中加入如下代码：

```groovy
@Override
void projectsLoaded(Gradle gradle) {
    GLog.d("projectsLoaded")
    gradle.addProjectEvaluationListener(new ProjectEvaluationListener() {
        @Override
        void beforeEvaluate(Project project) {
            GLog.d("beforeEvaluate")
        }
        @Override
        void afterEvaluate(Project project, ProjectState projectState) {
            GLog.d("afterEvaluate")
        }
    })
}
```

再次执行 `./gradlew clean`，会发现 `beforeEvaluate` 执行在各 module 的 `build.gradle` 之前，`afterEvaluate` 在之后，基于此，我们也就可以想到把开头的 apply 都放到这里来了，具体如下所示：

```groovy
// ConfigUtils.groovy
@Override
void projectsLoaded(Gradle gradle) {
    GLog.d("projectsLoaded")
    gradle.addProjectEvaluationListener(new ProjectEvaluationListener() {
        @Override
        void beforeEvaluate(Project project) {
            if (project.subprojects.isEmpty()) {// 定位到具体 project
                if (project.name == "app") {
                    GLog.l(project.toString() + " applies buildApp.gradle")
                    project.apply {
                        from "${project.rootDir.path}/buildApp.gradle"
                    }
                } else {
                    GLog.l(project.toString() + " applies buildLib.gradle")
                    project.apply {
                        from "${project.rootDir.path}/buildLib.gradle"
                    }
                }
            }
        }
        @Override
        void afterEvaluate(Project project, ProjectState projectState) {
        }
    })
}
```

可以看到在 `beforeEvaluate` 中对 app 我们已经 `apply buildApp.gradle` 了，对 `lib` 做了 `apply buildLib.gradle`了，现在可以把各个 module 首行的 apply 都可以删去了，然后 Gradle 同步下项目查看是否成功。

现在 feature 下的各 module 中的 `build.gradle` 只剩下 `dependencies` 域了，现在让我们把它也去除。

我们考虑下是否可以把 setting 中 include 各个 project 也放到 Config 中的 `depConfig` 呢，而且支持开关配置和远程仓库的切换？接下来就让我们骚操作一番。

**下面是干货**
**下面是干货**
**下面是干货**

我们建立一个 `DepConfig.groovy` 来记录各个库的属性，具体如下所示：
```groovy
class DepConfig {
    boolean useLocal // 是否使用本地的
    String localPath // 本地路径
    String remotePath// 远程路径
    boolean isApply  // 是否应用
    String path      // 最后的路径
    def dep          // 根据条件生成项目最终的依赖项

    DepConfig(String path) {
        this(path, true)
    }

    DepConfig(String path, boolean isApply) {
        if (path.startsWith(":")) {
            this.useLocal = true
            this.localPath = path
            this.isApply = isApply
        } else {
            this.useLocal = false
            this.remotePath = path
            this.isApply = isApply
        }
        this.path = path
    }

    DepConfig(boolean useLocal, String localPath, String remotePath) {
        this(useLocal, localPath, remotePath, true)
    }

    DepConfig(boolean useLocal, String localPath, String remotePath, boolean isApply) {
        this.useLocal = useLocal
        this.localPath = localPath
        this.remotePath = remotePath
        this.isApply = isApply
        this.path = useLocal ? localPath : remotePath
    }

    @Override
    String toString() {
        return "DepConfig { " +
                "useLocal = " + useLocal +
                (dep == null ? ", path = " + path : (", dep = " + dep)) +
                ", isApply = " + isApply +
                " }"
    }
}
```

下面我们来改造 `Config.depConfig`，改为如下所示：

```groovy
// appConfig 配置的是可以跑 app 的模块，git 提交务必只包含 launcher
static appConfig = ['launcher', 'feature0']
// pkgConfig 配置的是要依赖的功能包，为空则依赖全部，git 提交务必为空
static pkgConfig = ['feature0']
static depConfig = [
        feature      : [
                launcher: [
                        app: new DepConfig(":feature:launcher:app")
                ],
                feature0: [
                        app   : new DepConfig(":feature:feature0:app"),
                        pkg   : new DepConfig(true, ":feature:feature0:pkg", "com.blankj:feature-feature0-pkg:1.0", true),
                        export: new DepConfig(":feature:feature0:export"),
                ],
                feature1: [
                        app   : new DepConfig(":feature:feature1:app"),
                        pkg   : new DepConfig(":feature:feature1:pkg"),
                        export: new DepConfig(":feature:feature1:export"),
                ],
        ],
        lib          : [
                base  : new DepConfig(":lib:base"),
                common: new DepConfig(":lib:common"),
        ],
        support      : [
                appcompat_v7: new DepConfig("com.android.support:appcompat-v7:$support_version"),
                design      : new DepConfig("com.android.support:design:$support_version"),
                multidex    : new DepConfig("com.android.support:multidex:1.0.2"),
                constraint  : new DepConfig("com.android.support.constraint:constraint-layout:1.1.3"),
        ],
        kotlin       : new DepConfig("org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"),
        utilcode     : new DepConfig("com.blankj:utilcode:1.25.0"),
        free_proguard: new DepConfig("com.blankj:free-proguard:1.0.1"),
        swipe_panel  : new DepConfig("com.blankj:swipe-panel:1.1"),
        leakcanary   : [
                android         : new DepConfig("com.squareup.leakcanary:leakcanary-android:$leakcanary_version"),
                android_no_op   : new DepConfig("com.squareup.leakcanary:leakcanary-android-no-op:$leakcanary_version"),
                support_fragment: new DepConfig("com.squareup.leakcanary:leakcanary-support-fragment:$leakcanary_version"),
        ],
]
```

`Config.appConfig` 和 `Config.pkgConfig` 通过注释我已经说明得很清楚了，它们是方便我们切换工程属性的两个配置，对单模块调试或者多模块联合开发有很大的帮助。

后面的 `Config.depConfig` 已经从简单的 `String` 类型切换到了 `DepConfig`，我们以最复杂的 `:feature:feature0:pkg` 为例，它的配置是 `new DepConfig(true, ":feature:feature0:pkg", "com.blankj:feature-feature0-pkg:1.0", true)`，其参数意思在 `DepConfig` 中已经说明了，我这边再完整说一下，最后的参数 `isApply` 代表是否开启依赖，开启的话就会依赖到项目中，否则是不会依赖到项目中的，第一个参数是是否使用本地源码，如果为 `true`，那么就会使用第二个参数的本地 module 路径，否则就会使用第三个参数的远程依赖路径（com.blankj:feature-feature0-pkg:1.0 仓库并不存在，这里只是为了说明）。还存在一个问题就是，此时我们 `DepConfig` 中的本地 module 路径中只是个普通字符串，并不是我们 dependencies 中需要的 project 类型，这里我们需要在 `projectsLoaded` 中做一下处理，然后把最终的依赖赋值给 `DepConfig.dep`，最终让 dependencies 中所有都依赖 `DepConfig.dep`，下面是 `ConfigUtils` 中最主要的实现：

```groovy
@Override
void settingsEvaluated(Settings settings) {
    GLog.d("settingsEvaluated")
    includeModule(settings)
}

/**
 * 在 settings.gradle 中 根据 appConfig 和 pkgConfig 来 include 本地模块
 */
private static includeModule(Settings settings) {
    def config = getDepConfigByFilter(new DepConfigFilter() {
        @Override
        boolean accept(String name, DepConfig config) {
            if (name.endsWith('.app')) {// 如果最终是 app 的话
                def appName = name.substring('feature.'.length(), name.length() - 4)// 获取 app 模块的名字
                if (!Config.appConfig.contains(appName)) {// 如果 Config.appConfig 中不存在，那就不让它进依赖
                    config.isApply = false
                }
            }
            if (!Config.pkgConfig.isEmpty()) {// 如果 Config.pkgConfig 不为空，说明是 pkg 调试模式
                if (name.endsWith('.pkg')) {// 如果是 pkg 的话
                    def pkgName = name.substring('feature.'.length(), name.length() - 4)// 获取 pkg 模块的名字
                    if (!Config.pkgConfig.contains(pkgName)) {// 如果 Config.pkgConfig 中不存在，那就不让它进依赖
                        config.isApply = false
                    }
                }
            }
            // 过滤出本地并且 apply 的模块
            if (!config.isApply) return false
            if (!config.useLocal) return false
            if (config.localPath == "") return false
            return true
        }
    }).each { _, cfg ->// 把本地模块 include 进去
        settings.include cfg.localPath
    }
    GLog.l("includeModule = ${GLog.object2String(config)}")
}

@Override
void projectsLoaded(Gradle gradle) {
    GLog.d("projectsLoaded")
    generateDep(gradle)
    gradle.addProjectEvaluationListener(new ProjectEvaluationListener() {
        @Override
        void beforeEvaluate(Project project) {
            if (project.subprojects.isEmpty()) {// 定位到具体 project
                if (project.name == "app") {
                    GLog.l(project.toString() + " applies buildApp.gradle")
                    project.apply {
                        from "${project.rootDir.path}/buildApp.gradle"
                    }
                } else {
                    GLog.l(project.toString() + " applies buildLib.gradle")
                    project.apply {
                        from "${project.rootDir.path}/buildLib.gradle"
                    }
                }
            }
        }
        @Override
        void afterEvaluate(Project project, ProjectState projectState) {
        }
    })
}

/**
 * 根据 depConfig 生成 dep
 */
private static generateDep(Gradle gradle) {
    def config = getDepConfigByFilter(new DepConfigFilter() {
        @Override
        boolean accept(String name, DepConfig config) {
            if (config.useLocal) {// 如果使用的是本地模块，那么把它转化为 project
                config.dep = gradle.rootProject.findProject(config.localPath)
            } else {// 如果是远端依赖，那就直接使用远端依赖即可
                config.dep = config.remotePath
            }
            return true
        }
    })
    GLog.l("generateDep = ${GLog.object2String(config)}")
}

/**
 * 根据过滤器来获取 DepConfig
 */
static Map<String, DepConfig> getDepConfigByFilter(DepConfigFilter filter) {
    return _getDepConfigByFilter("", Config.depConfig, filter)
}

private static _getDepConfigByFilter(String namePrefix, Map map, DepConfigFilter filter) {
    def depConfigList = [:]// 结果 Map
    for (Map.Entry entry : map.entrySet()) {
        def (name, value) = [entry.getKey(), entry.getValue()]
        if (value instanceof Map) {// 如果值是 Map 类型就加到结果 Map 中
            namePrefix += (name + '.')
            depConfigList.putAll(_getDepConfigByFilter(namePrefix, value, filter))
            namePrefix -= (name + '.')
            continue
        }
        def config = value as DepConfig
        if (filter == null || filter.accept(namePrefix + name, config)) {
            depConfigList.put(namePrefix + name, config)// 符合过滤条件就加到结果 Map 中
        }
    }
    return depConfigList
}

interface DepConfigFilter {
    boolean accept(String name, DepConfig config);
}
```

注释已经把关键的地方写得很清楚了，下面我们就可以来做取消 feature 中各模块的 dependencies 了，我们在 `ConfigUtils` 添加获取可用的 `pkg` 和 `export` 的代码：

```groovy
static getApplyPkgs() {
    def applyPkgs = getDepConfigByFilter(new DepConfigFilter() {
        @Override
        boolean accept(String name, DepConfig config) {
            if (!config.isApply) return false
            return name.endsWith(".pkg")
        }
    })
    GLog.d("getApplyPkgs = ${GLog.object2String(applyPkgs)}")
    return applyPkgs
}

static getApplyExports() {
    def applyExports = getDepConfigByFilter(new DepConfigFilter() {
        @Override
        boolean accept(String name, DepConfig config) {
            if (!config.isApply) return false
            return name.endsWith(".export")
        }
    })
    GLog.d("getApplyExports = ${GLog.object2String(applyExports)}")
    return applyExports
}
```

然后在 `buildApp.gradle` 中的 dependencie 中把之前的依赖最后加 `.dep`，并加入依赖所有可用 `pkg` 的代码：

```groovy
dependencies {
    // LeakCanary
    debugImplementation Config.depConfig.leakcanary.android.dep
    debugImplementation Config.depConfig.leakcanary.support_fragment.dep
    releaseImplementation Config.depConfig.leakcanary.android_no_op.dep

    // 根据 Config.pkgConfig 来依赖所有 pkg
    for (def entrySet : ConfigUtils.getApplyPkgs().entrySet()) {
        api entrySet.value.dep
    }
}
```

然后在 `buildLib.gradle` 中的 dependencie 中加入如下 pkg 模块依赖所有 export，以及 export 依赖 common 的代码：

```groovy
dependencies {
    if (project.name == 'pkg') {
        // if module's name equals 'pkg', api all of export
        for (def entrySet : ConfigUtils.getApplyExports().entrySet()) {
            api entrySet.value.dep
        }
    } else if (project.name == 'export') {
        api Config.depConfig.lib.common.dep
    }
}
```

最后，我们就可以清空 feature 中所有的 `build.gradle` 中的 `dependencies` 域了，然后把 `common` 中依赖 `base` 的模块更新为 `Config.depConfig.lib.base.dep`，把 `base` 的 `dependencies` 中都加入 `.dep` 后缀，具体如下所示：

```groovy
// common
dependencies {
    api Config.depConfig.lib.base.dep
}

// base
dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    api Config.depConfig.utilcode.dep.dep
    api Config.depConfig.free_proguard.dep
    api Config.depConfig.swipe_panel.dep

    api Config.depConfig.support.appcompat_v7.dep
    api Config.depConfig.support.design.dep
    api Config.depConfig.support.multidex.dep
    api Config.depConfig.support.constraint.dep
    api Config.depConfig.kotlin.dep
    compileOnly Config.depConfig.leakcanary.android_no_op.dep
}
```

到此，我们的 Gradle 已经完全解放了，我们 Gradle 同步一下，正常情况是不会出错的，有问题的话可以参考源码查找差异点，我们运行一下 `./gradlew clean`，可以发现我写的 `ConfigUtils` 中写的日志还是很有帮助的哦，具体如下所示：

```
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ settingsEvaluated
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ includeModule = [
│         feature.launcher.app      : DepConfig { useLocal = true, path = :feature:launcher:app, isApply = true },
│         feature.feature0.pkg      : DepConfig { useLocal = true, path = :feature:feature0:pkg, isApply = true },
│         feature.feature0.export   : DepConfig { useLocal = true, path = :feature:feature0:export, isApply = true },
│         feature.feature1.pkg      : DepConfig { useLocal = true, path = :feature:feature1:pkg, isApply = true },
│         feature.feature1.export   : DepConfig { useLocal = true, path = :feature:feature1:export, isApply = true },
│         lib.base                  : DepConfig { useLocal = true, path = :lib:base, isApply = true },
│         lib.common                : DepConfig { useLocal = true, path = :lib:common, isApply = true }
│ ]
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ projectsLoaded
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ generateDep = [
│         feature.launcher.app      : DepConfig { useLocal = true, dep = project ':feature:launcher:app', isApply = true },
│         feature.feature0.app      : DepConfig { useLocal = true, path = :feature:feature0:app, isApply = false },
│         feature.feature0.pkg      : DepConfig { useLocal = true, dep = project ':feature:feature0:pkg', isApply = true },
│         feature.feature0.export   : DepConfig { useLocal = true, dep = project ':feature:feature0:export', isApply = true },
│         feature.feature1.app      : DepConfig { useLocal = true, path = :feature:feature1:app, isApply = false },
│         feature.feature1.pkg      : DepConfig { useLocal = true, dep = project ':feature:feature1:pkg', isApply = true },
│         feature.feature1.export   : DepConfig { useLocal = true, dep = project ':feature:feature1:export', isApply = true },
│         lib.base                  : DepConfig { useLocal = true, dep = project ':lib:base', isApply = true },
│         lib.common                : DepConfig { useLocal = true, dep = project ':lib:common', isApply = true },
│         support.appcompat_v7      : DepConfig { useLocal = false, dep = com.android.support:appcompat-v7:27.1.1, isApply = true },
│         support.design            : DepConfig { useLocal = false, dep = com.android.support:design:27.1.1, isApply = true },
│         support.multidex          : DepConfig { useLocal = false, dep = com.android.support:multidex:1.0.2, isApply = true },
│         support.constraint        : DepConfig { useLocal = false, dep = com.android.support.constraint:constraint-layout:1.1.3, isApply = true },
│         kotlin                    : DepConfig { useLocal = false, dep = org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.3.10, isApply = true },
│         utilcode                  : DepConfig { useLocal = false, dep = com.blankj:utilcode:1.25.0, isApply = true },
│         free_proguard             : DepConfig { useLocal = false, dep = com.blankj:free-proguard:1.0.1, isApply = true },
│         swipe_panel               : DepConfig { useLocal = false, dep = com.blankj:swipe-panel:1.1, isApply = true },
│         leakcanary.android        : DepConfig { useLocal = false, dep = com.squareup.leakcanary:leakcanary-android:1.6.3, isApply = true },
│         leakcanary.android_no_op  : DepConfig { useLocal = false, dep = com.squareup.leakcanary:leakcanary-android-no-op:1.6.3, isApply = true },
│         leakcanary.support_fragment: DepConfig { useLocal = false, dep = com.squareup.leakcanary:leakcanary-support-fragment:1.6.3, isApply = true }
│ ]
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ project ':lib:base' applies buildLib.gradle
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ project ':lib:common' applies buildLib.gradle
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ project ':feature:feature0:pkg' applies buildLib.gradle
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ getApplyExports = [
│         feature.feature0.export   : DepConfig { useLocal = true, dep = project ':feature:feature0:export', isApply = true },
│         feature.feature1.export   : DepConfig { useLocal = true, dep = project ':feature:feature1:export', isApply = true }
│ ]
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ project ':feature:feature1:export' applies buildLib.gradle
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ project ':feature:feature1:pkg' applies buildLib.gradle
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ getApplyExports = [
│         feature.feature0.export   : DepConfig { useLocal = true, dep = project ':feature:feature0:export', isApply = true },
│         feature.feature1.export   : DepConfig { useLocal = true, dep = project ':feature:feature1:export', isApply = true }
│ ]
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ project ':feature:launcher:app' applies buildApp.gradle
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ getApplyPkgs = [
│         feature.feature0.pkg      : DepConfig { useLocal = true, dep = project ':feature:feature0:pkg', isApply = true },
│         feature.feature1.pkg      : DepConfig { useLocal = true, dep = project ':feature:feature1:pkg', isApply = true }
│ ]
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ projectsEvaluated
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────
│ buildFinished
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

看了这个日志岂不美哉哈，现在你可以体验下动态切换 app 和 pkg 的功能了，比如：

```groovy
appConfig = ['launcher', 'feature0']
pkgConfig = ['feature0']
```
此时我们可以运行 `pkg` 只包括 `feature0` 的 `launcher-app` 和 `feature0-app`。


## 维护

随着业务越来越多，你会发现该种方式比以往的开发效率会高出很多，但随着源码越来越多，如果每个 `pkg` 和 `export` 都没有上传到远端仓库的话，跑一次 `launcher` 的全量包的话就会包括把 `pkg` 和 `export` 的源码编译时间加上，为了减少源码的编译时间，我们应该在上线一个版本前，把所有有更新的 `pkg` 和 `export` 都上传到远端，然后把 `pkg` 和 `export` 的 `isLocal` 都设置为 `false` 来依赖远端仓库，这样就大大减少了本地源码编译的时间，虽然对于单模块调试是没有什么影响的，但如果本地需要全量跑一遍 `launcher` 的话就可以大幅度提升速度。

如果你需要配置每个模块的代码权限，我们可以把每个模块作为一个 git 的 submodule 来使用，这样的话，就更加需要把 `pkg` 和 `export` 上传到远端仓库了，否则，在 `isLocal = true` 的情况下没有源码参与编译就会 GG 了哦。


## 优化

每次创建一个模块的 `app`、`pkg`、`export` 还是挺麻烦的，我们可以开发一个 IDEL 插件来完成三个模块的创建，由于比较忙，我没有开发，有兴趣的小伙伴可以帮我开发一个造福大家哦。但我在 feature 中为大家提供了 `template` 目录方便你直接拷贝，然后修改为你的业务名，再修改下包名，最后在 `Config.groovy` 的 feature 中加入它即可。