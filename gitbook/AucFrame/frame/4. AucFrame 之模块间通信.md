# AucFrame 之模块间通信

[「AucFrame 之模块间通信」源码传送门](https://github.com/Blankj/AucFrameTemplate/releases/tag/4)

## 背景
上一节中我们搭建了牛逼的工程配置，这一节我们来了解下模块间通信的问题吧，业界比较常见的做法就是路由，或者接口下沉，我觉得他们都没达到我的预期，要么太冗余复杂，要么不够智能，如今基于我的工程结构，设计出了一套更适合的通讯方式，就是 `ApiUtils`，表现形式和 SPI 方式差不多，但比它更优秀，更方便，相关地址在这里 **[ApiUtils 传送门](https://github.com/Blankj/AndroidUtilCode/tree/master/plugin/api-gradle-plugin)**。


## 实践
看完了 `ApiUtils` 的说明文档，接下来就让我们使用到我们工程中来吧。首先引入 `api` 的插件，我们往 `Config.depConfig` 中加入如下代码：

```groovy
plugin       : [
        gradle: new DepConfig("com.android.tools.build:gradle:3.3.0"),
        kotlin: new DepConfig("org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"),
        api   : new DepConfig("com.blankj:api-gradle-plugin:1.0"),
],
```

那么我们根目录的 `build.gradle` 可以做下优化，如下所示：

```groovy
// ConfigUtils
static getApplyPlugins() {
    def plugins = getDepConfigByFilter(new DepConfigFilter() {
        @Override
        boolean accept(String name, DepConfig config) {
            if (!name.startsWith("plugin.")) return false
            if (!config.isApply) return false
            return true
        }
    })
    GLog.d("getApplyPlugins = ${GLog.object2String(plugins)}")
    return plugins
}

// build.gradle in dependencies DSL
for (def entrySet : ConfigUtils.getApplyPlugins().entrySet()) {
    classpath entrySet.value.dep
}
```

然后我们往 `buildAPP.gradle` 加入 api 的 plugin，具体如下所示：

```groovy
apply {
    ...
    plugin "com.blankj.api"
}
```

现在我们要做一个在 `feature0` 中的 `Feature0Activity` 来启动 `feature1` 中的 `Feature1Activity`，向其传递一个自定义的数据结构，然后获取它传回的返回值。

根据它的说明文档，因为是 `feature0` 调用 `feature1`，所以我们要暴露 `feature1` 中的 `api` 给 `feature0` 用。

我们在 `feature1` 的 `export` 中建立继承自 `ApiUtils.BaseApi` 的 `Feature1Api`，并带上参数和返回值，具体如下所示：

```java
public abstract class Feature1Api extends ApiUtils.BaseApi {
    public abstract Feature1Result startFeature1Activity(Context context, Feature1Param param);
}

public class Feature1Param {

    private String name;

    public Feature1Param(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class Feature1Result {

    private String name;

    public Feature1Result(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

接下来，我们在 `feature1` 的 `pkg` 中来实现其 `api`，如下所示：
```java
@ApiUtils.Api
public class Feature1ApiImpl extends Feature1Api {
    @Override
    public Feature1Result startFeature1Activity(Context context, Feature1Param param) {
        Feature1Activity.start(context);
        LogUtils.d(param.getName());
        return new Feature1Result("Feature1Result");
    }
}
```

我们把 `Feature1ApiImpl` 放在包最外层，把 `Feature1Activity` 放在最外层包新建的一个 `main` 目录里，内部你想用 `mvp`、`mvc`、`mvvm` 随意你选择，结构如下所示：

```
└── feature1
    └── pkg
        └── src
            └── main
                └── java
                    └── com
                        └── blankj
                            └── feature1
                                └── pkg
                                    ├── Feature1ApiImpl.java
                                    └── main
                                        └── Feature1Activity.java
```

其他 `pkg` 也同理如此操作，这样一来方便查询到各模块暴露的接口的实现方式及模块的入口。

接下来就是在 `feature0` 的 `pkg` 中的 `Feature0Activity` 调用了，具体如下所示：

```java
@Override
public void initView(@Nullable Bundle savedInstanceState, @Nullable View contentView) {
    findViewById(R.id.startFeature1Btn).setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Feature1Result result = ApiUtils.getApi(Feature1Api.class)
                    .startFeature1Activity(Feature0Activity.this, new Feature1Param("Feature1Param"));
            ToastUtils.showLong(result.getName());
        }
    });
}
```

接下来我们配置 `Config` 为运行 `launcher` 及全量 `pkg` 的模式：

```groovy
static appConfig = ['launcher']
static pkgConfig = []
```

运行 `launcher-app`，点击 `Start Feature1` 后，可以发现我们可以成功跳转到 `Feature0Activity` 了，并打印了日志和显示了 Toast，说明 `feature1` 接收到了 `feature0` 传递的参数，`feature0` 接收到了 `feature1` 的返回值，跨模块通信成功。

### 更友好的 mock 层
接下来我们修改 `Config` 配置为运行 `launcher` 及只包含 `feature0` 的模式：

```groovy
static appConfig = ['launcher']
static pkgConfig = ['feature0']
```

会发现 `api` 插件提醒我们没有实现 `Feature1Api`，其 `launcher:app` 下 `__api__.json` 如下所示：

```json
{
  "ApiUtilsClass": "com.blankj.utilcode.util.ApiUtils",
  "implApis": {},
  "noImplApis": [
    "com/blankj/feature1/export/api/Feature1Api"
  ]
}
```

这里我们就需要用到 `mock` 层了，它应该只在非全量 `pkg` 的时候起作用，我们先创建 `mock` 模块，然后做如下配置：

```groovy
// Config.depConfig 中加入 mock
feature      : [
                    mock    : new DepConfig(":feature:mock"),
                    ...
]

// ConfigUtils.includeModule() 首行加入是否应用 mock 的判断
if (Config.pkgConfig.isEmpty()) {
    Config.depConfig.feature.mock.isApply = false
}

// buildLib.gradle 修改 dependencies 如下：
dependencies {
    if (project.name == 'pkg' || project.name == 'mock') {
        // if module's name equals 'pkg', api all of export
        for (def entrySet : ConfigUtils.getApplyExports().entrySet()) {
            api entrySet.value.dep
        }
    } else if (project.name == 'export') {
        api Config.depConfig.lib.common.dep
    }
}

// buildApp.gradle 中的 dependencies 加入
if (Config.depConfig.feature.mock.isApply) {
    api Config.depConfig.feature.mock.dep
}
```

Gradle 同步一下，`mock` 模块便会加入到编译中来了，我们在其中加入 `Feature1ApiMock`，并加上 `@ApiUtils.Api(isMock = true)` 注解，并完成 `mock` 的内容，具体如下所示：

```java
@ApiUtils.Api(isMock = true)
public class Feature1ApiMock extends Feature1Api {
    @Override
    public Feature1Result startFeature1Activity(Context context, Feature1Param param) {
        return new Feature1Result("Mock Result");
    }
}
```

现在我们就可以运行 `launcher-app` 了，结果就是点用 `startFeature1Activity` 后会返回其 `mock` 的结果，且当 `isMock = true` 和 `isMock = false` 同时存在的时候，最终以 `isMock = false` 为最终实现方，所以，不用担心 `mock` 层会影响到业务原有的实现，好了，AucFrame 的模块间通信到此已结束，下面再赠送点东西，我们给 Gradle 添加下耗时任务的统计。


## Gradle 耗时任务的统计

我们在 `ConfigUtils` 加入超过 100ms 的任务的统计，并使其排序输出：

```groovy
private List<TaskInfo> taskInfoList = []
private long startBuildMillis

@Override
void settingsEvaluated(Settings settings) {
    startBuildMillis = System.currentTimeMillis()
    ...
}

@Override
void projectsEvaluated(Gradle gradle) {
    GLog.d("projectsEvaluated")
    gradle.addListener(new TaskExecutionListener() {
        @Override
        void beforeExecute(Task task) {
            task.ext.startTime = System.currentTimeMillis()
        }
        @Override
        void afterExecute(Task task, TaskState state) {
            def exeDuration = System.currentTimeMillis() - task.ext.startTime
            if (exeDuration >= 100) {
                taskInfoList.add(new TaskInfo(task, exeDuration))
            }
        }
    })
}

@Override
void buildFinished(BuildResult result) {
    GLog.d("buildFinished")
    if (!taskInfoList.isEmpty()) {
        Collections.sort(taskInfoList, new Comparator<TaskInfo>() {
            @Override
            int compare(TaskInfo t, TaskInfo t1) {
                return t1.exeDuration - t.exeDuration
            }
        })
        StringBuilder sb = new StringBuilder()
        int buildSec = (System.currentTimeMillis() - startBuildMillis) / 1000;
        int m = buildSec / 60;
        int s = buildSec % 60;
        def timeInfo = (m == 0 ? "${s}s" : "${m}m ${s}s (${buildSec}s)")
        sb.append("BUILD FINISHED in $timeInfo")
        taskInfoList.each {
            sb.append(String.format("%7sms %s\n", it.exeDuration, it.task.path))
        }
        def content = sb.toString()
        GLog.l(content)
        File file = new File(result.gradle.rootProject.buildDir.getAbsolutePath(),
                "build_time_records_" + new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss").format(new Date()) + ".txt")
        FileUtils.write(file, content)
    }
}

private static class TaskInfo {
    Task task
    long exeDuration
    TaskInfo(Task task, long exeDuration) {
        this.task = task
        this.exeDuration = exeDuration
    }
}
```

接着，我们运行一下 `./gradlew build` 后便会在根目录的 `build` 中生成超过 100ms 任务的统计列表如下所示：

```
BUILD FINISHED in 40s
   5917ms :feature:launcher:app:transformClassesAndResourcesWithProguardForRelease
   4207ms :feature:mock:lint
   2143ms :feature:launcher:app:transformClassesWithDexBuilderForDebug
   2136ms :feature:launcher:app:transformClassesWithDexBuilderForRelease
   1593ms :feature:launcher:app:transformDexArchiveWithDexMergerForDebug
   1526ms :lib:base:lint
   1336ms :feature:launcher:app:transformClassesWithApiTransformForDebug
    959ms :feature:launcher:app:packageRelease
    730ms :feature:launcher:app:transformClassesWithApiTransformForRelease
    720ms :lib:common:lint
    623ms :feature:mock:compileDebugRenderscript
    600ms :feature:launcher:app:clean
    577ms :feature:launcher:app:lint
    557ms :feature:mock:mergeReleaseResources
    550ms :feature:feature0:pkg:lint
    487ms :feature:feature1:export:mergeReleaseResources
    460ms :feature:launcher:app:transformDexArchiveWithDexMergerForRelease
    446ms :feature:launcher:app:packageDebug
    442ms :feature:feature0:export:mergeReleaseResources
    435ms :lib:base:mergeReleaseResources
    422ms :feature:launcher:app:transformResourcesWithMergeJavaResForDebug
    414ms :lib:common:mergeReleaseResources
    412ms :feature:launcher:app:transformResourcesWithMergeJavaResForRelease
    401ms :feature:mock:verifyReleaseResources
    388ms :feature:launcher:app:mergeDebugResources
    386ms :feature:feature0:pkg:mergeReleaseResources
    378ms :feature:launcher:app:processDebugResources
    359ms :feature:launcher:app:transformNativeLibsWithMergeJniLibsForDebug
    335ms :feature:feature0:pkg:verifyReleaseResources
    332ms :lib:common:verifyReleaseResources
    328ms :feature:launcher:app:processReleaseResources
    319ms :lib:base:verifyReleaseResources
    314ms :feature:feature0:export:verifyReleaseResources
    313ms :feature:feature1:export:verifyReleaseResources
    309ms :feature:feature0:export:lint
    292ms :feature:feature1:export:lint
    286ms :feature:launcher:app:compileDebugJavaWithJavac
    270ms :feature:launcher:app:mergeReleaseResources
    216ms :feature:launcher:app:compileReleaseJavaWithJavac
    210ms :lib:base:generateDebugRFile
    202ms :feature:feature1:export:clean
    194ms :feature:launcher:app:transformNativeLibsWithMergeJniLibsForRelease
    191ms :feature:mock:clean
    183ms :feature:feature0:pkg:clean
    182ms :lib:common:clean
    173ms :lib:base:clean
    164ms :feature:feature0:export:clean
    141ms :lib:base:compileDebugKotlin
    130ms :lib:common:compileDebugJavaWithJavac
    102ms :feature:feature0:pkg:generateDebugRFile
```
