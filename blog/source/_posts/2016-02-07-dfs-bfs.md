---
title: 图的深搜和宽搜C++
categories:
  - 数据结构
tags:
  - 广搜
  - 深搜
date: 2016-02-07 14:58:40
---

第一行输入两个整数 n 和 m，表示顶点数和边数。接下来 m 行，每行输入两个整数 x 和 y，表示一条从 x 连向 y 的无向边。之后输入一个整数 k，表示深度优先搜索的起点。注意顶点是从 0 开始编号的哦。输入完成后会将遍历结果输出。

<!-- more -->
假如输入
<pre>5 6
0 1
1 2
1 3
2 3
0 4
1 4
0</pre>

遍历的结果为
<pre>0
1
2
3
4</pre>


``` cpp
#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

class Graph {
private:
    int n;  //!< 顶点数量
    vector<int> *edges;  //!< 邻接表
    bool *visited;

public:
    Graph(int input_n) {
        n = input_n;
        edges = new vector<int>[n];
        visited=new bool[n];
        memset(visited,0,n);
    }

    ~Graph() {
        delete[] edges;
        delete[] visited;
    }

    void insert(int x, int y) {
        edges[x].push_back(y);
        edges[y].push_back(x);
    }

    void dfs(int vertex) {
        cout<<vertex<<endl;
        visited[vertex]=true;
        for(int adj_vertex:edges[vertex]){
            if(!visited[adj_vertex]){
                dfs(adj_vertex);
            }
        }
    }
};

int main() {
    int n, m, k;
    cin >> n >> m;
    Graph g(n);
    for (int i = 0; i < m; ++i) {
        int x, y;
        cin >> x >> y;
        g.insert(x, y);
    }
    cin >> k;
    g.dfs(k);
    return 0;
}
```

第一行输入两个整数 n 和 m，表示顶点数和边数。接下来 m 行，每行输入两个整数 x 和 y，表示一条从 x 连向 y 的无向边。之后输入一个整数 k，表示广度优先搜索的起点。注意顶点是从 0 开始编号的哦。输入完成后会将遍历结果输出。

假如输入
<pre>5 6
0 1
1 2
1 3
2 3
0 4
1 4
0</pre>

遍历的结果为
<pre>0
1
4
2
3</pre>


``` cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <queue>

using namespace std;

class Graph {
private:
    int n;
    bool *visited;
    vector<int> *edges;    

public:
    Graph(int input_n) {
        n = input_n;
        edges = new vector<int>[n];
        visited = new bool[n];
        memset(visited, 0, n);
    }

    ~Graph() {
        delete[] edges;
        delete[] visited;
    }

    void insert(int x, int y) {
        edges[x].push_back(y);
        edges[y].push_back(x);
    }

    void bfs(int start_vertex) {
        queue<int> bfs_queue;
        bfs_queue.push(start_vertex);
        visited[start_vertex]=true;
        while(!bfs_queue.empty()){
            int vertex=bfs_queue.front();
            cout<<vertex<<endl;
            bfs_queue.pop();
            for(int adj_vertex:edges[vertex]){
                if(!visited[adj_vertex]){
                    visited[adj_vertex]=true;
                    bfs_queue.push(adj_vertex);
                }
            }
        }

    }
};

int main() {
    int n, m, k;
    cin >> n >> m;
    Graph g(n);
    for (int i = 0; i < m; ++i) {
        int x, y;
        cin >> x >> y;
        g.insert(x, y);
    }
    cin >> k;
    g.bfs(k);
    return 0;
}
```