---
title: 动归之数塔
date: 2016-02-04 22:45:37
categories:
  - 数据结构
tags:
  - 动态规划
---

{% asset_img pyramid_of_numbers.jpg  %}

上面这张图是一个数塔问题的例子。每次从顶部元素，就是上图中的9出发，每次可以走到下面相邻的两个节点，比如从9往下相邻的是12和15，6往下相邻的是18和9。找到一条从顶部到底部的路径，使得路径上的数值和最大。

一个直观的贪心策略是每次向下走都选择较大的那一个，得到的一个解是9+15+8+9+10=51，然而我们发现最优的解是9+12+10+18+10=59，也就是说这道题并不适合贪心策略。

接下来我们把问题分解，假如知道从顶点到每个点的最优解的话，最终答案也就能够得出了。假设第i行第j个元素为止的最优解为f[i][j]，可以想到f[i][j]只和f[i-1][j]和f[i-1][j-1](如果存在的话)有关。也就是说第i行的解只会跟第i-1行的一个或两个元素有关。

<!-- more -->

``` cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 100;
// 下面这个函数实现的是更新最大值，o赋值为o和x的最大值
template <class T>
void updateMax(T& o, const T& x) {
    o = (o > x) ? o : x;
}

// f数组为动态规划的状态数组
// num数组为读入的数塔
// n为读入的数塔高度
int f[N][N], num[N][N], n;

int main() {
    // 读入n和数塔数组num
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            scanf("%d", &num[i][j]);
        }
    }

    // step 1 begin: 在这里实现动态规划算法逻辑
     for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= i; ++j) {
            updateMax(f[i][j],max(f[i-1][j],f[i-1][j-1])+num[i][j]);
        }
    }
    // step 1 end.

    // 定义最终结果变量result，因为是计算最大值，所以初始化为0
    int result = 0;
    for (int i = 1; i <= n; ++i) {
        // step 2 begin: 在这里实现更新最终结果的逻辑
        updateMax(result,f[n][i]);
        // step 2 end.
    }
    // 输出最终最大权值和result
    printf("%d\n", result);
    return 0;
}
```